###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     02/Jul/2013  21:36:57 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\uart.c                                         #
#    Command line =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\uart.c -D DEBUG -D                             #
#                    "BOARD_HEADER=\"hal/micro/cortexm3/em35x/board/dev0680.h #
#                    \"" -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/ia #
#                    r.h\"" -D HAL_MICRO -D CORTEXM3 -D CORTEXM3_EM357 -D     #
#                    PHY_EM3XX -D BOARD_DEV0680 -D                            #
#                    "CONFIGURATION_HEADER=\"app/sensor/sensor-configuration. #
#                    h\"" -D SINK_APP -D EMBER_SERIAL1_MODE=EMBER_SERIAL_FIFO #
#                     -D EMBER_SERIAL1_TX_QUEUE_SIZE=128 -D                   #
#                    EMBER_SERIAL1_RX_QUEUE_SIZE=16 -D EMBER_SERIAL0_DEBUG    #
#                    -D EMBER_SERIAL0_MODE=EMBER_SERIAL_FIFO -D               #
#                    EMBER_SERIAL0_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL0_RX_QUEUE_SIZE=64 -D                        #
#                    SCAN_DEBUG_PRINT_ENABLE -D USE_BOOTLOADER_LIB -D         #
#                    "__SOURCEFILE__=\"uart.c\"" -lC                          #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\            #
#                    --diag_suppress Pa050 -o F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\build\sink-cortexm3-iar-em357-em3xx-dev0 #
#                    680-debug\Obj\ --debug --endian=little --cpu=Cortex-M3   #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I F:\Firmware\emberZNet\firmware\EmberZNet\EM35x #
#                    \hal\micro\cortexm3\ -I F:\Firmware\emberZNet\firmware\E #
#                    mberZNet\EM35x\app\sensor\ewb-em357\..\..\..\ -I         #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\STACK\ -I                           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\HAL\ -I                             #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -Ohz --use_c++_inline              #
#    List file    =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\uart.lst    #
#    Object file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Obj\uart.o      #
#                                                                             #
#                                                                             #
###############################################################################

F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro\cortexm3\uart.c
      1          /** @file hal/micro/cortexm3/uart.c
      2           *  @brief EM3XX UART Library.
      3           *
      4           * <!-- Author(s): Brooks Barrett -->
      5           * <!-- Copyright 2009-2010 by Ember Corporation. All rights reserved.  *80*-->
      6           */
      7          
      8          #include PLATFORM_HEADER
      9          #include "stack/include/ember.h"
     10          #include "stack/include/error.h"
     11          #include "hal/hal.h"
     12          #include "hal/micro/micro-types.h"
     13          
     14          #if (! defined(EMBER_STACK_IP))
     15          #include "stack/include/packet-buffer.h"
     16          #endif
     17          
     18          #include "app/util/serial/serial.h"
     19          #include "hal/micro/cortexm3/usb.h"
     20          
     21          #if defined(EZSP_UART) && \
     22              !defined(EMBER_SERIAL1_RTSCTS) && \
     23              !defined(EMBER_SERIAL1_XONXOFF)
     24            #error EZSP-UART requires either RTS/CTS or XON/XOFF flow control!
     25          #endif
     26          
     27          #ifdef EMBER_SERIAL1_RTSCTS
     28            #if EMBER_SERIAL1_MODE != EMBER_SERIAL_BUFFER
     29            #error "Illegal serial port 1 configuration"
     30            #endif
     31          #endif
     32          
     33          #ifdef EMBER_SERIAL1_XONXOFF
     34            #if EMBER_SERIAL1_MODE != EMBER_SERIAL_FIFO
     35            #error "Illegal serial port 1 configuration"
     36            #endif
     37          
     38            static void halInternalUart1ForceXon(void); // forward declaration
     39          
     40            static int8s xcmdCount;     // num XONs sent to host, written only by tx isr
     41                                        //-1 means an XOFF was sent last
     42                                        // 0 means ready to rx, but no XON has been sent
     43                                        // n>0 means ready to rx, and n XONs have been sent
     44            static int8u xonXoffTxByte; // if non-zero, an XON or XOFF byte to send ahead
     45                                        // of tx queue - cleared when byte is sent
     46            static int8u xonTimer;      // time when last data rx'ed from host, or when
     47                                        // an XON was sent (in 1/4 ticks)
     48          
     49            #define ASCII_XON         0x11  // requests host to pause sending 
     50            #define ASCII_XOFF        0x13  // requests host to resume sending
     51            #define XON_REFRESH_TIME  8     // delay between repeat XONs (1/4 sec units)
     52            #define XON_REFRESH_COUNT 3     // max number of repeat XONs to send after 1st
     53          
     54            // Define thresholds for XON/XOFF flow control in terms of queue used values
     55            // Take into account the 4 byte transmit FIFO
     56            #if (EMBER_SERIAL1_RX_QUEUE_SIZE == 128)
     57              #define XON_LIMIT       16    // send an XON
     58              #define XOFF_LIMIT      96    // send an XOFF
     59            #elif (EMBER_SERIAL1_RX_QUEUE_SIZE == 64)
     60              #define XON_LIMIT       8
     61              #define XOFF_LIMIT      36
     62            #elif (EMBER_SERIAL1_RX_QUEUE_SIZE == 32)
     63              #define XON_LIMIT       2 
     64              #define XOFF_LIMIT      8
     65            #elif (EMBER_SERIAL1_RX_QUEUE_SIZE > 32)
     66              #define XON_LIMIT       (EMBER_SERIAL1_RX_QUEUE_SIZE/8)
     67              #define XOFF_LIMIT      (EMBER_SERIAL1_RX_QUEUE_SIZE*3/4)
     68            #else
     69              #error "Serial port 1 receive buffer too small!"
     70            #endif
     71          #endif  // EMBER_SERIAL1_XONXOFF
     72          
     73          ////////////////////// SOFTUART Pin and Speed definitions //////////////////////
     74          //use a logic analyzer and trial and error to determine these values if
     75          //the SysTick time changes or you want to try a different baud
     76          //These were found using EMU 0x50
     77          #define FULL_BIT_TIME_PCLK  0x4E0  //9600 baud with FLKC @ PCLK(12MHz)
     78          #define START_BIT_TIME_PCLK 0x09C  //9600 baud with FLKC @ PCLK(12MHz)
     79          #define FULL_BIT_TIME_SCLK  0x9C0  //9600 baud with FLKC @ SCLK(24MHz)
     80          #define START_BIT_TIME_SCLK 0x138  //9600 baud with FLKC @ SCLK(24MHz)
     81          //USE PB6 (GPIO22) for TXD
     82          #define CONFIG_SOFT_UART_TX_BIT() \
     83            GPIO_PCCFGH = (GPIO_PCCFGH&(~PC6_CFG_MASK)) | (1 << PC6_CFG_BIT)
     84          #define SOFT_UART_TX_BIT(bit)  GPIO_PCOUT = (GPIO_PCOUT&(~PC6_MASK))|((bit)<<PC6_BIT)
     85          //USE PB7 (GPIO23) for RXD
     86          #define CONFIG_SOFT_UART_RX_BIT() \
     87            GPIO_PCCFGH = (GPIO_PCCFGH&(~PC7_CFG_MASK)) | (4 << PC7_CFG_BIT)
     88          #define SOFT_UART_RX_BIT  ((GPIO_PCIN&PC7)>>PC7_BIT)
     89          ////////////////////// SOFTUART Pin and Speed definitions //////////////////////
     90          
     91          
     92          #if defined(EMBER_SERIAL1_RTSCTS) && (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
     93            void halInternalUart1RxCheckRts( void );
     94          #else
     95            #define halInternalUart1RxCheckRts()
     96          #endif
     97          
     98          // Allow some code to be disabled (and flash saved) if
     99          //  a port is unused or in low-level driver mode
    100          #if (EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED)
    101            #define EM_SERIAL0_DISABLED
    102          #endif
    103          #if (EMBER_SERIAL0_MODE == EMBER_SERIAL_LOWLEVEL)
    104            #error Serial 0 (Virtual Uart) does not support LOWLEVEL mode
    105          #endif
    106          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED) || \
    107              (EMBER_SERIAL1_MODE == EMBER_SERIAL_LOWLEVEL)
    108            #define EM_SERIAL1_DISABLED
    109          #endif
    110          #if (EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED)
    111            #define EM_SERIAL3_DISABLED
    112          #endif
    113          
    114          #define INVALID -1 // frequency error exceeds +/-0.5%, given sysclock
    115          
    116          // Save flash if ports are undefined
    117          #if     !defined(EM_SERIAL1_DISABLED)
    118          

   \                                 In section .text, align 4, keep-with-next
    119            const int16s baudSettings[] = {
   \                     baudSettings:
   \   00000000   0x9C40 0x4E20      DC16 -25536, 20000, -13333, 10000, 5000, 2500, 1250, -833, 625, -416
   \              0xCBEB 0x2710
   \              0x1388 0x09C4
   \              0x04E2 0xFCBF
   \              0x0271 0xFE60
   \   00000014   0xFEC8 0x00F0      DC16 -312, 240, -208, 156, 120, 104, 52, 26, 13
   \              0xFF30 0x009C
   \              0x0078 0x0068
   \              0x0034 0x001A
   \              0x000D       
   \   00000026   0x00 0x00          DC8 0, 0
    120                // Negative values indicate 0.5 fractional bit should be set
    121          (int16s)40000L,  // 300     0.00%(40000.00) // N.B. this is -25536 special-case
    122               20000,      // 600     0.00%(20000.00)
    123              -13333,      // 900    -0.01%(13333.50 but desire 13333.33; slow by 0.01%)
    124               10000,      // 1200    0.00%(10000.00)
    125                5000,      // 2400    0.00% (5000.00)
    126                2500,      // 4800    0.00% (2500.00)
    127                1250,      // 9600    0.00% (1250.00)
    128                -833,      // 14.4k  -0.02% ( 833.50 but desire 833.33; slow by 0.02%)
    129                 625,      // 19.2k   0.00% ( 625.00)
    130                -416,      // 28.8k  +0.04% ( 416.50 but desire 416.67; fast by 0.04%)
    131                -312,      // 38.4k   0.00% ( 312.50)
    132                 240,      // 50.0k   0.00% ( 240.00)
    133                -208,      // 57.6k  -0.08% ( 208.50 but desire 208.33; slow by 0.08%)
    134                 156,      // 76.8k  +0.16% ( 156.00 but desire 156.25; fast by 0.16%)
    135                 120,      // 100.0k  0.00% ( 120.00)
    136                 104,      // 115.2k +0.16% ( 104.00 but desire 104.17; fast by 0.16%)
    137                  52,      // 230.4k +0.16% (  52.00 but desire  52.08; fast by 0.16%)
    138                  26,      // 460.8k +0.16% (  26.00 but desire  26.04; fast by 0.16%)
    139                 #ifdef EMBER_SERIAL_BAUD_CUSTOM
    140          (int16s) EMBER_SERIAL_BAUD_CUSTOM, //Hook for custom baud rate, see BOARD_HEADER
    141                 #else
    142                  13,      // 921.6k +0.16% (  13.00 but desire  13.02; fast by 0.16%)
    143                 #endif
    144            };
    145          
    146            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    147              //State information for RX DMA Buffer operation
    148              static const int16u fifoSize = EMBER_SERIAL1_RX_QUEUE_SIZE;
    149              static const int16u rxStartIndexB = (EMBER_SERIAL1_RX_QUEUE_SIZE/2);
    150              static int16u prevCountA=0;
    151              static int16u prevCountB=0;
    152              static boolean waitingForTailA = FALSE;
    153              static boolean waitingForTailB = FALSE;
    154              static boolean waitingForInputToB = FALSE;
    155            #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    156          
    157          #endif//!defined(EM_SERIAL1_DISABLED)
    158          
    159          // Forward prototype for TX
    160          void halInternalUart1TxIsr(void);
    161          
    162          //Prototype for Error Marking
    163          static void uartErrorMark(int8u port, int8u errors);
    164          
    165          #if (!defined(EM_SERIAL0_DISABLED) ||\
    166               !defined(EM_SERIAL1_DISABLED) ||\
    167               !defined(EM_SERIAL3_DISABLED))

   \                                 In section .text, align 2, keep-with-next
    168          EmberStatus halInternalUartInit(int8u port,
    169                                          SerialBaudRate rate,
    170                                          SerialParity parity,
    171                                          int8u stopBits)
    172          {
    173            #if !defined(EM_SERIAL0_DISABLED)
    174              if (port == 0) {
   \                     halInternalUartInit:
   \   00000000   0xB900             CBNZ.N   R0,??halInternalUartInit_0
    175                // Nothing special to do since the debug channel handles this
    176                return EMBER_SUCCESS;
    177              }
    178            #endif//!defined(EM_SERIAL0_DISABLED)
    179          
    180            #if !defined(EM_SERIAL1_DISABLED)
    181              #ifdef SOFTUART
    182                //make sure the TX bit starts at idle high
    183                SOFT_UART_TX_BIT(1);
    184                CONFIG_SOFT_UART_TX_BIT();
    185                CONFIG_SOFT_UART_RX_BIT();
    186              #else //SOFTUART
    187                if (port == 1) { 
   \   00000002   0x4770             BX       LR
   \                     ??halInternalUartInit_0:
   \   00000004   0xB510             PUSH     {R4,LR}
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD13C             BNE.N    ??halInternalUartInit_1
    188                int32u tempcfg;
    189          
    190                if ( (rate >= sizeof(baudSettings)/sizeof(*baudSettings)) ||
    191                    (baudSettings[rate] == INVALID) ) {
   \   0000000A   0x2913             CMP      R1,#+19
   \   0000000C   0xD207             BCS.N    ??halInternalUartInit_2
   \   0000000E   0x.... 0x....      ADR.W    R0,baudSettings
   \   00000012   0xF930 0x0011      LDRSH    R0,[R0, R1, LSL #+1]
   \   00000016   0xF04F 0x34FF      MOV      R4,#-1
   \   0000001A   0x42A0             CMP      R0,R4
   \   0000001C   0xD101             BNE.N    ??halInternalUartInit_3
    192                  return EMBER_SERIAL_INVALID_BAUD_RATE;
   \                     ??halInternalUartInit_2:
   \   0000001E   0x2020             MOVS     R0,#+32
   \   00000020   0xBD10             POP      {R4,PC}
    193                }
    194          
    195                if (baudSettings[rate] < 0 && // Negative says set .5 fractional bit
    196              #ifdef  EMBER_SERIAL_BAUD_CUSTOM
    197              #if     (EMBER_SERIAL_BAUD_CUSTOM > 32767L)
    198                    rate != BAUD_CUSTOM &&
    199              #endif//(EMBER_SERIAL_BAUD_CUSTOM > 32767L)
    200              #endif//EMBER_SERIAL_BAUD_CUSTOM
    201                    rate != BAUD_300) { // except BAUD_300 special-case to save flash
   \                     ??halInternalUartInit_3:
   \   00000022   0x....             LDR.N    R4,??DataTable15  ;; 0x4000c854
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD504             BPL.N    ??halInternalUartInit_4
   \   00000028   0xB119             CBZ.N    R1,??halInternalUartInit_4
    202                  SC1_UARTPER  = -baudSettings[rate];
   \   0000002A   0x4240             RSBS     R0,R0,#+0
   \   0000002C   0x6160             STR      R0,[R4, #+20]
    203                  SC1_UARTFRAC = 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE001             B.N      ??halInternalUartInit_5
    204                } else {
    205                  SC1_UARTPER  = baudSettings[rate];
   \                     ??halInternalUartInit_4:
   \   00000032   0x6160             STR      R0,[R4, #+20]
    206                  SC1_UARTFRAC = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??halInternalUartInit_5:
   \   00000036   0x61A0             STR      R0,[R4, #+24]
    207                }
    208          
    209                // Default is always 8 data bits irrespective of parity setting,
    210                // according to Lee, but hack overloads high-order nibble of stopBits to
    211                // allow user to specify desired number of data bits:  7 or 8 (default).
    212                if (((stopBits & 0xF0) >> 4) == 7) {
   \   00000038   0x0918             LSRS     R0,R3,#+4
   \   0000003A   0x2807             CMP      R0,#+7
   \   0000003C   0xBF0C             ITE      EQ 
   \   0000003E   0x2000             MOVEQ    R0,#+0
   \   00000040   0x2002             MOVNE    R0,#+2
    213                  tempcfg = 0;
    214                } else {
    215                  tempcfg = SC_UART8BIT;
    216                }
    217                
    218                if (parity == PARITY_ODD) {
   \   00000042   0x2A01             CMP      R2,#+1
   \   00000044   0xBF08             IT       EQ 
   \   00000046   0xF040 0x0018      ORREQ    R0,R0,#0x18
    219                  tempcfg |= SC_UARTPAR | SC_UARTODD;
   \   0000004A   0xD003             BEQ.N    ??halInternalUartInit_6
    220                } else if( parity == PARITY_EVEN ) {
   \   0000004C   0x2A02             CMP      R2,#+2
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0xF040 0x0008      ORREQ    R0,R0,#0x8
    221                  tempcfg |= SC_UARTPAR;
    222                }
    223          
    224                if ((stopBits & 0x0F) >= 2) {
   \                     ??halInternalUartInit_6:
   \   00000054   0xF003 0x010F      AND      R1,R3,#0xF
   \   00000058   0x2902             CMP      R1,#+2
   \   0000005A   0xBFA8             IT       GE 
   \   0000005C   0xF040 0x0004      ORRGE    R0,R0,#0x4
    225                  tempcfg |= SC_UART2STP;
    226                }
    227                SC1_UARTCFG = tempcfg;
   \   00000060   0x60A0             STR      R0,[R4, #+8]
    228          
    229                SC1_MODE = SC1_MODE_UART;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x6020             STR      R0,[R4, #+0]
    230          
    231                // Int configuration here must also be done in halInternalPowerUpUart()
    232                #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
    233                  // Make the RX Valid interrupt level sensitive (instead of edge)
    234                  // SC1_INTMODE = SC_SPIRXVALMODE;
    235                  // Enable just RX interrupts; TX interrupts are controlled separately
    236                  INT_SC1CFG |= (INT_SCRXVAL   |
    237                                 INT_SCRXOVF   |
    238                                 INT_SC1FRMERR |
    239                                 INT_SC1PARERR);
   \   00000066   0x....             LDR.N    R0,??DataTable15_1  ;; 0x4000a808
   \   00000068   0x6C01             LDR      R1,[R0, #+64]
   \   0000006A   0xF441 0x41C0      ORR      R1,R1,#0x6000
   \   0000006E   0xF041 0x0109      ORR      R1,R1,#0x9
   \   00000072   0x6401             STR      R1,[R0, #+64]
    240                  INT_SC1FLAG = 0xFFFF; // Clear any stale interrupts
   \   00000074   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000078   0x6001             STR      R1,[R0, #+0]
    241                  INT_CFGSET = INT_SC1;
   \   0000007A   0x....             LDR.N    R0,??DataTable15_2  ;; 0xe000e100
   \   0000007C   0x2120             MOVS     R1,#+32
   \   0000007E   0x6001             STR      R1,[R0, #+0]
    242                  #ifdef EMBER_SERIAL1_XONXOFF
    243                    halInternalUart1ForceXon();
    244                  #endif
    245                #elif (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    246                  {
    247                    //setup the addresses for receive DMA
    248                    EmSerialFifoQueue *q = emSerialRxQueues[1];
    249                    int32u startAddress  = (int32u)q->fifo;
    250                    SC1_RXBEGA =  startAddress;
    251                    SC1_RXENDA = (startAddress + fifoSize/2 - 1);
    252                    SC1_RXBEGB = (startAddress + fifoSize/2);
    253                    SC1_RXENDB = (startAddress + fifoSize - 1);
    254                    
    255                    //activate DMA
    256                    SC1_DMACTRL = (SC_RXLODA | SC_RXLODB);
    257                  }
    258                  #ifndef EZSP_UART
    259                    INT_SC1CFG |= (INT_SCRXOVF   |
    260                                   INT_SC1FRMERR |
    261                                   INT_SC1PARERR);
    262                  #endif
    263                  // The receive side of buffer mode does not require any interrupts.
    264                  // The transmit side of buffer mode requires interrupts, which
    265                  // will be configured on demand in halInternalStartUartTx(), so just
    266                  // enable the top level SC1 interrupt for the transmit side.
    267                  INT_SC1FLAG = 0xFFFF; // Clear any stale interrupts
    268                  INT_CFGSET = INT_SC1; // Enable top-level interrupt
    269          
    270                  #ifdef EMBER_SERIAL1_RTSCTS
    271                    // Software-based RTS/CTS needs interrupts on DMA buffer unloading.
    272                    INT_SC1CFG |= (INT_SCRXULDA | INT_SCRXULDB);
    273                    SC1_UARTCFG |= (SC_UARTFLOW | SC_UARTRTS);
    274                  #endif
    275                #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    276          
    277                return EMBER_SUCCESS;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xBD10             POP      {R4,PC}
    278                }
    279              #endif //SOFTUART
    280            #endif//!defined(EM_SERIAL1_DISABLED)
    281          
    282            #if !defined(EM_SERIAL3_DISABLED)
    283              #if defined (CORTEXM3_EM35X_USB)
    284                if ( port == 3 ) {
    285                  halResetWatchdog();
    286                  
    287                  usbConfigEnumerate();
    288                  
    289                  //It is necessary to wait for the COM port on the host to become
    290                  //active before serial port3 can be used.
    291                  int16u startTime = halCommonGetInt16uMillisecondTick();
    292                  while(!comPortActive()) {
    293                    //Give ourselves a healthy 1 second for a COM port to open.
    294                    if(elapsedTimeInt16u(startTime,
    295                                         halCommonGetInt16uMillisecondTick()) > 1000) {
    296                      return EMBER_SERIAL_INVALID_PORT;
    297                    }
    298                  }
    299                  
    300                  return EMBER_SUCCESS;
    301                }
    302              #endif
    303            #endif//!defined(EM_SERIAL3_DISABLED)
    304            
    305            return EMBER_SERIAL_INVALID_PORT;
   \                     ??halInternalUartInit_1:
   \   00000084   0x2021             MOVS     R0,#+33
   \   00000086   0xBD10             POP      {R4,PC}          ;; return
    306          }
    307          #endif//(!defined(EM_SERIAL0_DISABLED) || !defined(EM_SERIAL1_DISABLED))
    308          
    309          #ifdef SOFTUART
    310          //this requires use of the SysTick counter and will destory interrupt latency!
    311          static void softwareUartTxByte(int8u byte)
    312          {
    313            int8u i;
    314            int16u fullBitTime;
    315            
    316            if (CPU_CLKSEL) {
    317              fullBitTime = FULL_BIT_TIME_SCLK;
    318            } else {
    319              fullBitTime = FULL_BIT_TIME_PCLK;
    320            }
    321          
    322          #ifdef EMBER_EMU_TEST
    323              // If we're on the emulator the clock runs at half speed
    324              fullBitTime /= 2;
    325          #endif
    326          
    327            ATOMIC(
    328              ST_RVR = fullBitTime; //set the SysTick reload value register
    329              //enable core clock reference and the counter itself
    330              ST_CSR = (ST_CSR_CLKSOURCE | ST_CSR_ENABLE);
    331              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    332              
    333              //go low for start bit
    334              SOFT_UART_TX_BIT(0); //go low for start bit
    335              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    336              
    337              //loop over all 8 data bits transmitting each
    338              for (i=0;i<8;i++) {
    339                SOFT_UART_TX_BIT(byte&0x1); //data bit
    340                while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    341                byte = (byte>>1);
    342              }
    343          
    344              SOFT_UART_TX_BIT(1); //stop bit
    345              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
    346          
    347              //disable SysTick
    348              ST_CSR = 0;
    349            )
    350          }
    351          #endif //SOFTUART
    352          

   \                                 In section .text, align 4, keep-with-next
    353          void halInternalStartUartTx(int8u port)
    354          {
   \                     halInternalStartUartTx:
   \   00000000   0xB510             PUSH     {R4,LR}
    355            #if     !defined(EM_SERIAL0_DISABLED)
    356              if ( port == 0 ) {
   \   00000002   0xB998             CBNZ.N   R0,??halInternalStartUartTx_0
    357                #if EMBER_SERIAL0_MODE == EMBER_SERIAL_FIFO
    358                  EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[0];
   \   00000004   0x....             LDR.N    R0,??DataTable15_3
   \   00000006   0x6804             LDR      R4,[R0, #+0]
    359                  assert(q->tail == 0);
   \   00000008   0x8860             LDRH     R0,[R4, #+2]
   \   0000000A   0xB130             CBZ.N    R0,??halInternalStartUartTx_1
   \   0000000C   0xB507             PUSH {R0,R1,R2,LR}
   \   0000000E   0xF240 0x1167      MOVW     R1,#+359
   \   00000012   0x.... 0x....      ADR.W    R0,`?<Constant "uart.c">`
   \   00000016   0x.... 0x....      BL       halInternalAssertFailed
    360                  emDebugSendVuartMessage(q->fifo, q->used);
   \                     ??halInternalStartUartTx_1:
   \   0000001A   0x88A1             LDRH     R1,[R4, #+4]
   \   0000001C   0xB2C9             UXTB     R1,R1
   \   0000001E   0x1DA0             ADDS     R0,R4,#+6
   \   00000020   0x.... 0x....      BL       emDebugSendVuartMessage
    361                  q->used = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x80A0             STRH     R0,[R4, #+4]
    362                  q->head = 0;
   \   00000028   0x8020             STRH     R0,[R4, #+0]
    363                  return;
   \   0000002A   0xBD10             POP      {R4,PC}
    364                #endif
    365                #if EMBER_SERIAL0_MODE == EMBER_SERIAL_BUFFER
    366                  EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[0];
    367                  assert(q->nextByte == NULL);
    368                  emSerialBufferNextMessageIsr(q);
    369                  while (q->nextByte != NULL) {
    370                    emDebugSendVuartMessage(q->nextByte, (q->lastByte-q->nextByte)+1);
    371                    emSerialBufferNextBlockIsr(q,0);
    372                  }
    373                  return;
    374                #endif
    375              }
    376            #endif//!defined(EM_SERIAL0_DISABLED)
    377          
    378            #if     !defined(EM_SERIAL1_DISABLED)
    379              #ifdef SOFTUART
    380                if (port == 1) {
    381                  EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[1];
    382                  // Always configure the bit because other operations might have
    383                  // tried to compromise it
    384                  SOFT_UART_TX_BIT(1);
    385                  CONFIG_SOFT_UART_TX_BIT();
    386                  while (q->used > 0) {
    387                    int8u byte = FIFO_DEQUEUE(q, emSerialTxQueueWraps[1]);
    388                    softwareUartTxByte(byte);
    389                  }
    390                  return;
    391                }
    392              #else //SOFTUART
    393                // If the port is configured, go ahead and start transmit
    394                if ( (port == 1) && (SC1_MODE == SC1_MODE_UART) ) {
   \                     ??halInternalStartUartTx_0:
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xBF02             ITTT     EQ 
   \   00000030   0x....             LDREQ.N  R0,??DataTable15  ;; 0x4000c854
   \   00000032   0x6800             LDREQ    R0,[R0, #+0]
   \   00000034   0x2801             CMPEQ    R0,#+1
   \   00000036   0xD10E             BNE.N    ??halInternalStartUartTx_2
    395                  #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
    396                    // Ensure UART TX interrupts are enabled,
    397                    // and call the ISR to send any pending output
    398                    ATOMIC(
    399                      // Enable TX interrupts
    400                      INT_SC1CFG |= (INT_SCTXFREE | INT_SCTXIDLE);
    401                      // Pretend we got a tx interrupt
    402                      halInternalUart1TxIsr();
    403                    )
   \   00000038   0x.... 0x....      BL       _disableBasePri
   \   0000003C   0x4604             MOV      R4,R0
   \   0000003E   0x....             LDR.N    R0,??DataTable15_4  ;; 0x4000a848
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xF041 0x0106      ORR      R1,R1,#0x6
   \   00000046   0x6001             STR      R1,[R0, #+0]
   \   00000048   0x.... 0x....      BL       halInternalUart1TxIsr
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000052   0x.... 0x....      B.W      _writeBasePri
    404                  #elif (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    405                    // Ensure UART TX interrupts are enabled,
    406                    // and call the ISR to send any pending output
    407                    ATOMIC(
    408                      INT_SC1CFG |= (INT_SCTXULDA | INT_SCTXULDB | INT_SCTXIDLE);
    409                      // Pretend we got a tx interrupt
    410                      halInternalUart1TxIsr();
    411                    )
    412                  #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    413                  return;
    414                }
   \                     ??halInternalStartUartTx_2:
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    415              #endif //SOFTUART
    416            #endif//!defined(EM_SERIAL1_DISABLED)
    417          
    418            #if !defined(EM_SERIAL3_DISABLED)
    419              #if defined (CORTEXM3_EM35X_USB)
    420                if ( port == 3 ) {
    421                  #if EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO
    422          
    423                    //Call into the usb.c driver which will operate on serial
    424                    //port 3's Q to transmit data.
    425                    usbTxData();
    426          
    427                    return;
    428                  #endif
    429                }
    430              #endif
    431            #endif//!defined(EM_SERIAL3_DISABLED)
    432          
    433          }
    434          

   \                                 In section .text, align 2, keep-with-next
    435          void halInternalStopUartTx(int8u port)
    436          {
    437            // Nothing for port 0 (virtual uart)
    438          
    439            #if !defined(EM_SERIAL1_DISABLED)
    440              if (port == 1) {
   \                     halInternalStopUartTx:
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD104             BNE.N    ??halInternalStopUartTx_0
    441                #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
    442                  // Disable TX Interrupts
    443                  INT_SC1CFG &= ~(INT_SCTXFREE | INT_SCTXIDLE);
   \   00000004   0x....             LDR.N    R0,??DataTable15_4  ;; 0x4000a848
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF021 0x0106      BIC      R1,R1,#0x6
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    444                #elif (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    445                  // Ensure DMA operations are complete before shutting off interrupts,
    446                  // otherwise we might miss an important interrupt and cause a
    447                  // packet buffer leak, e.g.
    448                  while (SC1_DMACTRL & (SC_TXLODA | SC_TXLODB)) {}
    449                  while ( !(SC1_UARTSTAT & SC_UARTTXIDLE) ) {}
    450                  // Disable TX Interrupts
    451                  INT_SC1CFG &= ~(INT_SCTXULDA | INT_SCTXULDB | INT_SCTXIDLE);
    452                #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    453              }
    454            #endif//!defined(EM_SERIAL1_DISABLED)
    455          }
   \                     ??halInternalStopUartTx_0:
   \   0000000E   0x4770             BX       LR               ;; return
    456          
    457          
    458          //full blocking, no queue overflow issues, can be used in or out of int context
    459          //does not return until character is transmitted.

   \                                 In section .text, align 2, keep-with-next
    460          EmberStatus halInternalForceWriteUartData(int8u port, int8u *data, int8u length)
    461          {
   \                     halInternalForceWriteUartData:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x460B             MOV      R3,R1
   \   00000004   0x4611             MOV      R1,R2
    462            #if !defined(EM_SERIAL0_DISABLED)
    463              if (port == 0) {
   \   00000006   0xB920             CBNZ.N   R0,??halInternalForceWriteUartData_0
    464                emDebugSendVuartMessage(data, length);
   \   00000008   0x4618             MOV      R0,R3
   \   0000000A   0x.... 0x....      BL       emDebugSendVuartMessage
    465                return EMBER_SUCCESS;
   \                     ??halInternalForceWriteUartData_1:
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xBD02             POP      {R1,PC}
    466              }
    467            #endif//!defined(EM_SERIAL0_DISABLED)
    468          
    469            #if !defined(EM_SERIAL1_DISABLED)
    470              #ifdef SOFTUART
    471                if (port == 1) {
    472                  //always configure the bit because other operations might have
    473                  //tried to compromise it
    474                  SOFT_UART_TX_BIT(1);
    475                  CONFIG_SOFT_UART_TX_BIT();
    476                  while (length--) {
    477                    SC1_DATA = *data;
    478                    softwareUartTxByte(*data);
    479                    data++;
    480                  }
    481                  return EMBER_SUCCESS;
    482                }
    483              #else //SOFTUART
    484                //if the port is configured, go ahead and transmit
    485                if ( (port == 1) && (SC1_MODE == SC1_MODE_UART) ) {
   \                     ??halInternalForceWriteUartData_0:
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xBF02             ITTT     EQ 
   \   00000016   0x....             LDREQ.N  R0,??DataTable15_5  ;; 0x4000c83c
   \   00000018   0x6982             LDREQ    R2,[R0, #+24]
   \   0000001A   0x2A01             CMPEQ    R2,#+1
   \   0000001C   0xD007             BEQ.N    ??halInternalForceWriteUartData_2
    486                  while (length--) {
    487                    //spin until data register has room for more data
    488                    while ((SC1_UARTSTAT&SC_UARTTXFREE)!=SC_UARTTXFREE) {}
    489                    SC1_DATA = *data;
    490                    data++;
    491                  }
    492            
    493                  //spin until TX complete (TX is idle)
    494                  while ((SC1_UARTSTAT&SC_UARTTXIDLE)!=SC_UARTTXIDLE) {}
    495            
    496                  return EMBER_SUCCESS;
    497                }
    498              #endif //SOFTUART
    499            #endif//!defined(EM_SERIAL1_DISABLED)
    500            
    501            #if !defined(EM_SERIAL3_DISABLED)
    502              #if defined (CORTEXM3_EM35X_USB)
    503                if(port == 3) {
    504                  //This function will block until done sending all the data.
    505                  usbForceTxData(data, length);
    506                  return EMBER_SUCCESS;
    507                }
    508              #endif
    509            #endif//!defined(EM_SERIAL3_DISABLED)
    510          
    511            return EMBER_SERIAL_INVALID_PORT;
   \   0000001E   0x2021             MOVS     R0,#+33
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
   \                     ??halInternalForceWriteUartData_3:
   \   00000022   0x68C2             LDR      R2,[R0, #+12]
   \   00000024   0x0752             LSLS     R2,R2,#+29
   \   00000026   0xD5FC             BPL.N    ??halInternalForceWriteUartData_3
   \   00000028   0xF813 0x2B01      LDRB     R2,[R3], #+1
   \   0000002C   0x6002             STR      R2,[R0, #+0]
   \                     ??halInternalForceWriteUartData_2:
   \   0000002E   0x460A             MOV      R2,R1
   \   00000030   0x1E51             SUBS     R1,R2,#+1
   \   00000032   0xB2D2             UXTB     R2,R2
   \   00000034   0x2A00             CMP      R2,#+0
   \   00000036   0xD1F4             BNE.N    ??halInternalForceWriteUartData_3
   \                     ??halInternalForceWriteUartData_4:
   \   00000038   0x68C1             LDR      R1,[R0, #+12]
   \   0000003A   0x0649             LSLS     R1,R1,#+25
   \   0000003C   0xD5FC             BPL.N    ??halInternalForceWriteUartData_4
   \   0000003E   0xE7E6             B.N      ??halInternalForceWriteUartData_1
    512          }
    513          
    514          // Useful for waiting on serial port characters before interrupts have been
    515          // turned on.

   \                                 In section .text, align 2, keep-with-next
    516          EmberStatus halInternalForceReadUartByte(int8u port, int8u* dataByte)
    517          {
   \                     halInternalForceReadUartByte:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460D             MOV      R5,R1
    518            EmberStatus err = EMBER_SUCCESS;
   \   00000004   0x2400             MOVS     R4,#+0
    519          
    520            #if !defined(EM_SERIAL0_DISABLED)
    521              if ( port == 0 ) {
   \   00000006   0xB9F8             CBNZ.N   R0,??halInternalForceReadUartByte_0
    522                EmSerialFifoQueue *q = emSerialRxQueues[0];
   \   00000008   0x....             LDR.N    R0,??DataTable15_6
   \   0000000A   0x6806             LDR      R6,[R0, #+0]
    523                ATOMIC(
    524                  if (q->used == 0) {
    525                    WAKE_CORE = WAKE_CORE_FIELD;
    526                  }
    527                  if (q->used > 0) {
    528                    *dataByte = FIFO_DEQUEUE(q, emSerialRxQueueWraps[0]);
    529                  } else {
    530                    err = EMBER_SERIAL_RX_EMPTY;
    531                  }
    532                )
   \   0000000C   0x.... 0x....      BL       _disableBasePri
   \   00000010   0x88B1             LDRH     R1,[R6, #+4]
   \   00000012   0xB911             CBNZ.N   R1,??halInternalForceReadUartByte_1
   \   00000014   0x....             LDR.N    R1,??DataTable15_7  ;; 0x40000024
   \   00000016   0x2220             MOVS     R2,#+32
   \   00000018   0x600A             STR      R2,[R1, #+0]
   \                     ??halInternalForceReadUartByte_1:
   \   0000001A   0x88B1             LDRH     R1,[R6, #+4]
   \   0000001C   0xB181             CBZ.N    R1,??halInternalForceReadUartByte_2
   \   0000001E   0x8871             LDRH     R1,[R6, #+2]
   \   00000020   0x1989             ADDS     R1,R1,R6
   \   00000022   0x7989             LDRB     R1,[R1, #+6]
   \   00000024   0x7029             STRB     R1,[R5, #+0]
   \   00000026   0x8871             LDRH     R1,[R6, #+2]
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x....             LDR.N    R2,??DataTable15_8
   \   0000002C   0x8812             LDRH     R2,[R2, #+0]
   \   0000002E   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   00000032   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   00000036   0x8071             STRH     R1,[R6, #+2]
   \   00000038   0x88B1             LDRH     R1,[R6, #+4]
   \   0000003A   0x1E49             SUBS     R1,R1,#+1
   \   0000003C   0x80B1             STRH     R1,[R6, #+4]
   \   0000003E   0xE000             B.N      ??halInternalForceReadUartByte_3
   \                     ??halInternalForceReadUartByte_2:
   \   00000040   0x2426             MOVS     R4,#+38
   \                     ??halInternalForceReadUartByte_3:
   \   00000042   0x.... 0x....      BL       _writeBasePri
   \   00000046   0xE008             B.N      ??halInternalForceReadUartByte_4
    533              }
    534            #endif//!defined(EM_SERIAL0_DISABLED)
    535          
    536            #if !defined(EM_SERIAL1_DISABLED)
    537              if ( port == 1 ) {
   \                     ??halInternalForceReadUartByte_0:
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD106             BNE.N    ??halInternalForceReadUartByte_4
    538                #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
    539                  if ( SC1_UARTSTAT & SC_UARTRXVAL ) {
   \   0000004C   0x....             LDR.N    R0,??DataTable15_5  ;; 0x4000c83c
   \   0000004E   0x68C1             LDR      R1,[R0, #+12]
   \   00000050   0x0789             LSLS     R1,R1,#+30
   \   00000052   0xBF46             ITTE     MI 
   \   00000054   0x6800             LDRMI    R0,[R0, #+0]
   \   00000056   0x7028             STRBMI   R0,[R5, #+0]
   \   00000058   0x2426             MOVPL    R4,#+38
    540                    *dataByte = (int8u) SC1_DATA;
    541                  } else {
    542                    err = EMBER_SERIAL_RX_EMPTY;
    543                  }
    544                #elif (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    545                  //When in buffer mode, the DMA channel is active and the RXVALID bit (as
    546                  //used above in FIFO mode) will never get set.  To maintain the DMA/Buffer
    547                  //model of operation, we need to break the conceptual model in this function
    548                  //and make a function call upwards away from the hardware.  The ReadByte
    549                  //function calls back down into halInternalUartRxPump and forces the
    550                  //sequencing of the serial queues and the DMA buffer, resulting in a forced
    551                  //read byte being returned if it is there.
    552                  if (emberSerialReadByte(1, dataByte)!=EMBER_SUCCESS) {
    553                    err = EMBER_SERIAL_RX_EMPTY;
    554                  }
    555                #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    556              }
    557            #endif//!defined(EM_SERIAL1_DISABLED)
    558          
    559            return err;
   \                     ??halInternalForceReadUartByte_4:
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    560          }
    561          
    562          // blocks until the text actually goes out

   \                                 In section .text, align 2, keep-with-next
    563          void halInternalWaitUartTxComplete(int8u port)
    564          {
   \                     halInternalWaitUartTxComplete:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    565            halResetWatchdog();
   \   00000004   0x.... 0x....      BL       halInternalResetWatchDog
    566          
    567            // Nothing to do for port 0 (virtual uart)
    568          
    569            #if !defined(EM_SERIAL1_DISABLED) 
    570              if ( port == 1 ) {
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD103             BNE.N    ??halInternalWaitUartTxComplete_0
    571                while ( !(SC1_UARTSTAT & SC_UARTTXIDLE) ) {}
   \                     ??halInternalWaitUartTxComplete_1:
   \   0000000C   0x....             LDR.N    R0,??DataTable15_9  ;; 0x4000c848
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x0640             LSLS     R0,R0,#+25
   \   00000012   0xD5FB             BPL.N    ??halInternalWaitUartTxComplete_1
   \                     ??halInternalWaitUartTxComplete_0:
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    572                return;
    573              }
    574            #endif//!defined(EM_SERIAL1_DISABLED) 
    575          }
    576          
    577          
    578          // Debug Channel calls this ISR to push up data it has received

   \                                 In section .text, align 2, keep-with-next
    579          void halStackReceiveVuartMessage(int8u *data, int8u length)
    580          {
   \                     halStackReceiveVuartMessage:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    581            #if !defined(EM_SERIAL0_DISABLED)
    582              EmSerialFifoQueue *q = emSerialRxQueues[0];
   \   00000002   0x....             LDR.N    R2,??DataTable15_6
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x....             LDR.N    R3,??DataTable15_8
   \   00000008   0xE00F             B.N      ??halStackReceiveVuartMessage_0
    583          
    584              while (length--) {
    585                //Use (emSerialRxQueueSizes - 1) so that the FIFO never completely fills
    586                //and the head never wraps around to the tail
    587                if ((q->used < (emSerialRxQueueSizes[0] - 1))) {
    588                  FIFO_ENQUEUE(q,*data++,emSerialRxQueueWraps[0]);
   \                     ??halStackReceiveVuartMessage_1:
   \   0000000A   0x8814             LDRH     R4,[R2, #+0]
   \   0000000C   0x18A4             ADDS     R4,R4,R2
   \   0000000E   0xF810 0x5B01      LDRB     R5,[R0], #+1
   \   00000012   0x71A5             STRB     R5,[R4, #+6]
   \   00000014   0x8814             LDRH     R4,[R2, #+0]
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \   00000018   0x881D             LDRH     R5,[R3, #+0]
   \   0000001A   0xFB94 0xF6F5      SDIV     R6,R4,R5
   \   0000001E   0xFB05 0x4416      MLS      R4,R5,R6,R4
   \   00000022   0x8014             STRH     R4,[R2, #+0]
   \   00000024   0x8894             LDRH     R4,[R2, #+4]
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0x8094             STRH     R4,[R2, #+4]
    589                } else {    
   \                     ??halStackReceiveVuartMessage_0:
   \   0000002A   0x460C             MOV      R4,R1
   \   0000002C   0x1E61             SUBS     R1,R4,#+1
   \   0000002E   0xB2E4             UXTB     R4,R4
   \   00000030   0xB154             CBZ.N    R4,??halStackReceiveVuartMessage_2
   \   00000032   0x8894             LDRH     R4,[R2, #+4]
   \   00000034   0x....             LDR.N    R5,??DataTable15_10
   \   00000036   0x882D             LDRH     R5,[R5, #+0]
   \   00000038   0x1E6D             SUBS     R5,R5,#+1
   \   0000003A   0x42AC             CMP      R4,R5
   \   0000003C   0xDBE5             BLT.N    ??halStackReceiveVuartMessage_1
    590                  uartErrorMark(0, EMBER_SERIAL_RX_OVERFLOW);
   \   0000003E   0x2123             MOVS     R1,#+35
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000046   0x....             B.N      uartErrorMark
    591                  return;  // no sense in trying to enqueue the rest
    592                }
    593              }
   \                     ??halStackReceiveVuartMessage_2:
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
    594            #else  //!defined(EM_SERIAL0_DISABLED)
    595              return;  // serial 0 not used, drop any input
    596            #endif //!defined(EM_SERIAL0_DISABLED)
    597          }
    598          
    599          
    600          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    601          void halInternalRestartUart1Dma(void)
    602          {
    603            //Reset the DMA software and restart it.
    604            EmSerialFifoQueue *q = emSerialRxQueues[1];
    605            int32u startAddress = (int32u)q->fifo;
    606            int8u head;
    607            int8u tail;
    608            int8u loadA = 0;
    609            int8u loadB = 0;
    610            prevCountA = 0;
    611            prevCountB = 0;
    612            waitingForTailA = FALSE;
    613            waitingForTailB = FALSE;
    614            waitingForInputToB = FALSE;
    615            //reload all defaults addresses - they will be adjusted below if needed
    616            SC1_DMACTRL = SC_RXDMARST;
    617            SC1_RXBEGA =  startAddress;
    618            SC1_RXENDA = (startAddress + fifoSize/2 - 1);
    619            SC1_RXBEGB =  (startAddress + fifoSize/2);
    620            SC1_RXENDB = (startAddress + fifoSize - 1);
    621            
    622            //adjust buffer addresses as needed and reload available buffers
    623            if ( q->used != fifoSize ) {
    624              //we can only reload if the FIFO isn't full!
    625              //the FIFO is not empty or full, figure out what to do:
    626              //at this point we know we always have to adjust ST_ADDR to the head
    627              //we need to know which buffer the head is in, and always load that buff
    628              if ((q->head)<rxStartIndexB) {
    629                SC1_RXBEGA = startAddress + (q->head);
    630                loadA++;
    631              } else {
    632                SC1_RXBEGB = startAddress + (q->head);
    633                loadB++;
    634              }
    635              //check to see if the head and the tail are not in the same buffer
    636              if((q->tail)/(rxStartIndexB)) {
    637                tail = TRUE;  //Tail in B buffer
    638              } else {
    639                tail = FALSE; //Tail in A buffer
    640              }
    641              
    642              if((q->head)/(rxStartIndexB)) {
    643                head = TRUE;  //Head in B buffer
    644              } else {
    645                head = FALSE; //Head in A buffer
    646              }
    647          
    648              if ( tail != head ) {
    649                //the head and the tail are in different buffers
    650                //we need to flag the buffer the tail is in so the Pump function does
    651                //not try to reenable it until it has been drained like normal.
    652                if ((q->tail)<rxStartIndexB) {
    653                  waitingForTailA = TRUE;
    654                } else {
    655                  waitingForTailB = TRUE;
    656                }
    657              } else {
    658                //the head and the tail are in the same buffers
    659                if (q->used <= rxStartIndexB) {
    660                  //The serial FIFO is less no more than half full!
    661                  if (!loadB) {
    662                    //the head is in B, and we're capable of loading A
    663                    //BUT: we can't activate A because the DMA defaults to A first,
    664                    //  and it needs to start using B first to fill from the head
    665                    //  SO, only load A if B hasn't been marked yet for loading.
    666                    loadA++;
    667                  } else {
    668                    //B is loaded and waiting for data, A is being supressed until
    669                    //B receives at least one byte so A doesn't prematurely load and
    670                    //steal bytes meant for B first.
    671                    waitingForTailA = TRUE;
    672                    waitingForInputToB = TRUE;
    673                  }
    674                  //We can always loadB at this point thanks to our waiting* flags.
    675                  loadB++;
    676                } else {
    677                  //The serial FIFO is more than half full!
    678                  //Since this case requires moving an end address of a buffer, which
    679                  //severely breaks DMA'ing into a FIFO, we cannot do anything.
    680                  //Doing nothing is ok because we are more than half full anyways,
    681                  //and under normal operation we would only load a buffer when our
    682                  //used count is less than half full.
    683                  //Configure so the Pump function takes over when the serial FIFO drains
    684                  SC1_RXBEGA =  startAddress;
    685                  SC1_RXBEGB =  (startAddress + fifoSize/2);
    686                  loadA = 0;
    687                  loadB = 0;
    688                  waitingForTailA = TRUE;
    689                  waitingForTailB = TRUE;
    690                }
    691              }
    692              
    693              //Address are set, flags are set, DMA is ready, so now we load buffers
    694              if (loadA) {
    695                SC1_DMACTRL = SC_RXLODA;
    696              }
    697              if (loadB) {
    698                SC1_DMACTRL = SC_RXLODB;
    699              }
    700            } else {
    701              //we're full!!  doh!  have to wait for the FIFO to drain
    702              waitingForTailA = TRUE;
    703              waitingForTailB = TRUE;
    704            }
    705          }
    706          #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    707          
    708          
    709          #if !defined(EM_SERIAL1_DISABLED)

   \                                 In section .text, align 2, keep-with-next
    710          void halInternalUart1RxIsr(int16u causes)
    711          {
   \                     halInternalUart1RxIsr:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    712            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
    713              EmSerialFifoQueue *q = emSerialRxQueues[1];
   \   00000002   0x....             LDR.N    R0,??DataTable15_6
   \   00000004   0x6844             LDR      R4,[R0, #+4]
   \   00000006   0x....             LDR.N    R5,??DataTable15_8
   \   00000008   0x....             LDR.N    R6,??DataTable15_5  ;; 0x4000c83c
   \   0000000A   0xE010             B.N      ??halInternalUart1RxIsr_0
    714          
    715              // At present we really don't care which interrupt(s)
    716              // occurred, just that one did.  Loop reading RXVALID
    717              // data (loop is necessary for bursty data otherwise
    718              // we could leave with RXVALID and not get another
    719              // RXVALID interrupt), processing any errors noted
    720              // along the way.
    721              while ( SC1_UARTSTAT & SC_UARTRXVAL ) {
    722                int8u errors = SC1_UARTSTAT & (SC_UARTFRMERR |
    723                                               SC_UARTRXOVF  |
    724                                               SC_UARTPARERR );
    725                int8u incoming = (int8u) SC1_DATA;
    726          
    727                if ( (errors == 0) && (q->used < (EMBER_SERIAL1_RX_QUEUE_SIZE-1)) ) {
   \                     ??halInternalUart1RxIsr_1:
   \   0000000C   0x88A1             LDRH     R1,[R4, #+4]
   \   0000000E   0x290F             CMP      R1,#+15
   \   00000010   0xD21B             BCS.N    ??halInternalUart1RxIsr_2
    728          #ifdef EMBER_SERIAL1_XONXOFF
    729                  // Discard any XON or XOFF bytes received
    730                  if ( (incoming != ASCII_XON) && (incoming != ASCII_XOFF) ) {
    731                    FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[1]);
    732                  }
    733          #else
    734                  FIFO_ENQUEUE(q, incoming, emSerialRxQueueWraps[1]);
   \   00000012   0x8821             LDRH     R1,[R4, #+0]
   \   00000014   0x1909             ADDS     R1,R1,R4
   \   00000016   0x7188             STRB     R0,[R1, #+6]
   \   00000018   0x8820             LDRH     R0,[R4, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x8869             LDRH     R1,[R5, #+2]
   \   0000001E   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   00000022   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \   00000026   0x8020             STRH     R0,[R4, #+0]
   \   00000028   0x88A0             LDRH     R0,[R4, #+4]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x80A0             STRH     R0,[R4, #+4]
    735          #endif
    736                } else {
   \                     ??halInternalUart1RxIsr_0:
   \   0000002E   0x68F0             LDR      R0,[R6, #+12]
   \   00000030   0x0780             LSLS     R0,R0,#+30
   \   00000032   0xD516             BPL.N    ??halInternalUart1RxIsr_3
   \   00000034   0x68F0             LDR      R0,[R6, #+12]
   \   00000036   0xF010 0x0138      ANDS     R1,R0,#0x38
   \   0000003A   0x6830             LDR      R0,[R6, #+0]
   \   0000003C   0xD0E6             BEQ.N    ??halInternalUart1RxIsr_1
    737                  // Translate error code
    738                  if ( errors == 0 ) {
    739                    errors = EMBER_SERIAL_RX_OVERFLOW;
    740                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERFLOW_ERROR);
    741                  } else if ( errors & SC_UARTRXOVF ) {
   \   0000003E   0x0708             LSLS     R0,R1,#+28
   \   00000040   0xD405             BMI.N    ??halInternalUart1RxIsr_4
    742                    errors = EMBER_SERIAL_RX_OVERRUN_ERROR;
    743                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERRUN_ERROR);
    744                  } else if ( errors & SC_UARTFRMERR ) {
   \   00000042   0x06C8             LSLS     R0,R1,#+27
   \   00000044   0xD505             BPL.N    ??halInternalUart1RxIsr_5
    745                    errors = EMBER_SERIAL_RX_FRAME_ERROR;
   \   00000046   0x2124             MOVS     R1,#+36
   \   00000048   0xE007             B.N      ??halInternalUart1RxIsr_6
    746                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_FRAMING_ERROR);
    747                  } else if ( errors & SC_UARTPARERR ) {
   \                     ??halInternalUart1RxIsr_2:
   \   0000004A   0x2123             MOVS     R1,#+35
   \   0000004C   0xE005             B.N      ??halInternalUart1RxIsr_6
   \                     ??halInternalUart1RxIsr_4:
   \   0000004E   0x2127             MOVS     R1,#+39
   \   00000050   0xE003             B.N      ??halInternalUart1RxIsr_6
   \                     ??halInternalUart1RxIsr_5:
   \   00000052   0x0688             LSLS     R0,R1,#+26
   \   00000054   0xBF4C             ITE      MI 
   \   00000056   0x2125             MOVMI    R1,#+37
   \   00000058   0x2101             MOVPL    R1,#+1
    748                    errors = EMBER_SERIAL_RX_PARITY_ERROR;
    749                  } else { // unknown
    750                    errors = EMBER_ERR_FATAL;
    751                  }
    752                  uartErrorMark(1, errors);
   \                     ??halInternalUart1RxIsr_6:
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       uartErrorMark
   \   00000060   0xE7E5             B.N      ??halInternalUart1RxIsr_0
    753                }
    754          #ifdef EMBER_SERIAL1_XONXOFF
    755                if ((q->used >= XOFF_LIMIT) && (xcmdCount >= 0))  {
    756                  xonXoffTxByte = ASCII_XOFF;
    757                  halInternalStartUartTx(1);
    758                }
    759          #endif
    760              } // end of while ( SC1_UARTSTAT & SC1_UARTRXVAL )
    761          
    762            #elif (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    763              #ifdef EMBER_SERIAL1_RTSCTS
    764                // If RTS is controlled by sw, this ISR is called when a buffer unloads.
    765                if (causes & (INT_SCRXULDA | INT_SCRXULDB)) {
    766                  // Deassert RTS if the rx queue tail is not in an active DMA buffer:
    767                  // if it is, then there's at least one empty DMA buffer 
    768                  if ( !( (emSerialRxQueues[1]->tail < EMBER_SERIAL1_RX_QUEUE_SIZE/2) &&
    769                         (SC1_DMASTAT & SC_RXACTA) ) &&
    770                       !( (emSerialRxQueues[1]->tail >= EMBER_SERIAL1_RX_QUEUE_SIZE/2) 
    771                          && (SC1_DMASTAT & SC_RXACTB) ) ) {
    772                    SC1_UARTCFG &= ~SC_UARTRTS;        // deassert RTS
    773                  }
    774                #ifdef EZSP_UART
    775                  if ( ( (causes & INT_SCRXULDA) && (SC1_DMASTAT & SC_RXOVFA) ) ||
    776                       ( (causes & INT_SCRXULDB) && (SC1_DMASTAT & SC_RXOVFB) ) ) {
    777                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_OVERFLOW_ERROR);
    778                  }
    779                  if ( ( (causes & INT_SCRXULDA) && (SC1_DMASTAT & SC_RXFRMA) ) ||
    780                       ( (causes & INT_SCRXULDB) && (SC1_DMASTAT & SC_RXFRMB) ) ) {
    781                    HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_FRAMING_ERROR);
    782                  }
    783                #else//!EZSP_UART
    784                  causes &= ~(INT_SCRXULDA | INT_SCRXULDB);
    785                  if (causes == 0) { // if no errors in addition, all done
    786                    return;
    787                  }
    788                #endif//EZSP_UART
    789                }
    790              #endif  //#ifdef EMBER_SERIAL1_RTSCTS
    791              #ifndef EZSP_UART
    792              //Load all of the hardware status, then immediately reset so we can process
    793              //what happened without worrying about new data changing these values.
    794              //We're in an error condition anyways, so it is ok to have the DMA disabled
    795              //for a while (less than 80us, while 4 bytes @ 115.2kbps is 350us)
    796              {
    797                EmSerialFifoQueue *q = emSerialRxQueues[1];
    798                int16u status  = SC1_DMASTAT;
    799                int16u errCntA = SC1_RXERRA;
    800                int16u errCntB = SC1_RXERRB;
    801                int32u errorIdx = EMBER_SERIAL1_RX_QUEUE_SIZE*2;
    802                int32u tempIdx;
    803                int32u startAddress = (int32u)q->fifo;
    804          
    805                //interrupts acknowledged at the start of the master SC1 ISR
    806                int16u intSrc  = causes;
    807                int8u errorType = EMBER_SUCCESS;
    808          
    809                SC1_DMACTRL = SC_RXDMARST;  //to clear error
    810                //state fully captured, DMA reset, now we process error and restart
    811              
    812                if ( intSrc & INT_SCRXOVF ) {
    813                  //Read the data register four times to clear
    814                  //the RXOVERRUN condition and empty the FIFO, giving us 4 bytes
    815                  //worth of time (from this point) to reenable the DMA.
    816                  (void) SC1_DATA;
    817                  (void) SC1_DATA;
    818                  (void) SC1_DATA;
    819                  (void) SC1_DATA;
    820          
    821                  if ( status & ( SC_RXFRMA
    822                               | SC_RXFRMB
    823                               | SC_RXPARA
    824                               | SC_RXPARB ) ) {
    825                    //We just emptied hardware FIFO so the overrun condition is cleared.
    826                    //Byte errors require special handling to roll back the serial FIFO.
    827                    goto dealWithByteError;
    828                  }
    829                
    830                //record the error type
    831                emSerialRxError[1] = EMBER_SERIAL_RX_OVERRUN_ERROR;
    832                
    833                //check for a retriggering of the Rx overflow, don't advance FIFO if so
    834                if ( !(waitingForTailA && waitingForTailB) ) {
    835                  //first, move head to end of buffer head is in
    836                  //second, move head to end of other buffer if tail is not in other buffer
    837                  if ((q->head)<rxStartIndexB) {
    838                    //head inside A
    839                    q->used += (rxStartIndexB - q->head);
    840                    q->head = (rxStartIndexB);
    841                    if ((q->tail)<rxStartIndexB) {
    842                      //tail not inside of B
    843                      q->used += rxStartIndexB;
    844                      q->head = 0;
    845                    }
    846                  } else {
    847                    //head inside B
    848                    q->used += (fifoSize - q->head);
    849                    q->head = 0;
    850                    if ((q->tail)>=rxStartIndexB) {
    851                      //tail is not inside of A
    852                      q->used += rxStartIndexB;
    853                      q->head = rxStartIndexB;
    854                    }
    855                  }
    856                }
    857                
    858                //Record the error position in the serial FIFO
    859                if (q->used != fifoSize) {
    860                  //mark the byte at q->head as the error
    861                  emSerialRxErrorIndex[1] = q->head;
    862                } else {
    863                  //Since the FIFO is full, the error index needs special handling
    864                  //so there is no conflict between the head and tail looking at the same
    865                  //index which needs to be marked as an error.
    866                  emSerialRxErrorIndex[1] = RX_FIFO_FULL;
    867                }
    868          
    869                //By now the error is accounted for and the DMA hardware is reset.
    870                //By definition, the overrun error means we have no room left, therefore
    871                //we can't reenable the DMA.  Reset the previous counter states, and set
    872                //the waitingForTail flags to TRUE - this tells the Pump function we have
    873                //data to process.  The Pump function will reenable the buffers as they
    874                //become available, just like normal.
    875                prevCountA = 0;
    876                prevCountB = 0;
    877                waitingForInputToB = FALSE;
    878                waitingForTailA = TRUE;
    879                waitingForTailB = TRUE;
    880                //from this point we fall through to the end of the Isr and return.
    881          
    882                } else {
    883                dealWithByteError:
    884                  //We have a byte error to deal with and possibly more than one byte error,
    885                  //of different types in different DMA buffers, so check each error flag.
    886                  //All four error checks translate the DMA buffer's error position to their
    887                  //position in the serial FIFO, and compares the error locations to find
    888                  //the first error to occur after the head of the FIFO.  This error is the
    889                  //error condition that is stored and operated on.
    890                  if ( status & SC_RXFRMA ) {
    891                    tempIdx = errCntA;
    892                    if (tempIdx < q->head) {
    893                      tempIdx += fifoSize;
    894                    }
    895                    if (tempIdx<errorIdx) {
    896                      errorIdx = tempIdx;
    897                    }
    898                    errorType = EMBER_SERIAL_RX_FRAME_ERROR;
    899                  }
    900                  if ( status & SC_RXFRMB ) {
    901                    tempIdx = (errCntB + SC1_RXBEGB) - startAddress;
    902                    if (tempIdx < q->head) {
    903                      tempIdx += fifoSize;
    904                    }
    905                    if (tempIdx<errorIdx) {
    906                      errorIdx = tempIdx;
    907                    }
    908                    errorType = EMBER_SERIAL_RX_FRAME_ERROR;
    909                  }
    910                  if ( status & SC_RXPARA ) {
    911                    tempIdx = errCntA;
    912                    if (tempIdx < q->head) {
    913                      tempIdx += fifoSize;
    914                    }
    915                    if (tempIdx<errorIdx) {
    916                      errorIdx = tempIdx;
    917                    }
    918                    errorType = EMBER_SERIAL_RX_PARITY_ERROR;
    919                  }
    920                  if ( status & SC_RXPARB ) {
    921                    tempIdx = (errCntB + SC1_RXBEGB) - startAddress;
    922                    if (tempIdx < q->head) {
    923                      tempIdx += fifoSize;
    924                    }
    925                    if (tempIdx<errorIdx) {
    926                      errorIdx = tempIdx;
    927                    }
    928                    errorType = EMBER_SERIAL_RX_PARITY_ERROR;
    929                  }
    930                  
    931                  //We now know the type and location of the first error.
    932                  //Move up to the error location and increase the used count.
    933                  q->head = errorIdx;
    934                  if (q->head < q->tail) {
    935                    q->used = ((q->head + fifoSize) - q->tail);
    936                  } else {
    937                    q->used = (q->head - q->tail);
    938                  }
    939                  
    940                  //Mark the byte at q->head as the error
    941                  emSerialRxError[1] = errorType;
    942                  if (q->used != fifoSize) {
    943                    //mark the byte at q->head as the error
    944                    emSerialRxErrorIndex[1] = q->head;
    945                  } else {
    946                    //Since the FIFO is full, the error index needs special handling
    947                    //so there is no conflict between the head and tail looking at the same
    948                    //index which needs to be marked as an error.
    949                    emSerialRxErrorIndex[1] = RX_FIFO_FULL;
    950                  }
    951                  
    952                  //By now the error is accounted for and the DMA hardware is reset.
    953                  halInternalRestartUart1Dma();
    954                }
    955              }
    956              #endif // #ifndef EZSP_UART
    957            #endif //(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
    958          }
   \                     ??halInternalUart1RxIsr_3:
   \   00000062   0xBD70             POP      {R4-R6,PC}       ;; return
    959          #endif//!defined(EM_SERIAL1_DISABLED)
    960          
    961          
    962          #if !defined(EM_SERIAL3_DISABLED)
    963              #if defined (CORTEXM3_EM35X_USB)
    964              void halInternalUart3RxIsr(int8u *rxData, int8u length)
    965              {
    966                EmSerialFifoQueue *q = emSerialRxQueues[3];
    967                
    968                while(length--) {
    969                  if(q->used < (EMBER_SERIAL3_RX_QUEUE_SIZE-1)) {
    970                    FIFO_ENQUEUE(q, *rxData, emSerialRxQueueWraps[3]);
    971                    rxData++;
    972                  } else {
    973                    uartErrorMark(3, EMBER_SERIAL_RX_OVERFLOW);
    974                    return;
    975                  }
    976                }
    977              }
    978            #endif
    979          #endif
    980          
    981          
    982          #ifdef SOFTUART
    983          //this requires use of the SysTick counter and will destory interrupt latency!
    984          static int8u softwareUartRxByte(void)
    985          {
    986            int8u i;
    987            int8u bit;
    988            int8u byte = 0;
    989            int16u startBitTime, fullBitTime;
    990            
    991            if (CPU_CLKSEL) {
    992              startBitTime = START_BIT_TIME_SCLK;
    993              fullBitTime = FULL_BIT_TIME_SCLK;
    994            } else {
    995              startBitTime = START_BIT_TIME_PCLK;
    996              fullBitTime = FULL_BIT_TIME_PCLK;
    997            }
    998          
    999          #ifdef EMBER_EMU_TEST
   1000              // If we're on the emulator the clock runs at half speed
   1001              startBitTime /= 2;
   1002              fullBitTime /= 2;
   1003          #endif
   1004          
   1005            ATOMIC(
   1006              INTERRUPTS_ON();
   1007              //we can only begin receiveing if the input is idle high
   1008              while (SOFT_UART_RX_BIT != 1) {}
   1009              //now wait for our start bit
   1010              while (SOFT_UART_RX_BIT != 0) {}
   1011              INTERRUPTS_OFF();
   1012              
   1013              //set reload value such that move to the center of an incoming bit
   1014              ST_RVR = startBitTime;
   1015              ST_CVR = 0; //writing the current value will cause it to reset to zero
   1016              //enable core clock reference and the counter itself
   1017              ST_CSR = (ST_CSR_CLKSOURCE | ST_CSR_ENABLE);
   1018              while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 0.5bit time
   1019              //set reload value such that move 1bit time
   1020              ST_RVR = fullBitTime;
   1021              ST_CVR = 0; //writing the current value will cause it to reset to zero
   1022              
   1023              //loop 8 times recieving all 8 bits and building up the byte
   1024              for (i=0;i<8;i++) {
   1025                while ((ST_CSR&ST_CSR_COUNTFLAG) != ST_CSR_COUNTFLAG) {} //wait 1bit time
   1026                bit = SOFT_UART_RX_BIT; //get the data bit
   1027                bit = ((bit&0x1)<<7);
   1028                byte = (byte>>1)|(bit);
   1029              }
   1030          
   1031              //disable SysTick
   1032              ST_CSR = 0;
   1033            )
   1034            return byte;
   1035          }
   1036          #endif //SOFTUART
   1037          

   \                                 In section .text, align 2, keep-with-next
   1038          void halInternalUartRxPump(int8u port)
   1039          {
   1040            #ifdef SOFTUART
   1041              if (port == 1) {
   1042                EmSerialFifoQueue *q = emSerialRxQueues[1];
   1043                int8u errors;
   1044                int8u byte;
   1045          
   1046                //always configure the bit because other operations might have
   1047                //tried to compromise it
   1048                CONFIG_SOFT_UART_RX_BIT();
   1049          
   1050                //this will block waiting for a start bit!
   1051                byte = softwareUartRxByte();
   1052                
   1053                if (q->used < (EMBER_SERIAL1_RX_QUEUE_SIZE-1)) {
   1054                    FIFO_ENQUEUE(q, byte, emSerialRxQueueWraps[1]);
   1055                } else {
   1056                  errors = EMBER_SERIAL_RX_OVERFLOW;
   1057                  uartErrorMark(1, errors);
   1058                }
   1059              }
   1060            #else //SOFTUART
   1061              #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1062                if ( port == 1 ) {
   1063                  EmSerialFifoQueue *q = emSerialRxQueues[1];
   1064                  int8u tail,head;
   1065                  int16u count=0;
   1066                  int8u loadA;
   1067                  int8u loadB;
   1068                  //Load all of the hardware status, so we can process what happened
   1069                  //without worrying about new data changing these values.
   1070                  int8u dmaStatus = SC1_DMACTRL;
   1071                  int16u currCountA = SC1_RXCNTA;
   1072                  int16u currCountB = SC1_RXCNTB;
   1073              
   1074                  //Normal check to see if A has any data
   1075                  if (prevCountA != currCountA) {
   1076                    //Update the counters and head location for the new data
   1077                    count = (currCountA - prevCountA);
   1078                    q->used += count;
   1079                    q->head = (q->head + count) % emSerialRxQueueSizes[1];
   1080                    prevCountA = currCountA;
   1081                    waitingForTailA = TRUE;
   1082                  }
   1083                  //Normal check to see if B has any data at all
   1084                  if (prevCountB != currCountB) {
   1085                    //Update the counters and head location for the new data
   1086                    count = (currCountB - prevCountB);
   1087                    q->used += count;
   1088                    q->head = (q->head + count) % emSerialRxQueueSizes[1];
   1089                    prevCountB = currCountB;
   1090                    waitingForTailB = TRUE;
   1091                    waitingForInputToB = FALSE;
   1092                  }
   1093              
   1094              
   1095                  //if the used count is greater than half the buffer size, nothing can be done
   1096                  if (q->used > rxStartIndexB) {
   1097                    return;
   1098                  }
   1099                  //if nothing is in the FIFO, we can reload both if needed
   1100                  if (q->used == 0) {
   1101                    loadA = TRUE;
   1102                    loadB = TRUE;
   1103                    goto reloadBuffers;
   1104                  }
   1105                  //0 < used < bufferSize, so figure out where tail and head are
   1106                  if((q->tail)/(rxStartIndexB)) { 
   1107                    tail = TRUE;  //Tail in B buffer
   1108                  } else {
   1109                    tail = FALSE; //Tail in A buffer
   1110                  }
   1111                  
   1112                  if(((int16u)(q->head - 1))/(rxStartIndexB)) {
   1113                    head = TRUE;  //Head in B buffer
   1114                  } else {
   1115                    head = FALSE; //Head in A buffer
   1116                  }
   1117                  
   1118                  //To load, the tail must be in the same buffer as the head so we don't
   1119                  //overwrite any bytes that haven't drained from the serial FIFO yet.
   1120                  if (tail!=head) {
   1121                    halInternalUart1RxCheckRts();
   1122                    return;
   1123                  }
   1124                  // Recall tail TRUE means data is inside B
   1125                  loadA = tail;
   1126                  loadB = !tail;
   1127              reloadBuffers:
   1128                  //check if the buffers need to be reloaded
   1129                  if ( (loadA) && (!waitingForInputToB) ) {
   1130                    if ( (dmaStatus&SC_RXLODA)
   1131                        != SC_RXLODA) {
   1132                      //An error interrupt can move the addresses of the buffer
   1133                      //during the flush/reset/reload operation.  At this point the
   1134                      //buffer is clear of any usage, so we can reset the addresses
   1135                      SC1_RXBEGA = (int32u)q->fifo;
   1136                      SC1_RXENDA = (int32u)(q->fifo + fifoSize/2 - 1);
   1137                      prevCountA = 0;
   1138                      waitingForTailA = FALSE;
   1139                      SC1_DMACTRL = SC_RXLODA;
   1140                    }
   1141                  }
   1142                  if (loadB) {
   1143                    if ( (dmaStatus&SC_RXLODB)
   1144                        != SC_RXLODB) {
   1145                      //An error interrupt can move the addresses of the buffer
   1146                      //during the flush/reset/reload operation.  At this point the
   1147                      //buffer is clear of any usage, so we can reset the addresses
   1148                      SC1_RXBEGB = (int32u)(q->fifo + fifoSize/2);
   1149                      SC1_RXENDB = (int32u)(q->fifo + fifoSize - 1);
   1150                      prevCountB = 0;
   1151                      waitingForTailB = FALSE;
   1152                      SC1_DMACTRL = SC_RXLODB;
   1153                    }
   1154                  }
   1155                    halInternalUart1RxCheckRts();
   1156                }
   1157              #endif //(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1158            #endif //SOFTUART
   1159          }
   \                     halInternalUartRxPump:
   \   00000000   0x4770             BX       LR               ;; return
   1160          
   1161          #if defined(EMBER_SERIAL1_RTSCTS) && (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1162          void halInternalUart1RxCheckRts(void)
   1163          {
   1164            // Verify RTS is controlled by SW (not AUTO mode), and isn't already asserted.
   1165            // (The logic to deassert RTS is in halInternalUart1RxIsr().)
   1166            if ((SC1_UARTCFG & (SC_UARTFLOW | SC_UARTAUTO | SC_UARTRTS)) == SC_UARTFLOW) {
   1167              // Assert RTS if the rx queue tail is in an active (or pending) DMA buffer,
   1168              // because this means the other DMA buffer is empty.
   1169              ATOMIC (
   1170                if ( ( (emSerialRxQueues[1]->tail < EMBER_SERIAL1_RX_QUEUE_SIZE/2) &&
   1171                       (SC1_DMACTRL & SC_RXLODA) ) ||
   1172                     ( (emSerialRxQueues[1]->tail >= EMBER_SERIAL1_RX_QUEUE_SIZE/2) 
   1173                        && (SC1_DMACTRL & SC_RXLODB) ) ) {
   1174                    SC1_UARTCFG |= SC_UARTRTS;          // assert RTS
   1175                }
   1176              )
   1177            }
   1178          }
   1179          #endif
   1180          
   1181          #ifdef EMBER_SERIAL1_RTSCTS
   1182          boolean halInternalUart1FlowControlRxIsEnabled(void)
   1183          {
   1184            return ( (SC1_UARTCFG & (SC_UARTFLOW | SC_UARTAUTO | SC_UARTRTS)) ==
   1185                     (SC_UARTFLOW | SC_UARTRTS) );
   1186          }
   1187          #endif
   1188          #ifdef EMBER_SERIAL1_XONXOFF
   1189          boolean halInternalUart1FlowControlRxIsEnabled(void)
   1190          {
   1191            xonTimer = halCommonGetInt16uQuarterSecondTick(); //FIXME move into new func?
   1192            return ( (xonXoffTxByte == 0) && (xcmdCount > 0) );
   1193          }
   1194          
   1195          boolean halInternalUart1XonRefreshDone(void)
   1196          {
   1197            return (xcmdCount == XON_REFRESH_COUNT);
   1198          }
   1199          #endif
   1200          

   \                                 In section .text, align 2, keep-with-next
   1201          boolean halInternalUart1TxIsIdle(void)
   1202          {
   1203            return ( (SC1_MODE == SC1_MODE_UART) && 
   1204                     ((SC1_UARTSTAT & SC_UARTTXIDLE) != 0) );
   \                     halInternalUart1TxIsIdle:
   \   00000000   0x....             LDR.N    R0,??DataTable15_9  ;; 0x4000c848
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD104             BNE.N    ??halInternalUart1TxIsIdle_0
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0980             LSRS     R0,R0,#+6
   \   0000000C   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000010   0x4770             BX       LR
   \                     ??halInternalUart1TxIsIdle_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4770             BX       LR               ;; return
   1205          }
   1206          
   1207          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1208          // If called outside of an ISR, it should be from within an ATOMIC block.

   \                                 In section .text, align 2, keep-with-next
   1209          void halInternalUart1TxIsr(void)
   1210          {
   \                     halInternalUart1TxIsr:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1211            EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[1];
   \   00000002   0x....             LDR.N    R0,??DataTable15_3
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x....             LDR.N    R1,??DataTable15_11
   \   00000008   0x....             LDR.N    R2,??DataTable15_5  ;; 0x4000c83c
   \   0000000A   0xE00E             B.N      ??halInternalUart1TxIsr_0
   1212          
   1213            // At present we really don't care which interrupt(s)
   1214            // occurred, just that one did.  Loop while there is
   1215            // room to send more data and we've got more data to
   1216            // send.  For UART there is no error detection.
   1217          
   1218          #ifdef EMBER_SERIAL1_XONXOFF
   1219            // Sending an XON or XOFF takes priority over data in the tx queue.
   1220            if (xonXoffTxByte && (SC1_UARTSTAT & SC_UARTTXFREE) ) {
   1221              SC1_DATA = xonXoffTxByte;
   1222              if (xonXoffTxByte == ASCII_XOFF) {
   1223                xcmdCount = -1;
   1224                HANDLE_ASH_ERROR(EMBER_COUNTER_ASH_XOFF);
   1225              } else {
   1226                xcmdCount = (xcmdCount < 0) ? 1: xcmdCount + 1;
   1227              }
   1228              xonXoffTxByte = 0;    // clear to indicate XON/XOFF was sent
   1229            }
   1230          #endif
   1231            while ( (q->used > 0) && (SC1_UARTSTAT & SC_UARTTXFREE) ) {
   1232              SC1_DATA = FIFO_DEQUEUE(q, emSerialTxQueueWraps[1]);
   \                     ??halInternalUart1TxIsr_1:
   \   0000000C   0x8843             LDRH     R3,[R0, #+2]
   \   0000000E   0x181B             ADDS     R3,R3,R0
   \   00000010   0x799B             LDRB     R3,[R3, #+6]
   \   00000012   0x6013             STR      R3,[R2, #+0]
   \   00000014   0x8843             LDRH     R3,[R0, #+2]
   \   00000016   0x1C5B             ADDS     R3,R3,#+1
   \   00000018   0x884C             LDRH     R4,[R1, #+2]
   \   0000001A   0xFB93 0xF5F4      SDIV     R5,R3,R4
   \   0000001E   0xFB04 0x3315      MLS      R3,R4,R5,R3
   \   00000022   0x8043             STRH     R3,[R0, #+2]
   \   00000024   0x8883             LDRH     R3,[R0, #+4]
   \   00000026   0x1E5B             SUBS     R3,R3,#+1
   \   00000028   0x8083             STRH     R3,[R0, #+4]
   1233            }
   \                     ??halInternalUart1TxIsr_0:
   \   0000002A   0x8883             LDRH     R3,[R0, #+4]
   \   0000002C   0xB113             CBZ.N    R3,??halInternalUart1TxIsr_2
   \   0000002E   0x68D3             LDR      R3,[R2, #+12]
   \   00000030   0x075B             LSLS     R3,R3,#+29
   \   00000032   0xD4EB             BMI.N    ??halInternalUart1TxIsr_1
   1234          }
   \                     ??halInternalUart1TxIsr_2:
   \   00000034   0xBD30             POP      {R4,R5,PC}       ;; return
   1235          #elif   (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1236          // If called outside of an ISR, it should be from within an ATOMIC block.
   1237          void halInternalUart1TxIsr(void)
   1238          {
   1239            EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[1];
   1240            static EmberMessageBuffer holdBuf[2] = { EMBER_NULL_MESSAGE_BUFFER,
   1241                                                     EMBER_NULL_MESSAGE_BUFFER };
   1242          
   1243            // The only interrupts we care about here are UNLOAD's and IDLE.
   1244            // Our algorithm doesn't really care which interrupt occurred,
   1245            // or even if one really didn't.  If there is data to send and
   1246            // a DMA channel available to send it, then out it goes.
   1247          
   1248            assert( !((q->used == 0) && (q->nextByte != NULL)) );
   1249            while ( q->used > 0 ) {
   1250          
   1251              if ( q->nextByte == NULL ) {
   1252                // new message pending, but nextByte not set up yet
   1253                emSerialBufferNextMessageIsr(q);
   1254              }
   1255          
   1256              // Something to send: do we have a DMA channel to send it on?
   1257              // Probe for an available channel by checking the channel's
   1258              // SC1_DMACTRL.TX_LOAD   == 0 (channel unloaded) &&
   1259              // SC1_DMASTAT.TX_ACTIVE == 0 (channel not active)
   1260              // The latter check should be superfluous but is a safety mechanism.
   1261              if ( !(SC1_DMACTRL & SC_TXLODA) &&
   1262                   !(SC1_DMASTAT & SC_TXACTA) ) {
   1263                // Channel A is available
   1264                SC1_TXBEGA  = (int32u)q->nextByte;
   1265                SC1_TXENDA = (int32u)q->lastByte;
   1266                INT_SC1FLAG = INT_SCTXULDA; // Ack if pending
   1267                SC1_DMACTRL = SC_TXLODA;
   1268                // Release previously held buffer and hold the newly-loaded one
   1269                // so we can safely use emSerialBufferNextBlockIsr() to check for
   1270                // more data to send without the risk of reusing a buffer we're
   1271                // in the process of DMA-ing.
   1272                if (holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER)
   1273                  emberReleaseMessageBuffer(holdBuf[0]);
   1274                holdBuf[0] = q->currentBuffer;
   1275                emberHoldMessageBuffer(holdBuf[0]);
   1276                emSerialBufferNextBlockIsr(q, 1);
   1277              } else
   1278              if ( !(SC1_DMACTRL & SC_TXLODB) &&
   1279                   !(SC1_DMASTAT & SC_TXACTB) ) {
   1280                // Channel B is available
   1281                SC1_TXBEGB  = (int32u)q->nextByte;
   1282                SC1_TXENDB = (int32u)q->lastByte;
   1283                INT_SC1FLAG = INT_SCTXULDB; // Ack if pending
   1284                SC1_DMACTRL = SC_TXLODB;
   1285                // Release previously held buffer and hold the newly-loaded one
   1286                // so we can safely use emSerialBufferNextBlockIsr() to check for
   1287                // more data to send without the risk of reusing a buffer we're
   1288                // in the process of DMA-ing.
   1289                if (holdBuf[1] != EMBER_NULL_MESSAGE_BUFFER)
   1290                  emberReleaseMessageBuffer(holdBuf[1]);
   1291                holdBuf[1] = q->currentBuffer;
   1292                emberHoldMessageBuffer(holdBuf[1]);
   1293                emSerialBufferNextBlockIsr(q, 1);
   1294              } else {
   1295                // No channels available; can't send anything now so break out of loop
   1296                break;
   1297              }
   1298          
   1299            } // while ( q->used > 0 )
   1300          
   1301            // Release previously-held buffer(s) from an earlier DMA operation
   1302            // if that channel is now free (i.e. it's completed the DMA and we
   1303            // didn't need to use that channel for more output in this call).
   1304            if ( (holdBuf[0] != EMBER_NULL_MESSAGE_BUFFER) &&
   1305                 !(SC1_DMACTRL & SC_TXLODA) &&
   1306                 !(SC1_DMASTAT & SC_TXACTA) ) {
   1307              emberReleaseMessageBuffer(holdBuf[0]);
   1308              holdBuf[0] = EMBER_NULL_MESSAGE_BUFFER;
   1309            }
   1310            if ( (holdBuf[1] != EMBER_NULL_MESSAGE_BUFFER) &&
   1311                 !(SC1_DMACTRL & SC_TXLODB) &&
   1312                 !(SC1_DMASTAT & SC_TXACTB) ) {
   1313              emberReleaseMessageBuffer(holdBuf[1]);
   1314              holdBuf[1] = EMBER_NULL_MESSAGE_BUFFER;
   1315            }
   1316          }
   1317          #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1318          
   1319          
   1320          #if !defined(EM_SERIAL1_DISABLED)
   1321            //The following registers are the only SC1-UART registers that need to be
   1322            //saved across deep sleep cycles.  All other SC1-UART registers are 
   1323            //reenabled or restarted using more complex init or restart algorithms.

   \                                 In section .bss, align 4
   1324            static int32u  SC1_UARTPER_SAVED;
   \                     SC1_UARTPER_SAVED:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   1325            static int32u  SC1_UARTFRAC_SAVED;
   1326            static int32u  SC1_UARTCFG_SAVED;
   1327          #endif//!defined(EM_SERIAL1_DISABLED)
   1328          

   \                                 In section .text, align 2, keep-with-next
   1329          void halInternalPowerDownUart(void)
   1330          {
   1331            #if !defined(EM_SERIAL1_DISABLED)
   1332              SC1_UARTPER_SAVED = SC1_UARTPER;
   \                     halInternalPowerDownUart:
   \   00000000   0x....             LDR.N    R0,??DataTable15_12  ;; 0x4000c85c
   \   00000002   0x....             LDR.N    R1,??DataTable15_13
   \   00000004   0x68C2             LDR      R2,[R0, #+12]
   \   00000006   0x600A             STR      R2,[R1, #+0]
   1333              SC1_UARTFRAC_SAVED = SC1_UARTFRAC;
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   1334              SC1_UARTCFG_SAVED = SC1_UARTCFG;
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6088             STR      R0,[R1, #+8]
   1335            #endif//!defined(EM_SERIAL1_DISABLED)
   1336          }
   \   00000010   0x4770             BX       LR               ;; return
   1337          

   \                                 In section .text, align 2, keep-with-next
   1338          void halInternalPowerUpUart(void)
   1339          {
   1340            #if !defined(EM_SERIAL1_DISABLED)
   1341              SC1_UARTPER = SC1_UARTPER_SAVED;
   \                     halInternalPowerUpUart:
   \   00000000   0x....             LDR.N    R0,??DataTable15  ;; 0x4000c854
   \   00000002   0x....             LDR.N    R1,??DataTable15_13
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x6142             STR      R2,[R0, #+20]
   1342              SC1_UARTFRAC = SC1_UARTFRAC_SAVED;
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x6182             STR      R2,[R0, #+24]
   1343              SC1_UARTCFG = SC1_UARTCFG_SAVED;
   \   0000000C   0x6889             LDR      R1,[R1, #+8]
   \   0000000E   0x6081             STR      R1,[R0, #+8]
   1344          
   1345              SC1_MODE = SC1_MODE_UART;
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x6001             STR      R1,[R0, #+0]
   1346          
   1347              // Int configuration here must match that of halInternalUartInit()
   1348              #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1349                // Make the RX Valid interrupt level sensitive (instead of edge)
   1350                // SC1_INTMODE = SC_SPIRXVALMODE;
   1351                // Enable just RX interrupts; TX interrupts are controlled separately
   1352                INT_SC1CFG |= (INT_SCRXVAL   |
   1353                               INT_SCRXOVF   |
   1354                               INT_SC1FRMERR |
   1355                               INT_SC1PARERR);
   \   00000014   0x....             LDR.N    R0,??DataTable15_1  ;; 0x4000a808
   \   00000016   0x6C01             LDR      R1,[R0, #+64]
   \   00000018   0xF441 0x41C0      ORR      R1,R1,#0x6000
   \   0000001C   0xF041 0x0109      ORR      R1,R1,#0x9
   \   00000020   0x6401             STR      R1,[R0, #+64]
   1356                INT_SC1FLAG = 0xFFFF; // Clear any stale interrupts
   \   00000022   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1357                INT_CFGSET = INT_SC1;
   \   00000028   0x....             LDR.N    R0,??DataTable15_2  ;; 0xe000e100
   \   0000002A   0x2120             MOVS     R1,#+32
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   1358              #elif (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1359                halInternalRestartUart1Dma();
   1360                #ifndef EZSP_UART
   1361                  INT_SC1CFG |= (INT_SCRXOVF   |
   1362                                 INT_SC1FRMERR |
   1363                                 INT_SC1PARERR);
   1364                #endif
   1365                // The receive side of buffer mode does not require any interrupts.
   1366                // The transmit side of buffer mode requires interrupts, which
   1367                // will be configured on demand in halInternalStartUartTx(), so just
   1368                // enable the top level SC1 interrupt for the transmit side.
   1369                INT_SC1FLAG = 0xFFFF; // Clear any stale interrupts
   1370                INT_CFGSET = INT_SC1; // Enable top-level interrupt
   1371          
   1372                #ifdef EMBER_SERIAL1_RTSCTS
   1373                  // Software-based RTS/CTS needs interrupts on DMA buffer unloading.
   1374                  INT_SC1CFG |= (INT_SCRXULDA | INT_SCRXULDB);
   1375                #endif
   1376              #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1377            #endif//!defined(EM_SERIAL1_DISABLED)
   1378            
   1379            #if !defined(EM_SERIAL3_DISABLED)
   1380              #if defined (CORTEXM3_EM35X_USB)
   1381                //Remember, halInternalPowerUpUart does not return anything.  Powering
   1382                //up the USB requires going through its normal configuration and
   1383                //enumeration process.
   1384                usbConfigEnumerate();
   1385              #endif
   1386            #endif//!defined(EM_SERIAL3_DISABLED)
   1387          
   1388          }
   \   0000002E   0x4770             BX       LR               ;; return
   1389          
   1390          

   \                                 In section .text, align 2, keep-with-next
   1391          void halInternalRestartUart(void)
   1392          {
   1393            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1394              halInternalRestartUart1Dma();
   1395            #endif//(EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER)
   1396          }
   \                     halInternalRestartUart:
   \   00000000   0x4770             BX       LR               ;; return
   1397          
   1398          #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO) && defined(EMBER_SERIAL1_XONXOFF)
   1399          void halInternalUartFlowControl(int8u port)
   1400          {
   1401            if (port == 1) {
   1402              int16u used = emSerialRxQueues[1]->used;
   1403              int8u time = halCommonGetInt16uQuarterSecondTick();
   1404          
   1405              if (used) {
   1406                xonTimer = time;
   1407              }
   1408              // Send an XON if the rx queue is below the XON threshold
   1409              // and an XOFF had been sent that needs to be reversed
   1410              ATOMIC(
   1411                if ( (xcmdCount == -1) && (used <= XON_LIMIT) ) {
   1412                  halInternalUart1ForceXon();
   1413                } else if ( (used == 0) && 
   1414                            ((int8u)(time - xonTimer) >= XON_REFRESH_TIME) && 
   1415                            (xcmdCount < XON_REFRESH_COUNT) ) {
   1416                  halInternalUart1ForceXon();
   1417                }
   1418              )
   1419            }
   1420          }
   1421          #endif
   1422          
   1423          #ifdef EMBER_SERIAL1_XONXOFF
   1424          // Must be called from within an ATOMIC block.
   1425          static void halInternalUart1ForceXon(void)
   1426          {
   1427            if (xonXoffTxByte == ASCII_XOFF) {  // if XOFF waiting to be sent, cancel it
   1428              xonXoffTxByte = 0;
   1429              xcmdCount = 0;
   1430            } else {                            // else, send XON and record the time
   1431              xonXoffTxByte = ASCII_XON;
   1432              halInternalStartUartTx(1);
   1433            }
   1434            xonTimer = halCommonGetInt16uQuarterSecondTick();
   1435          }
   1436          #endif
   1437          
   1438          #if !defined(EM_SERIAL1_DISABLED)

   \                                 In section .text, align 2, keep-with-next
   1439          void halSc1Isr(void)
   1440          {
   \                     halSc1Isr:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1441            int32u interrupt;
   1442          
   1443            //this read and mask is performed in two steps otherwise the compiler
   1444            //will complain about undefined order of volatile access
   1445            interrupt = INT_SC1FLAG;
   \   00000002   0x....             LDR.N    R4,??DataTable15_1  ;; 0x4000a808
   \   00000004   0xE00D             B.N      ??halSc1Isr_0
   1446            interrupt &= INT_SC1CFG;
   1447            
   1448            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1449              while (interrupt != 0) {
   1450            #endif // (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1451            
   1452            INT_SC1FLAG = interrupt; // acknowledge the interrupts early
   \                     ??halSc1Isr_1:
   \   00000006   0x6025             STR      R5,[R4, #+0]
   1453            
   1454            // RX events
   1455            if ( interrupt & (INT_SCRXVAL   | // RX has data
   1456                              INT_SCRXOVF   | // RX Overrun error
   1457                              INT_SCRXFIN   | // RX done [TWI]
   1458                              INT_SCNAK     | // RX Nack [TWI]
   1459                              INT_SCRXULDA  | // RX DMA A has data
   1460                              INT_SCRXULDB  | // RX DMA B has data
   1461                              INT_SC1FRMERR | // RX Frame error
   1462                              INT_SC1PARERR ) // RX Parity error
   1463               ) {
   \   00000008   0xF246 0x7029      MOVW     R0,#+26409
   \   0000000C   0x4205             TST      R5,R0
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0xB2A8             UXTHNE   R0,R5
   \   00000012   0x.... 0x....      BLNE     halInternalUart1RxIsr
   1464              halInternalUart1RxIsr(interrupt);
   1465            }
   1466            
   1467            // TX events
   1468            if ( interrupt & (INT_SCTXFREE | // TX has room
   1469                              INT_SCTXIDLE | // TX idle (more room)
   1470                              INT_SCTXUND  | // TX Underrun [SPI/TWI]
   1471                              INT_SCTXFIN  | // TX complete [TWI]
   1472                              INT_SCCMDFIN | // TX Start/Stop done [TWI]
   1473                              INT_SCTXULDA | // TX DMA A has room
   1474                              INT_SCTXULDB ) // TX DMA B has room
   1475               ) {
   \   00000016   0xF641 0x00D6      MOVW     R0,#+6358
   \   0000001A   0x4205             TST      R5,R0
   \   0000001C   0xBF18             IT       NE 
   \   0000001E   0x.... 0x....      BLNE     halInternalUart1TxIsr
   1476              halInternalUart1TxIsr();
   1477            }
   1478            
   1479            #if (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1480              interrupt = INT_SC1FLAG;
   \                     ??halSc1Isr_0:
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   1481              interrupt &= INT_SC1CFG;
   \   00000024   0x6C21             LDR      R1,[R4, #+64]
   \   00000026   0xEA11 0x0500      ANDS     R5,R1,R0
   1482            }
   \   0000002A   0xD1EC             BNE.N    ??halSc1Isr_1
   1483            #endif // (EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO)
   1484          }
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1485          #endif//!defined(EM_SERIAL1_DISABLED)
   1486          

   \                                 In section .text, align 2, keep-with-next
   1487          static void uartErrorMark(int8u port, int8u errors) 
   1488          {
   \                     uartErrorMark:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1489            EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000002   0x....             LDR.N    R2,??DataTable15_6
   \   00000004   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   1490            
   1491            // save error code & location in queue
   1492            if ( emSerialRxError[port] == EMBER_SUCCESS ) {
   \   00000008   0x....             LDR.N    R3,??DataTable15_14
   \   0000000A   0x....             LDR.N    R4,??DataTable15_15
   \   0000000C   0x5D05             LDRB     R5,[R0, R4]
   \   0000000E   0xB925             CBNZ.N   R5,??uartErrorMark_0
   1493              emSerialRxErrorIndex[port] = q->head;
   \   00000010   0x8812             LDRH     R2,[R2, #+0]
   \   00000012   0xF823 0x2010      STRH     R2,[R3, R0, LSL #+1]
   1494              emSerialRxError[port] = errors;
   \   00000016   0x5501             STRB     R1,[R0, R4]
   \   00000018   0xBD30             POP      {R4,R5,PC}
   1495            } else {
   1496              // Flush back to previous error location & update value
   1497              q->head = emSerialRxErrorIndex[port];
   \                     ??uartErrorMark_0:
   \   0000001A   0xF833 0x3010      LDRH     R3,[R3, R0, LSL #+1]
   \   0000001E   0x8013             STRH     R3,[R2, #+0]
   1498              emSerialRxError[port] = errors;
   \   00000020   0x5501             STRB     R1,[R0, R4]
   1499              if(q->head < q->tail) {
   \   00000022   0x8851             LDRH     R1,[R2, #+2]
   \   00000024   0x8813             LDRH     R3,[R2, #+0]
   \   00000026   0x428B             CMP      R3,R1
   \   00000028   0xD205             BCS.N    ??uartErrorMark_1
   1500                q->used = (emSerialRxQueueSizes[port] - q->tail) + q->head;   
   \   0000002A   0x....             LDR.N    R4,??DataTable15_10
   \   0000002C   0xF834 0x0010      LDRH     R0,[R4, R0, LSL #+1]
   \   00000030   0x1A40             SUBS     R0,R0,R1
   \   00000032   0x1818             ADDS     R0,R3,R0
   \   00000034   0xE000             B.N      ??uartErrorMark_2
   1501              } else {
   1502                q->used = q->head - q->tail;
   \                     ??uartErrorMark_1:
   \   00000036   0x1A58             SUBS     R0,R3,R1
   \                     ??uartErrorMark_2:
   \   00000038   0x8090             STRH     R0,[R2, #+4]
   1503              }
   1504            }
   1505          }
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x4000C854         DC32     0x4000c854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x4000A808         DC32     0x4000a808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     emSerialTxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x4000A848         DC32     0x4000a848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x4000C83C         DC32     0x4000c83c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     emSerialRxQueues

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x40000024         DC32     0x40000024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x........         DC32     emSerialRxQueueWraps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x4000C848         DC32     0x4000c848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x........         DC32     emSerialRxQueueSizes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x........         DC32     emSerialTxQueueWraps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x4000C85C         DC32     0x4000c85c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     SC1_UARTPER_SAVED

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x........         DC32     emSerialRxErrorIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x........         DC32     emSerialRxError

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "uart.c">`:
   \   00000000   0x75 0x61          DC8 "uart.c"
   \              0x72 0x74    
   \              0x2E 0x63    
   \              0x00         
   \   00000007   0x00               DC8 0
   1506          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  halInternalForceReadUartByte
             16 -> _disableBasePri
             16 -> _writeBasePri
        8  halInternalForceWriteUartData
              8 -> emDebugSendVuartMessage
        0  halInternalPowerDownUart
        0  halInternalPowerUpUart
        0  halInternalRestartUart
        8  halInternalStartUartTx
              8 -> _disableBasePri
              0 -> _writeBasePri
              8 -> emDebugSendVuartMessage
              8 -> halInternalAssertFailed
              8 -> halInternalUart1TxIsr
        0  halInternalStopUartTx
       16  halInternalUart1RxIsr
             16 -> uartErrorMark
        0  halInternalUart1TxIsIdle
       12  halInternalUart1TxIsr
        8  halInternalUartInit
        0  halInternalUartRxPump
        8  halInternalWaitUartTxComplete
              8 -> halInternalResetWatchDog
       16  halSc1Isr
             16 -> halInternalUart1RxIsr
             16 -> halInternalUart1TxIsr
       16  halStackReceiveVuartMessage
              0 -> uartErrorMark
       12  uartErrorMark


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "uart.c">
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      12  SC1_UARTPER_SAVED
          SC1_UARTFRAC_SAVED
          SC1_UARTCFG_SAVED
      40  baudSettings
      94  halInternalForceReadUartByte
      64  halInternalForceWriteUartData
      18  halInternalPowerDownUart
      48  halInternalPowerUpUart
       2  halInternalRestartUart
      88  halInternalStartUartTx
      16  halInternalStopUartTx
     100  halInternalUart1RxIsr
      22  halInternalUart1TxIsIdle
      54  halInternalUart1TxIsr
     136  halInternalUartInit
       2  halInternalUartRxPump
      22  halInternalWaitUartTxComplete
      46  halSc1Isr
      74  halStackReceiveVuartMessage
      60  uartErrorMark

 
  12 bytes in section .bss
 958 bytes in section .text
 
 958 bytes of CODE memory
  12 bytes of DATA memory

Errors: none
Warnings: none
