###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     02/Jul/2013  21:36:40 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\micro-common.c                                 #
#    Command line =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\micro-common.c -D DEBUG -D                     #
#                    "BOARD_HEADER=\"hal/micro/cortexm3/em35x/board/dev0680.h #
#                    \"" -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/ia #
#                    r.h\"" -D HAL_MICRO -D CORTEXM3 -D CORTEXM3_EM357 -D     #
#                    PHY_EM3XX -D BOARD_DEV0680 -D                            #
#                    "CONFIGURATION_HEADER=\"app/sensor/sensor-configuration. #
#                    h\"" -D SINK_APP -D EMBER_SERIAL1_MODE=EMBER_SERIAL_FIFO #
#                     -D EMBER_SERIAL1_TX_QUEUE_SIZE=128 -D                   #
#                    EMBER_SERIAL1_RX_QUEUE_SIZE=16 -D EMBER_SERIAL0_DEBUG    #
#                    -D EMBER_SERIAL0_MODE=EMBER_SERIAL_FIFO -D               #
#                    EMBER_SERIAL0_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL0_RX_QUEUE_SIZE=64 -D                        #
#                    SCAN_DEBUG_PRINT_ENABLE -D USE_BOOTLOADER_LIB -D         #
#                    "__SOURCEFILE__=\"micro-common.c\"" -lC                  #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\            #
#                    --diag_suppress Pa050 -o F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\build\sink-cortexm3-iar-em357-em3xx-dev0 #
#                    680-debug\Obj\ --debug --endian=little --cpu=Cortex-M3   #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I F:\Firmware\emberZNet\firmware\EmberZNet\EM35x #
#                    \hal\micro\cortexm3\ -I F:\Firmware\emberZNet\firmware\E #
#                    mberZNet\EM35x\app\sensor\ewb-em357\..\..\..\ -I         #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\STACK\ -I                           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\HAL\ -I                             #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -Ohz --use_c++_inline              #
#    List file    =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\micro-commo #
#                    n.lst                                                    #
#    Object file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Obj\micro-commo #
#                    n.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro\cortexm3\micro-common.c
      1          /*
      2           * File: micro.c
      3           * Description: EM3XX micro specific HAL functions common to 
      4           *  full and minimal hal
      5           *
      6           *
      7           * Copyright 2013 Silicon Laboratories, Inc.                                *80*
      8           */
      9          //[[ Author(s): Brooks Barrett, Lee Taylor ]]
     10          
     11          
     12          #include PLATFORM_HEADER
     13          #include "include/error.h"
     14          #include "hal/micro/micro-common.h"
     15          #include "hal/micro/cortexm3/micro-common.h"
     16          #if defined(BOARD_HEADER) && !defined(MINIMAL_HAL)
     17            #include BOARD_HEADER
     18          #endif //defined(BOARD_HEADER)
     19          
     20          //NOTE:  The reason ENABLE_OSC32K gets translated into an int8u is so that
     21          //       haltest can override the build time configuration and force use of
     22          //       a different OSC32K mode when running the "RTC" command which is used
     23          //       to check proper connectivity of the 32kHz XTAL or external clock.
     24          #define DO_EXPAND(sym)  1 ## sym
     25          #define EXPAND(sym)     DO_EXPAND(sym)
     26          #define CHECK_BLANK_DEFINE(sym) (1 == EXPAND(sym))
     27          #ifdef  ENABLE_OSC32K
     28            #if CHECK_BLANK_DEFINE(ENABLE_OSC32K) // Empty #define => OSC32K_CRYSTAL
     29              #undef  ENABLE_OSC32K
     30              #define ENABLE_OSC32K OSC32K_CRYSTAL // Default if ENABLE_OSC32K is blank
     31            #endif
     32          #else//!ENABLE_OSC32K
     33            #define ENABLE_OSC32K OSC32K_DISABLE // Default if BOARD_HEADER doesn't say
     34          #endif//ENABLE_OSC32K

   \                                 In section .bss, align 1
     35          int8u useOsc32k = ENABLE_OSC32K;
   \                     useOsc32k:
   \   00000000                      DS8 1
     36          #ifndef OSC32K_STARTUP_DELAY_MS
     37            #define OSC32K_STARTUP_DELAY_MS (0) // Not all BOARD_HEADERs define this
     38          #endif//OSC32K_STARTUP_DELAY_MS
     39          

   \                                 In section .text, align 2, keep-with-next
     40          void halInternalEnableWatchDog(void)
     41          {
     42            //Just to be on the safe side, restart the watchdog before enabling it
     43            WDOG_RESET = 1;
   \                     halInternalEnableWatchDog:
   \   00000000   0x....             LDR.N    R0,??DataTable4  ;; 0x40006000
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x6081             STR      R1,[R0, #+8]
     44            WDOG_KEY = 0xEABE;
   \   00000006   0xF64E 0x21BE      MOVW     R1,#+60094
   \   0000000A   0x6041             STR      R1,[R0, #+4]
     45            WDOG_CFG = WDOG_ENABLE;
   \   0000000C   0x....             B.N      ?Subroutine0
     46          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     47          

   \                                 In section .text, align 2, keep-with-next
     48          void halInternalResetWatchDog(void)
     49          {
     50            //Writing any value will restart the watchdog
     51            WDOG_RESET = 1;
   \                     halInternalResetWatchDog:
   \   00000000   0x....             LDR.N    R0,??DataTable4_1  ;; 0x40006008
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
     52          }
     53          

   \                                 In section .text, align 2, keep-with-next
     54          void halInternalDisableWatchDog(int8u magicKey)
     55          {
     56            if (magicKey == MICRO_DISABLE_WATCH_DOG_KEY) {
   \                     halInternalDisableWatchDog:
   \   00000000   0x28A5             CMP      R0,#+165
   \   00000002   0xD105             BNE.N    ??halInternalDisableWatchDog_0
     57              WDOG_KEY = 0xDEAD;
   \   00000004   0x....             LDR.N    R0,??DataTable4  ;; 0x40006000
   \   00000006   0xF64D 0x61AD      MOVW     R1,#+57005
   \   0000000A   0x6041             STR      R1,[R0, #+4]
     58              WDOG_CFG = WDOG_DISABLE;
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x6001             STR      R1,[R0, #+0]
     59            }
     60          }
   \                     ??halInternalDisableWatchDog_0:
   \   00000010   0x4770             BX       LR               ;; return
     61          

   \                                 In section .text, align 2, keep-with-next
     62          boolean halInternalWatchDogEnabled(void)
     63          {
     64            if(WDOG_CFG&WDOG_ENABLE) {
   \                     halInternalWatchDogEnabled:
   \   00000000   0x....             LDR.N    R0,??DataTable4  ;; 0x40006000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2001             MOVNE    R0,#+1
     65              return TRUE;
     66            } else {
     67              return FALSE;
   \   0000000C   0x4770             BX       LR               ;; return
     68            }
     69          }
     70          

   \                                 In section .text, align 2, keep-with-next
     71          void halGpioConfig(int32u io, int32u config)
     72          {
   \                     halGpioConfig:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0882             LSRS     R2,R0,#+2
   \   00000004   0x.... 0x....      ADR.W    R3,??configRegs
   \   00000008   0xF853 0x2022      LDR      R2,[R3, R2, LSL #+2]
   \   0000000C   0x6813             LDR      R3,[R2, #+0]
     73            static volatile int32u *const configRegs[] = 
     74              { (volatile int32u *)GPIO_PACFGL_ADDR,
     75                (volatile int32u *)GPIO_PACFGH_ADDR,
     76                (volatile int32u *)GPIO_PBCFGL_ADDR,
     77                (volatile int32u *)GPIO_PBCFGH_ADDR,
     78                (volatile int32u *)GPIO_PCCFGL_ADDR,
     79                (volatile int32u *)GPIO_PCCFGH_ADDR };
     80            int32u portcfg;
     81            portcfg = *configRegs[io/4];                // get current config                   
     82            portcfg = portcfg & ~((0xF)<<((io&3)*4));   // mask out config of this pin
     83            *configRegs[io/4] = portcfg | (config <<((io&3)*4));
   \   0000000E   0xF000 0x0003      AND      R0,R0,#0x3
   \   00000012   0x0080             LSLS     R0,R0,#+2
   \   00000014   0x240F             MOVS     R4,#+15
   \   00000016   0x4084             LSLS     R4,R4,R0
   \   00000018   0x43A3             BICS     R3,R3,R4
   \   0000001A   0xFA01 0xF000      LSL      R0,R1,R0
   \   0000001E   0x4318             ORRS     R0,R0,R3
   \   00000020   0x6010             STR      R0,[R2, #+0]
     84          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??configRegs:
   \   00000000   0x4000B000         DC32 4000B000H, 4000B004H, 4000B400H, 4000B404H, 4000B800H, 4000B804H
   \              0x4000B004   
   \              0x4000B400   
   \              0x4000B404   
   \              0x4000B800   
   \              0x4000B804   
     85          
     86          //[[ Most of the system-timer functionality is part of the hal-library
     87          //  This functionality is kept public because it depends on configuration 
     88          //  options defined in the BOARD_HEADER.  Only for the full HAL, though. In
     89          //  the minimal HAL if the user has to supply the two ifdefs they do so
     90          //  in whatever manner they choose.
     91          //]]

   \                                 In section .text, align 2, keep-with-next
     92          int16u halInternalStartSystemTimer(void)
     93          {
   \                     halInternalStartSystemTimer:
   \   00000000   0xB580             PUSH     {R7,LR}
     94            //Since the SleepTMR is the only timer maintained during deep sleep, it is
     95            //used as the System Timer (RTC).  We maintain a 32 bit hardware timer
     96            //configured for a tick value time of 1024 ticks/second (0.9765625 ms/tick)
     97            //using either the 10 kHz internal SlowRC clock divided and calibrated to
     98            //1024 Hz or the external 32.768 kHz crystal divided to 1024 Hz.
     99            //With a tick time of ~1ms, this 32bit timer will wrap after ~48.5 days.
    100            
    101            //disable top-level interrupt while configuring
    102            INT_CFGCLR = INT_SLEEPTMR;
   \   00000002   0x....             LDR.N    R0,??DataTable4_2  ;; 0xe000e180
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0x6001             STR      R1,[R0, #+0]
    103            
    104            if (useOsc32k > OSC32K_DISABLE) {
   \   00000008   0x....             LDR.N    R0,??DataTable4_3
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x....             LDR.N    R1,??DataTable4_4  ;; 0x4000600c
   \   0000000E   0x....             LDR.N    R2,??DataTable4_5  ;; 0x40000008
   \   00000010   0xB158             CBZ.N    R0,??halInternalStartSystemTimer_0
    105              if (useOsc32k == OSC32K_DIGITAL) {
   \   00000012   0x2803             CMP      R0,#+3
   \   00000014   0xBF0C             ITE      EQ 
   \   00000016   0x2000             MOVEQ    R0,#+0
   \   00000018   0x2001             MOVNE    R0,#+1
    106                //Disable both OSC32K and SLOWRC if using external digital clock input
    107                SLEEPTMR_CLKEN = 0;
    108              } else { // OSC32K_CRYSTAL || OSC32K_SINE_1V
    109                //Enable the 32kHz XTAL (and disable SlowRC since it is not needed)
    110                SLEEPTMR_CLKEN = SLEEPTMR_CLK32KEN;
   \   0000001A   0x6010             STR      R0,[R2, #+0]
    111              }
    112              //Sleep timer configuration is the same for crystal and external clock
    113              SLEEPTMR_CFG = (SLEEPTMR_ENABLE            | //enable TMR
    114                             (0 << SLEEPTMR_DBGPAUSE_BIT)| //TMR not paused when halted
    115                             (5 << SLEEPTMR_CLKDIV_BIT)  | //divide down to 1024Hz
    116                             (1 << SLEEPTMR_CLKSEL_BIT)) ; //select CLK32K external clock
   \   0000001C   0xF640 0x0051      MOVW     R0,#+2129
   \   00000020   0x6008             STR      R0,[R1, #+0]
    117              halCommonDelayMilliseconds(OSC32K_STARTUP_DELAY_MS);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       halCommonDelayMilliseconds
   \   00000028   0xE006             B.N      ??halInternalStartSystemTimer_1
    118            } else {
    119              //Enable the SlowRC (and disable 32kHz XTAL since it is not needed)
    120              SLEEPTMR_CLKEN = SLEEPTMR_CLK10KEN;
   \                     ??halInternalStartSystemTimer_0:
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x6010             STR      R0,[R2, #+0]
    121              SLEEPTMR_CFG = (SLEEPTMR_ENABLE            | //enable TMR
    122                             (0 << SLEEPTMR_DBGPAUSE_BIT)| //TMR not paused when halted
    123                             (0 << SLEEPTMR_CLKDIV_BIT)  | //already 1024Hz
    124                             (0 << SLEEPTMR_CLKSEL_BIT)) ; //select CLK1K internal SlowRC
   \   0000002E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000032   0x6008             STR      R0,[R1, #+0]
    125              #ifndef DISABLE_RC_CALIBRATION
    126                halInternalCalibrateSlowRc(); //calibrate SlowRC to 1024Hz
   \   00000034   0x.... 0x....      BL       halInternalCalibrateSlowRc
    127              #endif//DISABLE_RC_CALIBRATION
    128            }
    129            
    130            //clear out any stale interrupts
    131            INT_SLEEPTMRFLAG = (INT_SLEEPTMRWRAP | INT_SLEEPTMRCMPA | INT_SLEEPTMRCMPB);
   \                     ??halInternalStartSystemTimer_1:
   \   00000038   0x....             LDR.N    R0,??DataTable4_6  ;; 0x4000a014
   \   0000003A   0x2107             MOVS     R1,#+7
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    132            //turn off second level interrupts.  they will be enabled elsewhere as needed
    133            INT_SLEEPTMRCFG = INT_SLEEPTMRCFG_RESET;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x6401             STR      R1,[R0, #+64]
    134            //enable top-level interrupt
    135            INT_CFGSET = INT_SLEEPTMR;
   \   00000042   0x....             LDR.N    R0,??DataTable4_7  ;; 0xe000e100
   \   00000044   0x2110             MOVS     R1,#+16
   \   00000046   0x6001             STR      R1,[R0, #+0]
    136            
    137            return 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD02             POP      {R1,PC}          ;; return
    138          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40006000         DC32     0x40006000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40006008         DC32     0x40006008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     useOsc32k

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x4000600C         DC32     0x4000600c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40000008         DC32     0x40000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x4000A014         DC32     0x4000a014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0xE000E100         DC32     0xe000e100
    139          
    140          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  halGpioConfig
        0  halInternalDisableWatchDog
        0  halInternalEnableWatchDog
        0  halInternalResetWatchDog
        8  halInternalStartSystemTimer
             8 -> halCommonDelayMilliseconds
             8 -> halInternalCalibrateSlowRc
        0  halInternalWatchDogEnabled


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       6  ?Subroutine0
      24  configRegs
      36  halGpioConfig
      18  halInternalDisableWatchDog
      14  halInternalEnableWatchDog
       2  halInternalResetWatchDog
      76  halInternalStartSystemTimer
      14  halInternalWatchDogEnabled
       1  useOsc32k

 
   1 byte  in section .bss
 222 bytes in section .text
 
 222 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
