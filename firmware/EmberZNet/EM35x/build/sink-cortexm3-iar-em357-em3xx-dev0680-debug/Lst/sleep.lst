###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     02/Jul/2013  21:36:51 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\sleep.c                                        #
#    Command line =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\sleep.c -D DEBUG -D                            #
#                    "BOARD_HEADER=\"hal/micro/cortexm3/em35x/board/dev0680.h #
#                    \"" -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/ia #
#                    r.h\"" -D HAL_MICRO -D CORTEXM3 -D CORTEXM3_EM357 -D     #
#                    PHY_EM3XX -D BOARD_DEV0680 -D                            #
#                    "CONFIGURATION_HEADER=\"app/sensor/sensor-configuration. #
#                    h\"" -D SINK_APP -D EMBER_SERIAL1_MODE=EMBER_SERIAL_FIFO #
#                     -D EMBER_SERIAL1_TX_QUEUE_SIZE=128 -D                   #
#                    EMBER_SERIAL1_RX_QUEUE_SIZE=16 -D EMBER_SERIAL0_DEBUG    #
#                    -D EMBER_SERIAL0_MODE=EMBER_SERIAL_FIFO -D               #
#                    EMBER_SERIAL0_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL0_RX_QUEUE_SIZE=64 -D                        #
#                    SCAN_DEBUG_PRINT_ENABLE -D USE_BOOTLOADER_LIB -D         #
#                    "__SOURCEFILE__=\"sleep.c\"" -lC                         #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\            #
#                    --diag_suppress Pa050 -o F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\build\sink-cortexm3-iar-em357-em3xx-dev0 #
#                    680-debug\Obj\ --debug --endian=little --cpu=Cortex-M3   #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I F:\Firmware\emberZNet\firmware\EmberZNet\EM35x #
#                    \hal\micro\cortexm3\ -I F:\Firmware\emberZNet\firmware\E #
#                    mberZNet\EM35x\app\sensor\ewb-em357\..\..\..\ -I         #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\STACK\ -I                           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\HAL\ -I                             #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -Ohz --use_c++_inline              #
#    List file    =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\sleep.lst   #
#    Object file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Obj\sleep.o     #
#                                                                             #
#                                                                             #
###############################################################################

F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro\cortexm3\sleep.c
      1          /** @file hal/micro/cortexm3/sleep.c
      2           * 
      3           * @brief EM3XX micro specific sleep functions.
      4           *
      5           * <!-- Copyright 2008 by Ember Corporation. All rights reserved.       *80* -->   
      6           */
      7          
      8          #include PLATFORM_HEADER
      9          #include "hal/micro/micro-common.h"
     10          #include "hal/micro/micro.h"
     11          #include "hal/micro/cortexm3/micro-common.h"
     12          #include "hal/micro/cortexm3/memmap.h"
     13          #ifdef MINIMAL_HAL
     14            #define BYPASS_MPU(blah) blah
     15          #else
     16            #include BOARD_HEADER
     17            #include "hal/micro/cortexm3/mpu.h"
     18          #endif //defined(MINIMAL_HAL)
     19          #include "hal/micro/cortexm3/diagnostic.h"
     20          
     21          
     22          //[[
     23          //This function is responsible for manually putting every piece of the Low
     24          //Voltage domain through a fake reset cycle.  This function is intended to
     25          //mimick a Low Voltage domain reset, with the except being any piece of
     26          //the chip that is enabled via cstartup (since cstartup will not be called
     27          //after this function).

   \                                 In section .text, align 2, keep-with-next
     28          void halInternalMimickLvReset(void)
     29          {
     30            //WBB350FIXME -- This function needs to differentiate between DS1 and DS0!!
     31            
     32            // Only three register blocks keep power across deep sleep:
     33            //  CM_HV, GPIO, SLOW_TIMERS
     34            //
     35            // All other register blocks lose their state across deep sleep and we
     36            // must force a reset of them to mimick a LV reset.  The blocks are listed
     37            // here in a loose order of importance.
     38            
     39            //// NVIC          ////
     40            //ST_CSR
     41            //ST_RVR
     42            //ST_CALVR
     43            //INT_CFGCLR
     44            //INT_PENDCLR
     45            //NVIC_IPR_3to0
     46            //NVIC_IPR_7to4
     47            //NVIC_IPR_11to8
     48            //NVIC_IPR_15to12
     49            //NVIC_IPR_19to16
     50            //SCS_VTOR
     51            //SCS_AIRCR
     52            
     53            //// EVENT         ////
     54            //// CM_LV         ////
     55            //// RAM_CTRL      ////
     56            //// FLASH_CONTROL ////
     57            //// TPIU          ////
     58            //// AUX_ADC       ////
     59            //// SERIAL        ////
     60            //// TMR1          ////
     61            //// TMR2          ////
     62            //// ITM           ////
     63            //// DWT           ////
     64            //// FPB           ////
     65            //// CAL_ADC       ////
     66            //// BASEBAND      ////
     67            //// MAC           ////
     68            //// SECURITY      ////
     69            
     70            //WBB350FIXME -- Fill out this function and complete SLEEP13 testcase to
     71            //               cover this
     72          }
   \                     halInternalMimickLvReset:
   \   00000000   0x4770             BX       LR               ;; return
     73          
     74          
     75          #ifdef SLEEP_TRACE //WBB350FIXME -- Find a less intrusive technique
     76            extern boolean sleepTraceOn;
     77            extern int8u sleepTraceBuffer[];
     78            extern int8u sleepTraceIndex;
     79            extern int8u sleepTraceDelayPosition;
     80            #define SLEEP_TRACE_ADD_MARKER(byte)                 \
     81              do {                                               \
     82                if(sleepTraceOn) {                               \
     83                  if(sleepTraceIndex<50) {                       \
     84                    sleepTraceBuffer[sleepTraceIndex] = byte;    \
     85                  }                                              \
     86                  sleepTraceIndex++;                             \
     87                }                                                \
     88              } while(0)
     89            #define SLEEP_TRACE_1SEC_DELAY(position)             \
     90              do {                                               \
     91                if(sleepTraceDelayPosition==position) {          \
     92                  int8u delayCnt=(20*1);                         \
     93                  while(delayCnt-->0) {                          \
     94                    halCommonDelayMicroseconds(50000);           \
     95                  }                                              \
     96                }                                                \
     97              } while(0)
     98          #else //SLEEP_TRACE
     99            #define SLEEP_TRACE_ADD_MARKER(byte) do{}while(0)
    100            #define SLEEP_TRACE_1SEC_DELAY(position) do{}while(0)
    101          #endif //SLEEP_TRACE
    102          //]]
    103          
    104          
    105          //We don't have a real register to hold this composite information.
    106          //Pretend we do so halGetWakeInfo can operate like halGetResetInfo.
    107          //This "register" is only ever set by halSleep.
    108          // [31] = WakeInfoValid
    109          // [30] = SleepSkipped
    110          // [29] = CSYSPWRUPREQ
    111          // [28] = CDBGPWRUPREQ
    112          // [27] = WAKE_CORE
    113          // [26] = TIMER_WAKE_WRAP
    114          // [25] = TIMER_WAKE_COMPB
    115          // [24] = TIMER_WAKE_COMPA
    116          // [23:0] = corresponding GPIO activity
    117          #define WAKEINFOVALID_INTERNAL_WAKE_EVENT_BIT 31
    118          #define SLEEPSKIPPED_INTERNAL_WAKE_EVENT_BIT  30
    119          #define CSYSPWRUPREQ_INTERNAL_WAKE_EVENT_BIT  29
    120          #define CDBGPWRUPREQ_INTERNAL_WAKE_EVENT_BIT  28
    121          #define WAKE_CORE_INTERNAL_WAKE_EVENT_BIT     27
    122          #define WRAP_INTERNAL_WAKE_EVENT_BIT          26
    123          #define CMPB_INTERNAL_WAKE_EVENT_BIT          25
    124          #define CMPA_INTERNAL_WAKE_EVENT_BIT          24
    125          //This define shifts events from the PWRUP_EVENT register into the proper
    126          //place in the halInternalWakeEvent variable
    127          #define INTERNAL_WAKE_EVENT_BIT_SHIFT         20
    128          
    129          static int32u halInternalWakeEvent=0;
    130          

   \                                 In section .text, align 2, keep-with-next
    131          int32u halGetWakeInfo(void)
    132          {
    133            return halInternalWakeEvent;
   \                     halGetWakeInfo:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable5
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x4770             BX       LR               ;; return
    134          }

   \                                 In section .bss, align 4
    135          
    136          //forceSleepTmrCnt is a flag indicating that the system timer module
    137          //should force a fake value for SLEEPTMR_CNT whenever the timer is
    138          //accessed.  For FogBugz 11909/11920 workaround.
    139          boolean forceSleepTmrCnt = FALSE;
   \                     forceSleepTmrCnt:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 4
    140          //wakeupSleepTmrCnt is a capturing of the SLEEPTMR_CNT immediately upon
    141          //waking up from deep sleep.  This value is used to know when the counter
    142          //has ticked forward.  For FogBugz 11909/11920 workaround.
    143          int32u wakeupSleepTmrCnt = 0;
   \                     wakeupSleepTmrCnt:
   \   00000008                      DS8 4
    144          

   \                                 In section .text, align 4, keep-with-next
    145          void halInternalSleep(SleepModes sleepMode)
    146          {
   \                     halInternalSleep:
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB09A             SUB      SP,SP,#+104
    147            //Timer restoring always takes place during the wakeup sequence.  We save
    148            //the state here in case SLEEPMODE_NOTIMER is invoked, which would disable
    149            //the clocks.
    150            int32u SLEEPTMR_CLKEN_SAVED = SLEEPTMR_CLKEN;
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable5_1  ;; 0x40000004
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x9018             STR      R0,[SP, #+96]
    151            
    152            //SLEEPMODE_POWERDOWN and SLEEPMODE_POWERSAVE are deprecated.  Remap them
    153            //to their appropriate, new mode name.
    154            if(sleepMode == SLEEPMODE_POWERDOWN) {
   \   0000000E   0xF89D 0x0068      LDRB     R0,[SP, #+104]
   \   00000012   0x2807             CMP      R0,#+7
   \   00000014   0xBF08             IT       EQ 
   \   00000016   0x2003             MOVEQ    R0,#+3
    155              sleepMode = SLEEPMODE_MAINTAINTIMER;
   \   00000018   0xD002             BEQ.N    ??halInternalSleep_0
    156            } else if(sleepMode == SLEEPMODE_POWERSAVE) {
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD102             BNE.N    ??halInternalSleep_1
    157              sleepMode = SLEEPMODE_WAKETIMER;
   \   0000001E   0x2002             MOVS     R0,#+2
   \                     ??halInternalSleep_0:
   \   00000020   0xF88D 0x0068      STRB     R0,[SP, #+104]
    158            }
    159            
    160            //This code assumes all wake source registers are properly configured.
    161            //As such, it should be called from halSleep() which configues the
    162            //wake sources.
    163            
    164            //The parameter gpioWakeSel is a bitfield composite of the GPIO wake
    165            //sources derived from the 3 ports, indicating which of the 24 GPIO
    166            //are configured as a wake source.
    167            int32u gpioWakeSel  = (GPIO_PAWAKE<<0);
   \                     ??halInternalSleep_1:
   \   00000024   0x.... 0x....      LDR.W    R5,??DataTable5_2  ;; 0x4000bc08
   \   00000028   0x6828             LDR      R0,[R5, #+0]
    168                   gpioWakeSel |= (GPIO_PBWAKE<<8);
   \   0000002A   0x6869             LDR      R1,[R5, #+4]
    169                   gpioWakeSel |= (GPIO_PCWAKE<<16);
   \   0000002C   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000030   0x68A9             LDR      R1,[R5, #+8]
   \   00000032   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000036   0x9000             STR      R0,[SP, #+0]
    170            
    171            //PB2 is also WAKE_SC1.  Set this wake source if PB2's GPIO wake is set.
    172            if(GPIO_PBWAKE & PB2) {
   \   00000038   0x6868             LDR      R0,[R5, #+4]
   \   0000003A   0x0740             LSLS     R0,R0,#+29
   \   0000003C   0xD503             BPL.N    ??halInternalSleep_2
    173              WAKE_SEL |= WAKE_SC1;
   \   0000003E   0x69E0             LDR      R0,[R4, #+28]
   \   00000040   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000044   0x61E0             STR      R0,[R4, #+28]
    174            }
    175            
    176            //PA2 is also WAKE_SC2.  Set this wake source if PA2's GPIO wake is set.
    177            if(GPIO_PAWAKE & PA2) {
   \                     ??halInternalSleep_2:
   \   00000046   0x6828             LDR      R0,[R5, #+0]
   \   00000048   0x0740             LSLS     R0,R0,#+29
   \   0000004A   0xD503             BPL.N    ??halInternalSleep_3
    178              WAKE_SEL |= WAKE_SC2;
   \   0000004C   0x69E0             LDR      R0,[R4, #+28]
   \   0000004E   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000052   0x61E0             STR      R0,[R4, #+28]
    179            }
    180            
    181            //The WAKE_IRQD source can come from any pin based on IRQD's sel register.
    182            if(gpioWakeSel & BIT(GPIO_IRQDSEL)) {
   \                     ??halInternalSleep_3:
   \   00000054   0xF04F 0x0A01      MOV      R10,#+1
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x6929             LDR      R1,[R5, #+16]
   \   0000005C   0xFA0A 0xF101      LSL      R1,R10,R1
   \   00000060   0x4208             TST      R0,R1
   \   00000062   0xD003             BEQ.N    ??halInternalSleep_4
    183              WAKE_SEL |= WAKE_IRQD;
   \   00000064   0x69E0             LDR      R0,[R4, #+28]
   \   00000066   0xF040 0x0008      ORR      R0,R0,#0x8
   \   0000006A   0x61E0             STR      R0,[R4, #+28]
    184            }
    185            
    186            halInternalWakeEvent = 0; //clear old wake events
   \                     ??halInternalSleep_4:
   \   0000006C   0x.... 0x....      LDR.W    R7,??DataTable5
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x6078             STR      R0,[R7, #+4]
    187            
    188            switch(sleepMode)
   \   00000074   0x.... 0x....      LDR.W    R8,??DataTable5_3  ;; 0x4000a014
   \   00000078   0xF89D 0x0068      LDRB     R0,[SP, #+104]
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xF000 0x8252      BEQ.W    ??halInternalSleep_5
   \   00000082   0xF0C0 0x8278      BCC.W    ??halInternalSleep_6
   \   00000086   0x2803             CMP      R0,#+3
   \   00000088   0xD01E             BEQ.N    ??halInternalSleep_7
   \   0000008A   0xD305             BCC.N    ??halInternalSleep_8
   \   0000008C   0x2804             CMP      R0,#+4
   \   0000008E   0xF040 0x8272      BNE.W    ??halInternalSleep_6
    189            {
    190              case SLEEPMODE_NOTIMER:
    191                //The sleep timer clock sources (both RC and XTAL) are turned off.
    192                //Wakeup is possible from only GPIO.  System time is lost.
    193                //NOTE: Timer restoring always takes place during the wakeup sequence.
    194                SLEEPTMR_CLKEN = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x6060             STR      R0,[R4, #+4]
    195                goto deepSleepCore;
   \   00000096   0xE017             B.N      ??halInternalSleep_7
    196              
    197              case SLEEPMODE_WAKETIMER:
    198                //The sleep timer clock sources remain running.  The RC is always
    199                //running and the 32kHz XTAL depends on the board header.  Wakeup
    200                //is possible from both GPIO and the sleep timer.  System time
    201                //is maintained.  The sleep timer is assumed to be configured
    202                //properly for wake events.
    203                //NOTE: This mode assumes the caller has configured the *entire*
    204                //      sleep timer properly.
    205                
    206                if(INT_SLEEPTMRCFG&INT_SLEEPTMRWRAP) {
   \                     ??halInternalSleep_8:
   \   00000098   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \   0000009C   0x07C0             LSLS     R0,R0,#+31
   \   0000009E   0xD503             BPL.N    ??halInternalSleep_9
    207                  WAKE_SEL |= WAKE_SLEEPTMRWRAP;
   \   000000A0   0x69E0             LDR      R0,[R4, #+28]
   \   000000A2   0xF040 0x0040      ORR      R0,R0,#0x40
   \   000000A6   0x61E0             STR      R0,[R4, #+28]
    208                }
    209                if(INT_SLEEPTMRCFG&INT_SLEEPTMRCMPB) {
   \                     ??halInternalSleep_9:
   \   000000A8   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \   000000AC   0x0740             LSLS     R0,R0,#+29
   \   000000AE   0xD503             BPL.N    ??halInternalSleep_10
    210                  WAKE_SEL |= WAKE_SLEEPTMRCMPB;
   \   000000B0   0x69E0             LDR      R0,[R4, #+28]
   \   000000B2   0xF040 0x0020      ORR      R0,R0,#0x20
   \   000000B6   0x61E0             STR      R0,[R4, #+28]
    211                }
    212                if(INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) {
   \                     ??halInternalSleep_10:
   \   000000B8   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \   000000BC   0x0780             LSLS     R0,R0,#+30
   \   000000BE   0xD503             BPL.N    ??halInternalSleep_7
    213                  WAKE_SEL |= WAKE_SLEEPTMRCMPA;
   \   000000C0   0x69E0             LDR      R0,[R4, #+28]
   \   000000C2   0xF040 0x0010      ORR      R0,R0,#0x10
   \   000000C6   0x61E0             STR      R0,[R4, #+28]
    214                }
    215                //fall into SLEEPMODE_MAINTAINTIMER's sleep code:
    216                
    217              case SLEEPMODE_MAINTAINTIMER:
    218                //The sleep timer clock sources remain running.  The RC is always
    219                //running and the 32kHz XTAL depends on the board header.  Wakeup
    220                //is possible from only GPIO.  System time is maintained.
    221                //NOTE: System time is maintained without any sleep timer interrupts
    222                //      because the hardware sleep timer counter is large enough
    223                //      to hold the entire count value and not need a RAM counter.
    224                
    225              ////////////////////////////////////////////////////////////////////////////
    226              // Core deep sleep code
    227              ////////////////////////////////////////////////////////////////////////////
    228          deepSleepCore:
    229                // Interrupts *must* be/stay disabled for DEEP SLEEP operation
    230                // INTERRUPTS_OFF will use BASEPRI to disable all interrupts except
    231                // fault handlers and PendSV.
    232                INTERRUPTS_OFF();
   \                     ??halInternalSleep_7:
   \   000000C8   0x.... 0x....      BL       _disableBasePri
    233                // This is the point of no return.  From here on out, only the interrupt
    234                // sources available in WAKE_SEL will be captured and propagated across
    235                // deep sleep.
    236                //stick all our saved info onto stack since it's only temporary
    237                {
    238                  boolean restoreWatchdog = halInternalWatchDogEnabled();
   \   000000CC   0x.... 0x....      BL       halInternalWatchDogEnabled
   \   000000D0   0xF88D 0x005C      STRB     R0,[SP, #+92]
    239                  boolean skipSleep = FALSE;
   \   000000D4   0xF04F 0x0B00      MOV      R11,#+0
    240          
    241                  #if defined(CORTEXM3_EM358X) || defined(CORTEXM3_EM359)        
    242                    // On the 358x we must configure the RAM_RETAIN register to set which
    243                    // blocks of RAM are maintained across deepsleep. This register is
    244                    // reset during deepsleep so we must do this every time.
    245                    RAM_RETAIN = (1<<(RETAIN_BITS - (UNRETAINED_RAM_SIZE*RETAIN_BITS)/RAM_SIZE_B))-1;
    246                  #endif
    247          
    248                  // Only three register blocks keep power across deep sleep:
    249                  //  CM_HV, GPIO, SLOW_TIMERS
    250                  //
    251                  // All other register blocks lose their state across deep sleep:
    252                  //  BASEBAND, MAC, SECURITY, SERIAL, TMR1, TMR2, EVENT, CM_LV, RAM_CTRL,
    253                  //  AUX_ADC, CAL_ADC, FLASH_CONTROL, ITM, DWT, FPB, NVIC, TPIU
    254                  //
    255                  // The sleep code will only save and restore registers where it is
    256                  // meaningful and necessary to do so.  In most cases, there must still
    257                  // be a powerup function to restore proper state.
    258                  //
    259                  // NOTE: halPowerUp() and halPowerDown() will always be called before
    260                  // and after this function.  halPowerDown and halPowerUp should leave
    261                  // the modules in a safe state and then restart the modules.
    262                  // (For example, shutting down and restarting Timer1)
    263                  //
    264                  //----BASEBAND
    265                  //        reinitialized by emberStackPowerUp()
    266                  //----MAC
    267                  //        reinitialized by emberStackPowerUp()
    268                  //----SECURITY
    269                  //        reinitialized by emberStackPowerUp()
    270                  //----SERIAL
    271                  //        reinitialized by halPowerUp() or similar
    272                  //----TMR1
    273                  //        reinitialized by halPowerUp() or similar
    274                  //----TMR2
    275                  //        reinitialized by halPowerUp() or similar
    276                  //----EVENT
    277                  //SRC or FLAG interrupts are not saved or restored
    278                  //MISS interrupts are not saved or restored
    279                  //MAC_RX_INT_MASK - reinitialized by emberStackPowerUp()
    280                  //MAC_TX_INT_MASK - reinitialized by emberStackPowerUp()
    281                  //MAC_TIMER_INT_MASK - reinitialized by emberStackPowerUp()
    282                  //BB_INT_MASK - reinitialized by emberStackPowerUp()
    283                  //SEC_INT_MASK - reinitialized by emberStackPowerUp()
    284                  int32u INT_SLEEPTMRCFG_SAVED = INT_SLEEPTMRCFG_REG;
   \   000000D8   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \   000000DC   0x9016             STR      R0,[SP, #+88]
    285                  int32u INT_MGMTCFG_SAVED = INT_MGMTCFG_REG;
   \   000000DE   0xF8D8 0x0044      LDR      R0,[R8, #+68]
   \   000000E2   0x9015             STR      R0,[SP, #+84]
    286                  //INT_TIM1CFG - reinitialized by halPowerUp() or similar
    287                  //INT_TIM2CFG - reinitialized by halPowerUp() or similar
    288                  //INT_SC1CFG - reinitialized by halPowerUp() or similar
    289                  //INT_SC2CFG - reinitialized by halPowerUp() or similar
    290                  //INT_ADCCFG - reinitialized by halPowerUp() or similar
    291                  int32u GPIO_INTCFGA_SAVED = GPIO_INTCFGA_REG;
   \   000000E4   0x.... 0x....      LDR.W    R9,??DataTable5_4  ;; 0x4000a814
   \   000000E8   0xF8D9 0x004C      LDR      R0,[R9, #+76]
   \   000000EC   0x9014             STR      R0,[SP, #+80]
    292                  int32u GPIO_INTCFGB_SAVED = GPIO_INTCFGB_REG;
   \   000000EE   0xF8D9 0x0050      LDR      R0,[R9, #+80]
   \   000000F2   0x9013             STR      R0,[SP, #+76]
    293                  int32u GPIO_INTCFGC_SAVED = GPIO_INTCFGC_REG;
   \   000000F4   0xF8D9 0x0054      LDR      R0,[R9, #+84]
   \   000000F8   0x9012             STR      R0,[SP, #+72]
    294                  int32u GPIO_INTCFGD_SAVED = GPIO_INTCFGD_REG;
   \   000000FA   0xF8D9 0x0058      LDR      R0,[R9, #+88]
   \   000000FE   0x9011             STR      R0,[SP, #+68]
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable5_5  ;; 0x40004004
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0x9010             STR      R0,[SP, #+64]
    295                  //SC1_INTMODE - reinitialized by halPowerUp() or similar
    296                  //SC2_INTMODE - reinitialized by halPowerUp() or similar
    297                  //----CM_LV
    298                  int32u OSC24M_BIASTRIM_SAVED = OSC24M_BIASTRIM_REG;
    299                  int32u OSCHF_TUNE_SAVED = OSCHF_TUNE_REG;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable5_5  ;; 0x40004004
   \   0000010C   0x6840             LDR      R0,[R0, #+4]
   \   0000010E   0x900F             STR      R0,[SP, #+60]
    300                  int32u DITHER_DIS_SAVED = DITHER_DIS_REG;
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable5_5  ;; 0x40004004
   \   00000114   0x6940             LDR      R0,[R0, #+20]
   \   00000116   0x900E             STR      R0,[SP, #+56]
    301                  //OSC24M_CTRL - reinitialized by halPowerUp() or similar
    302                  //CPU_CLKSEL  - reinitialized by halPowerUp() or similar
    303                  //TMR1_CLK_SEL - reinitialized by halPowerUp() or similar
    304                  //TMR2_CLK_SEL - reinitialized by halPowerUp() or similar
    305                  int32u PCTRACE_SEL_SAVED = PCTRACE_SEL_REG;
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable5_5  ;; 0x40004004
   \   0000011C   0x6A40             LDR      R0,[R0, #+36]
   \   0000011E   0x900D             STR      R0,[SP, #+52]
    306                  //----RAM_CTRL
    307                  #if !defined(CORTEXM3_EM358X) && !defined(CORTEXM3_EM359)
    308                    int32u MEM_PROT_0_SAVED = MEM_PROT_0_REG;
   \   00000120   0x.... 0x....      LDR.W    R6,??DataTable5_6  ;; 0x40005000
   \   00000124   0x6830             LDR      R0,[R6, #+0]
   \   00000126   0x900C             STR      R0,[SP, #+48]
    309                    int32u MEM_PROT_1_SAVED = MEM_PROT_1_REG;
   \   00000128   0x6870             LDR      R0,[R6, #+4]
   \   0000012A   0x900B             STR      R0,[SP, #+44]
    310                    int32u MEM_PROT_2_SAVED = MEM_PROT_2_REG;
   \   0000012C   0x68B0             LDR      R0,[R6, #+8]
   \   0000012E   0x900A             STR      R0,[SP, #+40]
    311                    int32u MEM_PROT_3_SAVED = MEM_PROT_3_REG;
   \   00000130   0x68F0             LDR      R0,[R6, #+12]
   \   00000132   0x9009             STR      R0,[SP, #+36]
    312                    int32u MEM_PROT_4_SAVED = MEM_PROT_4_REG;
   \   00000134   0x6930             LDR      R0,[R6, #+16]
   \   00000136   0x9008             STR      R0,[SP, #+32]
    313                    int32u MEM_PROT_5_SAVED = MEM_PROT_5_REG;
   \   00000138   0x6970             LDR      R0,[R6, #+20]
   \   0000013A   0x9007             STR      R0,[SP, #+28]
    314                    int32u MEM_PROT_6_SAVED = MEM_PROT_6_REG;
   \   0000013C   0x69B0             LDR      R0,[R6, #+24]
   \   0000013E   0x9006             STR      R0,[SP, #+24]
    315                    int32u MEM_PROT_7_SAVED = MEM_PROT_7_REG;
   \   00000140   0x69F0             LDR      R0,[R6, #+28]
   \   00000142   0x9005             STR      R0,[SP, #+20]
    316                    int32u MEM_PROT_EN_SAVED = MEM_PROT_EN_REG;
   \   00000144   0x6BB0             LDR      R0,[R6, #+56]
   \   00000146   0x9004             STR      R0,[SP, #+16]
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable5_7  ;; 0xe000e100
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0x.... 0x....      LDR.W    R1,??DataTable5_8  ;; 0xe000ed04
   \   00000152   0x6849             LDR      R1,[R1, #+4]
   \   00000154   0x9103             STR      R1,[SP, #+12]
    317                  #endif //!CORTEXM3_EM358X && !CORTEXM3_EM359
    318                  //----AUX_ADC
    319                  //        reinitialized by halPowerUp() or similar
    320                  //----CAL_ADC
    321                  //        reinitialized by emberStackPowerUp()
    322                  //----FLASH_CONTROL
    323                  //        configured on the fly by the flash library
    324                  //----ITM
    325                  //        reinitialized by halPowerUp() or similar
    326                  //----DWT
    327                  //        not used by software on chip
    328                  //----FPB
    329                  //        not used by software on chip
    330                  //----NVIC
    331                  //ST_CSR - fixed, restored by cstartup when exiting deep sleep
    332                  //ST_RVR - fixed, restored by cstartup when exiting deep sleep
    333                  int32u INT_CFGSET_SAVED = INT_CFGSET_REG; //mask against wake sources
    334                  //INT_PENDSET - used below when overlapping interrupts and wake sources
    335                  //NVIC_IPR_3to0 - fixed, restored by cstartup when exiting deep sleep
    336                  //NVIC_IPR_7to4 - fixed, restored by cstartup when exiting deep sleep
    337                  //NVIC_IPR_11to8 - fixed, restored by cstartup when exiting deep sleep
    338                  //NVIC_IPR_15to12 - fixed, restored by cstartup when exiting deep sleep
    339                  //NVIC_IPR_19to16 - fixed, restored by cstartup when exiting deep sleep
    340                  int32u SCS_VTOR_SAVED = SCS_VTOR_REG;
    341                  //SCS_CCR - fixed, restored by cstartup when exiting deep sleep
    342                  //SCS_SHPR_7to4 - fixed, restored by cstartup when exiting deep sleep
    343                  //SCS_SHPR_11to8 - fixed, restored by cstartup when exiting deep sleep
    344                  //SCS_SHPR_15to12 - fixed, restored by cstartup when exiting deep sleep
    345                  //SCS_SHCSR - fixed, restored by cstartup when exiting deep sleep
    346                  //----TPIU
    347                  //        reinitialized by halPowerUp() or similar
    348                  
    349                  //emDebugPowerDown() should have shutdown the DWT/ITM/TPIU already.
    350                  
    351                  //freeze input to the GPIO from LV (alternate output functions freeze)
    352                  EVENT_CTRL = LV_FREEZE;
   \   00000156   0x2102             MOVS     R1,#+2
   \   00000158   0x6021             STR      R1,[R4, #+0]
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable5_9  ;; 0x4000b008
   \   0000015E   0x6809             LDR      R1,[R1, #+0]
   \   00000160   0x.... 0x....      LDR.W    R2,??DataTable5_10  ;; 0x4000b408
   \   00000164   0x6812             LDR      R2,[R2, #+0]
   \   00000166   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000016A   0x.... 0x....      LDR.W    R2,??DataTable5_11  ;; 0x4000b808
   \   0000016E   0x6812             LDR      R2,[R2, #+0]
   \   00000170   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   00000174   0x9102             STR      R1,[SP, #+8]
   \   00000176   0xF04F 0x31FF      MOV      R1,#-1
   \   0000017A   0x6261             STR      R1,[R4, #+36]
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable5_12  ;; 0xe000e200
   \   00000180   0x680A             LDR      R2,[R1, #+0]
   \   00000182   0x6879             LDR      R1,[R7, #+4]
   \   00000184   0x04D2             LSLS     R2,R2,#+19
   \   00000186   0xD508             BPL.N    ??halInternalSleep_11
   \   00000188   0x686A             LDR      R2,[R5, #+4]
   \   0000018A   0x07D2             LSLS     R2,R2,#+31
   \   0000018C   0xD505             BPL.N    ??halInternalSleep_11
   \   0000018E   0x69E2             LDR      R2,[R4, #+28]
   \   00000190   0x07D2             LSLS     R2,R2,#+31
   \   00000192   0xBF44             ITT      MI 
   \   00000194   0x46D3             MOVMI    R11,R10
   \   00000196   0xF441 0x7180      ORRMI    R1,R1,#0x100
    353                  //record GPIO state for wake monitoring purposes
    354                  //By having a snapshot of GPIO state, we can figure out after waking
    355                  //up exactly which GPIO could have woken us up.
    356                  //Reading the three IN registers is done separately to avoid warnings
    357                  //about undefined order of volatile access.
    358                  int32u GPIO_IN_SAVED =   GPIO_PAIN;
    359                         GPIO_IN_SAVED |= (GPIO_PBIN<<8);
    360                         GPIO_IN_SAVED |= (GPIO_PCIN<<16);
    361                  //reset the power up events by writing 1 to all bits.
    362                  PWRUP_EVENT = 0xFFFFFFFF;
    363                  //[[
    364                  SLEEP_TRACE_ADD_MARKER('A');
    365                  //]]
    366                  //By clearing the events, the wake up event capturing is activated.
    367                  //At this point we can safely check our interrupt flags since event
    368                  //capturing is now overlapped.  Up to now, interrupts indicate
    369                  //activity, after this point, powerup events indicate activity.
    370                  //If any of the interrupt flags are set, that means we saw a wake event
    371                  //sometime while entering sleep, so we need to skip over sleeping
    372                  //
    373                  //--possible interrupt sources for waking:
    374                  //  IRQA, IRQB, IRQC, IRQD
    375                  //  SleepTMR CMPA, CMPB, Wrap
    376                  //  WAKE_CORE (DebugIsr)
    377                  //
    378                  //check for IRQA interrupt and if IRQA (PB0) is wake source
    379                  if((INT_PENDSET&INT_IRQA) &&
    380                     (GPIO_PBWAKE&PB0) &&
    381                     (WAKE_SEL&GPIO_WAKE)) {
    382                    skipSleep = TRUE;
    383                    //log IRQA as a wake event
    384                    halInternalWakeEvent |= BIT(PORTB_PIN(0));
    385                    //[[
    386                    SLEEP_TRACE_ADD_MARKER('B');
    387                    //]]
    388                  }
    389                  //check for IRQB interrupt and if IRQB (PB6) is wake source
    390                  if((INT_PENDSET&INT_IRQB) &&
    391                     (GPIO_PBWAKE&PB6) &&
    392                     (WAKE_SEL&GPIO_WAKE)) {
   \                     ??halInternalSleep_11:
   \   0000019A   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   0000019E   0x0492             LSLS     R2,R2,#+18
   \   000001A0   0xD508             BPL.N    ??halInternalSleep_12
   \   000001A2   0x686A             LDR      R2,[R5, #+4]
   \   000001A4   0x0652             LSLS     R2,R2,#+25
   \   000001A6   0xD505             BPL.N    ??halInternalSleep_12
   \   000001A8   0x69E2             LDR      R2,[R4, #+28]
   \   000001AA   0x07D2             LSLS     R2,R2,#+31
   \   000001AC   0xBF44             ITT      MI 
   \   000001AE   0x46D3             MOVMI    R11,R10
   \   000001B0   0xF441 0x4180      ORRMI    R1,R1,#0x4000
    393                    skipSleep = TRUE;
    394                    //log IRQB as a wake event
    395                    halInternalWakeEvent |= BIT(PORTB_PIN(6));
    396                    //[[
    397                    SLEEP_TRACE_ADD_MARKER('C');
    398                    //]]
    399                  }
    400                  //check for IRQC interrupt and if IRQC (GPIO_IRQCSEL) is wake source
    401                  if((INT_PENDSET&INT_IRQC) &&
    402                     (gpioWakeSel&BIT(GPIO_IRQCSEL)) &&
    403                     (WAKE_SEL&GPIO_WAKE)) {
   \                     ??halInternalSleep_12:
   \   000001B4   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   000001B8   0x0452             LSLS     R2,R2,#+17
   \   000001BA   0xD50A             BPL.N    ??halInternalSleep_13
   \   000001BC   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4:
   \   000001C0   0xD007             BEQ.N    ??halInternalSleep_13
   \   000001C2   0x69E2             LDR      R2,[R4, #+28]
   \   000001C4   0x07D2             LSLS     R2,R2,#+31
   \   000001C6   0xD504             BPL.N    ??halInternalSleep_13
    404                    skipSleep = TRUE;
   \   000001C8   0x46D3             MOV      R11,R10
    405                    //log IRQC as a wake event
    406                    halInternalWakeEvent |= BIT(GPIO_IRQCSEL);
   \   000001CA   0x68EA             LDR      R2,[R5, #+12]
   \   000001CC   0xFA0A 0xF202      LSL      R2,R10,R2
   \   000001D0   0x4311             ORRS     R1,R2,R1
    407                    //[[
    408                    SLEEP_TRACE_ADD_MARKER('D');
    409                    //]]
    410                  }
    411                  //check for IRQD interrupt and if IRQD (GPIO_IRQDSEL) is wake source
    412                  if((INT_PENDSET&INT_IRQD) &&
    413                     (gpioWakeSel&BIT(GPIO_IRQDSEL)) &&
    414                     ((WAKE_SEL&GPIO_WAKE) ||
    415                      (WAKE_SEL&WAKE_IRQD))) {
   \                     ??halInternalSleep_13:
   \   000001D2   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2:
   \   000001D6   0x0412             LSLS     R2,R2,#+16
   \   000001D8   0xD510             BPL.N    ??halInternalSleep_14
   \   000001DA   0x9A00             LDR      R2,[SP, #+0]
   \   000001DC   0x692B             LDR      R3,[R5, #+16]
   \   000001DE   0xFA0A 0xF303      LSL      R3,R10,R3
   \   000001E2   0x421A             TST      R2,R3
   \   000001E4   0xD00A             BEQ.N    ??halInternalSleep_14
   \   000001E6   0x69E2             LDR      R2,[R4, #+28]
   \   000001E8   0x07D2             LSLS     R2,R2,#+31
   \   000001EA   0xD402             BMI.N    ??halInternalSleep_15
   \   000001EC   0x69E2             LDR      R2,[R4, #+28]
   \   000001EE   0x0712             LSLS     R2,R2,#+28
   \   000001F0   0xD504             BPL.N    ??halInternalSleep_14
    416                    skipSleep = TRUE;
   \                     ??halInternalSleep_15:
   \   000001F2   0x46D3             MOV      R11,R10
    417                    //log IRQD as a wake event
    418                    halInternalWakeEvent |= BIT(GPIO_IRQDSEL);
   \   000001F4   0x692A             LDR      R2,[R5, #+16]
   \   000001F6   0xFA0A 0xF202      LSL      R2,R10,R2
   \   000001FA   0x4311             ORRS     R1,R2,R1
    419                    //[[
    420                    SLEEP_TRACE_ADD_MARKER('E');
    421                    //]]
    422                  }
    423                  //check for SleepTMR CMPA interrupt and if SleepTMR CMPA is wake source
    424                  if((INT_SLEEPTMR&INT_SLEEPTMRCMPA) && (WAKE_SEL&WAKE_SLEEPTMRCMPA)) {
    425                    skipSleep = TRUE;
    426                    //log SleepTMR CMPA as a wake event
    427                    halInternalWakeEvent |= BIT32(CMPA_INTERNAL_WAKE_EVENT_BIT);
    428                    //[[
    429                    SLEEP_TRACE_ADD_MARKER('F');
    430                    //]]
    431                  }
    432                  //check for SleepTMR CMPB interrupt and if SleepTMR CMPB is wake source
    433                  if((INT_SLEEPTMR&INT_SLEEPTMRCMPB) && (WAKE_SEL&WAKE_SLEEPTMRCMPB)) {
    434                    skipSleep = TRUE;
    435                    //log SleepTMR CMPB as a wake event
    436                    halInternalWakeEvent |= BIT32(CMPB_INTERNAL_WAKE_EVENT_BIT);
    437                    //[[
    438                    SLEEP_TRACE_ADD_MARKER('G');
    439                    //]]
    440                  }
    441                  //check for SleepTMR WRAP interrupt and if SleepTMR WRAP is wake source
    442                  if((INT_SLEEPTMR&INT_SLEEPTMRWRAP) && (WAKE_SEL&WAKE_SLEEPTMRWRAP)) {
    443                    skipSleep = TRUE;
    444                    //log SleepTMR WRAP as a wake event
    445                    halInternalWakeEvent |= BIT32(WRAP_INTERNAL_WAKE_EVENT_BIT);
    446                    //[[
    447                    SLEEP_TRACE_ADD_MARKER('H');
    448                    //]]
    449                  }
    450                  //check for Debug interrupt and if WAKE_CORE is wake source
    451                  if((INT_PENDSET&INT_DEBUG) && (WAKE_SEL&WAKE_WAKE_CORE)) {
   \                     ??halInternalSleep_14:
   \   000001FC   0x.... 0x....      BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_3:
   \   00000200   0x03D2             LSLS     R2,R2,#+15
   \   00000202   0xD505             BPL.N    ??halInternalSleep_16
   \   00000204   0x69E2             LDR      R2,[R4, #+28]
   \   00000206   0x0612             LSLS     R2,R2,#+24
   \   00000208   0xBF44             ITT      MI 
   \   0000020A   0x46D3             MOVMI    R11,R10
   \   0000020C   0xF041 0x6100      ORRMI    R1,R1,#0x8000000
    452                    skipSleep = TRUE;
    453                    //log WAKE_CORE as a wake event
    454                    halInternalWakeEvent |= BIT32(WAKE_CORE_INTERNAL_WAKE_EVENT_BIT);
    455                    //[[
    456                    SLEEP_TRACE_ADD_MARKER('I');
   \                     ??halInternalSleep_16:
   \   00000210   0x6079             STR      R1,[R7, #+4]
    457                    //]]
    458                  }
    459          
    460                  //only propagate across deep sleep the interrupts that are both
    461                  //enabled and possible wake sources
    462                  {
    463                    int32u wakeSourceInterruptMask = 0;
   \   00000212   0x2100             MOVS     R1,#+0
   \   00000214   0x686A             LDR      R2,[R5, #+4]
   \   00000216   0x07D2             LSLS     R2,R2,#+31
   \   00000218   0xBF48             IT       MI 
   \   0000021A   0xF44F 0x5180      MOVMI    R1,#+4096
    464                    
    465                    if(GPIO_PBWAKE&PB0) {
    466                      wakeSourceInterruptMask |= INT_IRQA;
    467                      //[[
    468                      SLEEP_TRACE_ADD_MARKER('J');
    469                      //]]
    470                    }
    471                    if(GPIO_PBWAKE&PB6) {
   \   0000021E   0x686A             LDR      R2,[R5, #+4]
   \   00000220   0x0652             LSLS     R2,R2,#+25
   \   00000222   0xBF48             IT       MI 
   \   00000224   0xF441 0x5100      ORRMI    R1,R1,#0x2000
    472                      wakeSourceInterruptMask |= INT_IRQB;
    473                      //[[
    474                      SLEEP_TRACE_ADD_MARKER('K');
    475                      //]]
    476                    }
    477                    if(gpioWakeSel&BIT(GPIO_IRQCSEL)) {
   \   00000228   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5:
   \   0000022C   0xBF18             IT       NE 
   \   0000022E   0xF441 0x4180      ORRNE    R1,R1,#0x4000
    478                      wakeSourceInterruptMask |= INT_IRQC;
    479                      //[[
    480                      SLEEP_TRACE_ADD_MARKER('L');
    481                      //]]
    482                    }
    483                    if(gpioWakeSel&BIT(GPIO_IRQDSEL)) {
   \   00000232   0x692B             LDR      R3,[R5, #+16]
   \   00000234   0xFA0A 0xF303      LSL      R3,R10,R3
   \   00000238   0x421A             TST      R2,R3
   \   0000023A   0xBF18             IT       NE 
   \   0000023C   0xF441 0x4100      ORRNE    R1,R1,#0x8000
    484                      wakeSourceInterruptMask |= INT_IRQD;
    485                      //[[
    486                      SLEEP_TRACE_ADD_MARKER('M');
    487                      //]]
    488                    }
    489                    if( (WAKE_SEL&WAKE_SLEEPTMRCMPA) ||
    490                        (WAKE_SEL&WAKE_SLEEPTMRCMPB) ||
    491                        (WAKE_SEL&WAKE_SLEEPTMRWRAP) ) {
   \   00000240   0x69E2             LDR      R2,[R4, #+28]
   \   00000242   0x06D2             LSLS     R2,R2,#+27
   \   00000244   0xD405             BMI.N    ??halInternalSleep_17
   \   00000246   0x69E2             LDR      R2,[R4, #+28]
   \   00000248   0x0692             LSLS     R2,R2,#+26
   \   0000024A   0xD402             BMI.N    ??halInternalSleep_17
   \   0000024C   0x69E2             LDR      R2,[R4, #+28]
   \   0000024E   0x0652             LSLS     R2,R2,#+25
   \   00000250   0xD501             BPL.N    ??halInternalSleep_18
    492                      wakeSourceInterruptMask |= INT_SLEEPTMR;
   \                     ??halInternalSleep_17:
   \   00000252   0xF041 0x0110      ORR      R1,R1,#0x10
    493                      //[[
    494                      SLEEP_TRACE_ADD_MARKER('N');
    495                      //]]
    496                    }
    497                    if(WAKE_SEL&WAKE_WAKE_CORE) {
   \                     ??halInternalSleep_18:
   \   00000256   0x69E2             LDR      R2,[R4, #+28]
   \   00000258   0x0612             LSLS     R2,R2,#+24
   \   0000025A   0xBF48             IT       MI 
   \   0000025C   0xF441 0x3180      ORRMI    R1,R1,#0x10000
    498                      wakeSourceInterruptMask |= INT_DEBUG;
    499                      //[[
    500                      SLEEP_TRACE_ADD_MARKER('O');
    501                      //]]
    502                    }
    503                    
    504                    INT_CFGSET_SAVED &= wakeSourceInterruptMask;
   \   00000260   0x4008             ANDS     R0,R1,R0
   \   00000262   0x9001             STR      R0,[SP, #+4]
    505                  }
    506                  
    507                  //[[
    508                  //Since it is possible to perform a deep sleep cycle without actually
    509                  //leaving the running state (a wake source was captured while
    510                  //entering deep sleep or CSYSPWRUPREQ remained set), it is possible for
    511                  //the application to perform a sleep cycle and not have the entire
    512                  //low voltage domain reset.  In theory, the application is responsible
    513                  //for cleanly shutting down the entire chip and then bringing
    514                  //it back up around a sleep cycle (stack and hal sleep/powerup).  In
    515                  //practice, though, the safest thing to do is shut down the entire
    516                  //low voltage domain while entering deep sleep.  By doing this,
    517                  //we ensure the application always has the same sleep cycle operation
    518                  //and does not experience accidental peripheral operation that should
    519                  //not have survived.
    520                  halInternalMimickLvReset();
    521                  //]]
    522                  
    523                  //disable watchdog while sleeping (since we can't reset it asleep)
    524                  halInternalDisableWatchDog(MICRO_DISABLE_WATCH_DOG_KEY);
   \   00000264   0x20A5             MOVS     R0,#+165
   \   00000266   0x.... 0x....      BL       halInternalDisableWatchDog
    525                  
    526                  //The chip is not allowed to enter a deep sleep mode (which could
    527                  //cause a core reset cycle) while CSYSPWRUPREQ is set.  CSYSPWRUPREQ
    528                  //indicates that the debugger is trying to access sections of the
    529                  //chip that would get reset during deep sleep.  Therefore, a reset
    530                  //cycle could very easily cause the debugger to error and we don't
    531                  //want that.  While the power management state machine will stall
    532                  //if CSYSPWRUPREQ is set (to avoid the situation just described),
    533                  //in this stalled state the chip will not be responsive to wake
    534                  //events.  To be sensitive to wake events, we must handle them in
    535                  //software instead.  To accomplish this, we request that the
    536                  //CSYSPWRUPACK be inhibited (which will indicate the debugger is not
    537                  //connected).  But, we cannot induce deep sleep until CSYSPWRUPREQ/ACK
    538                  //go low and these are under the debuggers control, so we must stall
    539                  //and wait here.  If there is a wake event during this time, break
    540                  //out and wake like normal.  If the ACK eventually clears,
    541                  //we can proceed into deep sleep.  The CSYSPWRUPACK_INHIBIT
    542                  //functionality will hold off the debugger (by holding off the ACK)
    543                  //until we are safely past and out of deep sleep.  The power management
    544                  //state machine then becomes responsible for clearing
    545                  //CSYSPWRUPACK_INHIBIT and responding to a CSYSPWRUPREQ with a
    546                  //CSYSPWRUPACK at the right/safe time.
    547                  CSYSPWRUPACK_INHIBIT = CSYSPWRUPACK_INHIBIT_CSYSPWRUPACK_INHIBIT;
   \   0000026A   0xF8C4 0xA03C      STR      R10,[R4, #+60]
    548                  {
    549                    //Use a local copy of WAKE_SEL to avoid warnings from the compiler
    550                    //about order of volatile accesses
    551                    int32u wakeSel = WAKE_SEL;
   \   0000026E   0x69E0             LDR      R0,[R4, #+28]
    552                    //stall until a wake event or CSYSPWRUPREQ/ACK clears
    553                    while( (CSYSPWRUPACK_STATUS) && (!(PWRUP_EVENT&wakeSel)) ) {}
   \                     ??halInternalSleep_19:
   \   00000270   0x6BA1             LDR      R1,[R4, #+56]
   \   00000272   0xB111             CBZ.N    R1,??halInternalSleep_20
   \   00000274   0x6A61             LDR      R1,[R4, #+36]
   \   00000276   0x4201             TST      R1,R0
   \   00000278   0xD0FA             BEQ.N    ??halInternalSleep_19
   \                     ??halInternalSleep_20:
   \   0000027A   0x6A61             LDR      R1,[R4, #+36]
   \   0000027C   0x4201             TST      R1,R0
   \   0000027E   0xF000 0x80EF      BEQ.W    ??halInternalSleep_21
    554                    //if there was a wake event, allow CSYSPWRUPACK and skip sleep
    555                    if(PWRUP_EVENT&wakeSel) {
    556                      CSYSPWRUPACK_INHIBIT = CSYSPWRUPACK_INHIBIT_RESET;
   \   00000282   0x2000             MOVS     R0,#+0
   \   00000284   0x63E0             STR      R0,[R4, #+60]
    557                      skipSleep = TRUE;
   \   00000286   0x46D3             MOV      R11,R10
    558                    }
    559                  }
    560                  
    561                  
    562                  //[[
    563                  SLEEP_TRACE_ADD_MARKER('P');
    564                  //]]
    565                  if(!skipSleep) {
    566                    //[[
    567                    SLEEP_TRACE_ADD_MARKER('Q');
    568                    //]]
    569                    //FogBugz 7283 states that we must switch to the OSCHF when entering
    570                    //deep sleep since using the 24MHz XTAL could result in RAM
    571                    //corruption.  This switch must occur at least 2*24MHz cycles before
    572                    //sleeping.
    573                    //
    574                    //FogBugz 8858 states that we cannot go into deep-sleep when the
    575                    //chip is clocked with the 24MHz XTAL with a duty cycle as low as
    576                    //70/30 since this causes power_down generation timing to fail.
    577                    //
    578                    //Hekla-S-003_Digital_specification.doc#21 states:  "Note that
    579                    //in Lipari there was a requirement to set the clock into OSCHF
    580                    //mode prior to entering deep sleep. This was a limitation brought
    581                    //about from an early version of the RAM IP used in Lipari and does
    582                    //not apply to Hekla so that requirement is removed."  But since
    583                    //continuing to switch the clock does not dramatically affect
    584                    //behavior and we prefer to keep our code as common as we can
    585                    //between 3xx chips, we still switch the clock for 358x/359.
    586                    OSC24M_CTRL &= ~OSC24M_CTRL_OSC24M_SEL;
    587                    //If DS12 needs to be forced regardless of state, clear
    588                    //REGEN_DSLEEP here.  This is hugely dangerous and
    589                    //should only be done in very controlled chip tests.
    590                    SCS_SCR |= SCS_SCR_SLEEPDEEP;      //enable deep sleep
    591          
    592          #ifdef BOOTLOADER_OPEN
    593                    void bootloaderInternalSaveContextAndDeepSleep(void);
    594          
    595                    // We don't have interrupts in the bootloader, so we can't just use
    596                    // SCS_ICSR to trigger a PendSV. So we manually call a function that
    597                    // pushes all registers on the stack and enters deep sleep via a WFI
    598                    // instruction.
    599                    //
    600          
    601                    // NOTE: Only set the reset reason in the bootloader. See bugzid 14827
    602                    // for more information.
    603                    // Also note that we leave the resetReason intact after waking up and restoring
    604                    // since resetReason is used in cstartup-iar.c during startup.
    605                    halResetInfo.crash.resetReason    = RESET_BOOTLOADER_DEEPSLEEP;
    606                    halResetInfo.crash.resetSignature = RESET_VALID_SIGNATURE;
    607          
    608                    bootloaderInternalSaveContextAndDeepSleep();
    609                    //I AM ASLEEP.  WHEN EXECUTION RESUMES, CSTARTUP WILL RESTORE TO HERE
    610          
    611                    extern boolean sleepTimerInterruptOccurred;
    612          
    613                    // In normal non-bootloader sleep situations here's what would happen
    614                    // after we wakeup from deep sleep:
    615                    //
    616                    // 1. The INT_SLEEPTMRCFG register is restored (search for
    617                    //    INT_SLEEPTMRCFG_REG below). We know that this will have the
    618                    //    INT_SLEEPTMRCMPA bit set, because that's what we use for sleep.
    619                    // 2. This "if(sleep int triggered)?" test is true:
    620                    //      if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) &&
    621                    //          (halInternalWakeEvent&BIT(CMPA_INTERNAL_WAKE_EVENT_BIT)) )
    622                    //    And because it's true, the code below forces the sleep interrupt
    623                    //    like this:
    624                    //      INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPA;
    625                    // 3. The halSleepTimerIsr would clear INT_SLEEPTMRCFG and then set
    626                    //    sleepTimerInterruptOccurred to TRUE.
    627                    //
    628                    // But we're in the bootloader deep sleep case, so we don't have that
    629                    // ISR (or any interrupts, actually!).
    630                    //
    631                    // So we'll handle it ourselves here by:
    632                    // 1. Setting sleepTimerInterruptOccurred to TRUE.
    633                    // 2. Clearing the INT_SLEEPTMRCFG_SAVED variable so when it's
    634                    //    restored to INT_SLEEPTMRCFG_REG the "if(sleep int triggered)?"
    635                    //    will be false, and the deep sleep interrupt won't be forced.
    636                    sleepTimerInterruptOccurred = TRUE;
    637          
    638                    INT_SLEEPTMRCFG_SAVED = 0;
    639          
    640                    // Invalidate the reset reason.
    641                    // Bugzid-14827: Only do this when in a bootloader because otherwise
    642                    // we will overwrite heap data like packetbuffers.
    643                    halResetInfo.crash.resetSignature = RESET_INVALID_SIGNATURE;
    644          #else
    645                    extern volatile boolean halPendSvSaveContext;
    646                    halPendSvSaveContext = 1;          //1 means save context
    647          
    648                    // NOTE: Only bootloader sets the reset reason to allow deep sleep
    649                    // wakeup to know upon wake to stay in bootloader.  App does not
    650                    // set this, because this RAM is used for heap data (bugzid 14827),
    651                    // however app makes sure wakeup won't be fooled by happenstance
    652                    // if the heap actually contains the bootloader's pattern.
    653                    if ( halResetInfo.crash.resetReason == RESET_BOOTLOADER_DEEPSLEEP
    654                       &&halResetInfo.crash.resetSignature == RESET_VALID_SIGNATURE ) {
    655                      // temporarily corrupt resetSignature so wakeup returns here
    656                      // to app rather than thinking it's the bootloader that slept
    657                      halResetInfo.crash.resetSignature = RESET_INVALID_SIGNATURE;
    658                      // Hack repurpose skipSleep local as signal to post-wakeup code
    659                      skipSleep = TRUE; // Signal to wakeup code below to restore
    660                    }
    661          
    662                    //The INTERRUPTS_OFF used at the beginning of this function set
    663                    //BASEPRI such that the only interrupts that will fire are faults
    664                    //and PendSV.  Trigger PendSV now to induce a context save.
    665                    SCS_ICSR |= SCS_ICSR_PENDSVSET;    //pend the context save and Dsleep
    666                    //Since the interrupt will not fire immediately it is possible to
    667                    //execute a few lines of code.  To stay halted in this spot until the
    668                    //WFI instruction, spin on the context flag (which will get cleared
    669                    //during the startup sequence when restoring context).
    670                    while(halPendSvSaveContext) {}
    671                    //I AM ASLEEP.  WHEN EXECUTION RESUMES, CSTARTUP WILL RESTORE TO HERE
    672          
    673                    // If signalled above that we had to corrupt heap temporarily
    674                    // during sleep, restore it now upon wakeup!
    675                    if (skipSleep) {
    676                      halResetInfo.crash.resetSignature = RESET_VALID_SIGNATURE;
    677                      skipSleep = FALSE; // Done with repurposed local, restore it too
    678                    }
    679          #endif // BOOTLOADER_OPEN
    680          
    681                    //Save the value of the SLEEPTMR_CNT register immediately after
    682                    //waking up from a real sleep.  For FogBugz 11909/11920 workaround.
    683                    wakeupSleepTmrCnt = SLEEPTMR_CNTH<<16;
    684                    wakeupSleepTmrCnt |= SLEEPTMR_CNTL;
    685                  } else {
    686                    //Record the fact that we skipped sleep
    687                    halInternalWakeEvent |= BIT32(SLEEPSKIPPED_INTERNAL_WAKE_EVENT_BIT);
   \                     ??halInternalSleep_22:
   \   00000288   0x6878             LDR      R0,[R7, #+4]
   \   0000028A   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   0000028E   0x6078             STR      R0,[R7, #+4]
    688                    //If this was a true deep sleep, we would have executed cstartup and
    689                    //PRIMASK would be set right now.  If we skipped sleep, PRIMASK is not
    690                    //set so we explicitely set it to guarantee the powerup sequence
    691                    //works cleanly and consistently with respect to interrupt
    692                    //dispatching and enabling.
    693                    _setPriMask();
   \   00000290   0x.... 0x....      BL       _setPriMask
    694                  }
    695                  //[[
    696                  SLEEP_TRACE_1SEC_DELAY(1);
    697                  //]]
    698                  
    699                  //[[
    700                  SLEEP_TRACE_ADD_MARKER('a');
    701                  //]]
    702                  
    703                  //Clear the interrupt flags for all wake sources.  This
    704                  //is necessary because if we don't execute an actual deep sleep cycle
    705                  //the interrupt flags will never be cleared.  By clearing the flags,
    706                  //we always mimick a real deep sleep as closely as possible and
    707                  //guard against any accidental interrupt triggering coming out
    708                  //of deep sleep.  (The interrupt dispatch code coming out of sleep
    709                  //is responsible for translating wake events into interrupt events,
    710                  //and if we don't clear interrupt flags here it's possible for an
    711                  //interrupt to trigger even if it wasn't the true wake event.)
    712                  INT_SLEEPTMRFLAG = (INT_SLEEPTMRCMPA |
    713                                      INT_SLEEPTMRCMPB |
    714                                      INT_SLEEPTMRWRAP);
   \                     ??halInternalSleep_23:
   \   00000294   0x2007             MOVS     R0,#+7
   \   00000296   0xF8C8 0x0000      STR      R0,[R8, #+0]
    715                  INT_GPIOFLAG = (INT_IRQAFLAG |
    716                                  INT_IRQBFLAG |
    717                                  INT_IRQCFLAG |
    718                                  INT_IRQDFLAG);
   \   0000029A   0x200F             MOVS     R0,#+15
   \   0000029C   0xF8C9 0x0000      STR      R0,[R9, #+0]
    719                  
    720                  //immediately restore the registers we saved before sleeping
    721                  //so IRQ and SleepTMR capture can be reenabled as quickly as possible
    722                  //this is safe because our global interrupts are still disabled
    723                  //other registers will be restored later
    724                  //[[-(superphy)
    725                  #if ( ! (defined(MINIMAL_HAL) || defined(BOOTLOADER_OPEN)) )
    726                  //The minimal HAL (and therefore the SuperPHY release) doesn't
    727                  //use the MPU, and neither does app-bootloader-open.
    728                  halInternalEnableMPU();
   \   000002A0   0x.... 0x....      BL       halInternalEnableMPU
    729                  #endif //MINIMAL_HAL
    730                  //]] (superphy)
    731                  SLEEPTMR_CLKEN_REG = SLEEPTMR_CLKEN_SAVED;
   \   000002A4   0x9818             LDR      R0,[SP, #+96]
   \   000002A6   0x6060             STR      R0,[R4, #+4]
    732                  INT_SLEEPTMRCFG_REG = INT_SLEEPTMRCFG_SAVED;
   \   000002A8   0x9816             LDR      R0,[SP, #+88]
   \   000002AA   0xF8C8 0x0040      STR      R0,[R8, #+64]
    733                  INT_MGMTCFG_REG = INT_MGMTCFG_SAVED;
   \   000002AE   0x9815             LDR      R0,[SP, #+84]
   \   000002B0   0xF8C8 0x0044      STR      R0,[R8, #+68]
    734                  GPIO_INTCFGA_REG = GPIO_INTCFGA_SAVED;
   \   000002B4   0x9814             LDR      R0,[SP, #+80]
   \   000002B6   0xF8C9 0x004C      STR      R0,[R9, #+76]
    735                  GPIO_INTCFGB_REG = GPIO_INTCFGB_SAVED;
   \   000002BA   0x9813             LDR      R0,[SP, #+76]
   \   000002BC   0xF8C9 0x0050      STR      R0,[R9, #+80]
    736                  GPIO_INTCFGC_REG = GPIO_INTCFGC_SAVED;
   \   000002C0   0x9812             LDR      R0,[SP, #+72]
   \   000002C2   0xF8C9 0x0054      STR      R0,[R9, #+84]
    737                  GPIO_INTCFGD_REG = GPIO_INTCFGD_SAVED;
   \   000002C6   0x9811             LDR      R0,[SP, #+68]
   \   000002C8   0xF8C9 0x0058      STR      R0,[R9, #+88]
    738                  OSC24M_BIASTRIM_REG = OSC24M_BIASTRIM_SAVED;
   \   000002CC   0x....             LDR.N    R0,??DataTable5_5  ;; 0x40004004
   \   000002CE   0x9910             LDR      R1,[SP, #+64]
   \   000002D0   0x6001             STR      R1,[R0, #+0]
    739                  OSCHF_TUNE_REG = OSCHF_TUNE_SAVED;
   \   000002D2   0x990F             LDR      R1,[SP, #+60]
   \   000002D4   0x6041             STR      R1,[R0, #+4]
    740                  DITHER_DIS_REG = DITHER_DIS_SAVED;
   \   000002D6   0x990E             LDR      R1,[SP, #+56]
   \   000002D8   0x6141             STR      R1,[R0, #+20]
    741                  PCTRACE_SEL_REG = PCTRACE_SEL_SAVED;
   \   000002DA   0x990D             LDR      R1,[SP, #+52]
   \   000002DC   0x6241             STR      R1,[R0, #+36]
    742                  #if !defined(CORTEXM3_EM358X) && !defined(CORTEXM3_EM359)
    743                    MEM_PROT_0_REG = MEM_PROT_0_SAVED;
   \   000002DE   0x980C             LDR      R0,[SP, #+48]
   \   000002E0   0x6030             STR      R0,[R6, #+0]
    744                    MEM_PROT_1_REG = MEM_PROT_1_SAVED;
   \   000002E2   0x980B             LDR      R0,[SP, #+44]
   \   000002E4   0x6070             STR      R0,[R6, #+4]
    745                    MEM_PROT_2_REG = MEM_PROT_2_SAVED;
   \   000002E6   0x980A             LDR      R0,[SP, #+40]
   \   000002E8   0x60B0             STR      R0,[R6, #+8]
    746                    MEM_PROT_3_REG = MEM_PROT_3_SAVED;
   \   000002EA   0x9809             LDR      R0,[SP, #+36]
   \   000002EC   0x60F0             STR      R0,[R6, #+12]
    747                    MEM_PROT_4_REG = MEM_PROT_4_SAVED;
   \   000002EE   0x9808             LDR      R0,[SP, #+32]
   \   000002F0   0x6130             STR      R0,[R6, #+16]
    748                    MEM_PROT_5_REG = MEM_PROT_5_SAVED;
   \   000002F2   0x9807             LDR      R0,[SP, #+28]
   \   000002F4   0x6170             STR      R0,[R6, #+20]
    749                    MEM_PROT_6_REG = MEM_PROT_6_SAVED;
   \   000002F6   0x9806             LDR      R0,[SP, #+24]
   \   000002F8   0x61B0             STR      R0,[R6, #+24]
    750                    MEM_PROT_7_REG = MEM_PROT_7_SAVED;
   \   000002FA   0x9805             LDR      R0,[SP, #+20]
   \   000002FC   0x61F0             STR      R0,[R6, #+28]
    751                    MEM_PROT_EN_REG = MEM_PROT_EN_SAVED;
   \   000002FE   0x9804             LDR      R0,[SP, #+16]
   \   00000300   0x63B0             STR      R0,[R6, #+56]
    752                  #endif //!CORTEXM3_EM358X && !CORTEXM3_EM359
    753                  INT_CFGSET_REG = INT_CFGSET_SAVED;
   \   00000302   0x....             LDR.N    R0,??DataTable5_7  ;; 0xe000e100
   \   00000304   0x9901             LDR      R1,[SP, #+4]
   \   00000306   0x6001             STR      R1,[R0, #+0]
    754                  SCS_VTOR_REG = SCS_VTOR_SAVED;
   \   00000308   0x....             LDR.N    R0,??DataTable5_8  ;; 0xe000ed04
   \   0000030A   0x9903             LDR      R1,[SP, #+12]
   \   0000030C   0x6041             STR      R1,[R0, #+4]
    755                  
    756                  //WAKE_CORE/INT_DEBUG and INT_IRQx is cleared by INT_PENDCLR below
    757                  INT_PENDCLR = 0xFFFFFFFF;
   \   0000030E   0x....             LDR.N    R0,??DataTable5_13  ;; 0xe000e280
   \   00000310   0xF04F 0x31FF      MOV      R1,#-1
   \   00000314   0x6001             STR      R1,[R0, #+0]
    758                  
    759                  //Now that we're awake, normal interrupts are operational again
    760                  //Take a snapshot of the new GPIO state and the EVENT register to
    761                  //record our wake event
    762                  int32u GPIO_IN_NEW =   GPIO_PAIN;
   \   00000316   0x....             LDR.N    R0,??DataTable5_9  ;; 0x4000b008
   \   00000318   0x6802             LDR      R2,[R0, #+0]
    763                         GPIO_IN_NEW |= (GPIO_PBIN<<8);
   \   0000031A   0x....             LDR.N    R0,??DataTable5_10  ;; 0x4000b408
   \   0000031C   0x6800             LDR      R0,[R0, #+0]
    764                         GPIO_IN_NEW |= (GPIO_PCIN<<16);
   \   0000031E   0x....             LDR.N    R1,??DataTable5_11  ;; 0x4000b808
   \   00000320   0x6809             LDR      R1,[R1, #+0]
    765                  //Only operate on power up events that are also wake events.  Power
    766                  //up events will always trigger like an interrupt flag, so we have
    767                  //to check them against events that are enabled for waking. (This is
    768                  //a two step process because we're accessing two volatile values.)
    769                  int32u powerUpEvents = PWRUP_EVENT;
   \   00000322   0x6A63             LDR      R3,[R4, #+36]
    770                         powerUpEvents &= WAKE_SEL;
   \   00000324   0x69E6             LDR      R6,[R4, #+28]
   \   00000326   0x4033             ANDS     R3,R6,R3
    771                  halInternalWakeEvent |= ((GPIO_IN_SAVED^GPIO_IN_NEW)&gpioWakeSel);
    772                  //PWRUP_SC1 is PB2 which is bit 10
    773                  halInternalWakeEvent |= (!!(powerUpEvents&PWRUP_SC1))<<((1*8)+2);
    774                  //PWRUP_SC2 is PA2 which is bit 2
    775                  halInternalWakeEvent |= (!!(powerUpEvents&PWRUP_SC2))<<((0*8)+2);
    776                  //PWRUP_IRQD is chosen by GPIO_IRQDSEL
    777                  halInternalWakeEvent |= (!!(powerUpEvents&PWRUP_IRQD))<<(GPIO_IRQDSEL);
   \   00000328   0xF8D5 0xC010      LDR      R12,[R5, #+16]
    778                  halInternalWakeEvent |= ((powerUpEvents & 
    779                                            (PWRUP_CSYSPWRUPREQ_MASK  |
    780                                             PWRUP_CDBGPWRUPREQ_MASK  |
    781                                             PWRUP_WAKECORE_MASK      |
    782                                             PWRUP_SLEEPTMRWRAP_MASK  |
    783                                             PWRUP_SLEEPTMRCOMPB_MASK |
    784                                             PWRUP_SLEEPTMRCOMPA_MASK ))
    785                                                    <<INTERNAL_WAKE_EVENT_BIT_SHIFT);
   \   0000032C   0x687E             LDR      R6,[R7, #+4]
   \   0000032E   0xF8DD 0xE008      LDR      LR,[SP, #+8]
   \   00000332   0xEA42 0x2000      ORR      R0,R2,R0, LSL #+8
   \   00000336   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   0000033A   0xEA80 0x000E      EOR      R0,R0,LR
   \   0000033E   0x9900             LDR      R1,[SP, #+0]
   \   00000340   0x4008             ANDS     R0,R1,R0
   \   00000342   0x0859             LSRS     R1,R3,#+1
   \   00000344   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000348   0xEA40 0x2081      ORR      R0,R0,R1, LSL #+10
   \   0000034C   0x0899             LSRS     R1,R3,#+2
   \   0000034E   0xF001 0x0101      AND      R1,R1,#0x1
   \   00000352   0xEA40 0x0081      ORR      R0,R0,R1, LSL #+2
   \   00000356   0x08D9             LSRS     R1,R3,#+3
   \   00000358   0xF001 0x0101      AND      R1,R1,#0x1
   \   0000035C   0xFA01 0xF10C      LSL      R1,R1,R12
   \   00000360   0x4308             ORRS     R0,R1,R0
   \   00000362   0xF403 0x717C      AND      R1,R3,#0x3F0
   \   00000366   0xEA40 0x5001      ORR      R0,R0,R1, LSL #+20
   \   0000036A   0x4330             ORRS     R0,R0,R6
   \   0000036C   0x6078             STR      R0,[R7, #+4]
    786                  //at this point wake events are fully captured and interrupts have
    787                  //taken over handling all new events
    788                  
    789                  //[[
    790                  SLEEP_TRACE_1SEC_DELAY(2);
    791                  SLEEP_TRACE_ADD_MARKER('b');
    792                  //]]
    793                  
    794                  //Bring limited interrupts back online.  INTERRUPTS_OFF will use
    795                  //BASEPRI to disable all interrupts except fault handlers and PendSV.
    796                  //PRIMASK is still set though (global interrupt disable) so we need
    797                  //to clear that next.
    798                  INTERRUPTS_OFF();
   \   0000036E   0x.... 0x....      BL       _disableBasePri
    799                  
    800                  //[[
    801                  SLEEP_TRACE_ADD_MARKER('c');
    802                  //]]
    803                  
    804                  //Now that BASEPRI has taken control of interrupt enable/disable,
    805                  //we can clear PRIMASK to reenable global interrupt operation.
    806                  _clearPriMask();
   \   00000372   0x.... 0x....      BL       _clearPriMask
    807                  
    808                  //[[
    809                  SLEEP_TRACE_ADD_MARKER('d');
    810                  //]]
    811                  
    812                  //wake events are saved and interrupts are back on track,
    813                  //disable gpio freeze
    814                  EVENT_CTRL = EVENT_CTRL_RESET;
   \   00000376   0x2000             MOVS     R0,#+0
   \   00000378   0x6020             STR      R0,[R4, #+0]
    815                  
    816                  //restart watchdog if it was running when we entered sleep
    817                  //do this before dispatching interrupts while we still have tight
    818                  //control of code execution
    819                  if(restoreWatchdog) {
   \   0000037A   0xF89D 0x005C      LDRB     R0,[SP, #+92]
   \   0000037E   0xB108             CBZ.N    R0,??halInternalSleep_24
    820                    halInternalEnableWatchDog();
   \   00000380   0x.... 0x....      BL       halInternalEnableWatchDog
    821                  }
    822                  
    823                  //[[
    824                  SLEEP_TRACE_ADD_MARKER('e');
    825                  //]]
    826                  
    827                  //Pend any interrupts associated with deep sleep wake sources.  The
    828                  //restoration of INT_CFGSET above and the changing of BASEPRI below
    829                  //is responsible for proper dispatching of interrupts at the end of
    830                  //halSleep.
    831                  //
    832                  //
    833                  //The WAKE_CORE wake source triggers a Debug Interrupt.  If INT_DEBUG
    834                  //interrupt is enabled and WAKE_CORE is a wake event, then pend the
    835                  //Debug interrupt (using the wake_core bit).
    836                  if( (INT_CFGSET&INT_DEBUG) &&
    837                      (halInternalWakeEvent&BIT(WAKE_CORE_INTERNAL_WAKE_EVENT_BIT)) ) {
   \                     ??halInternalSleep_24:
   \   00000384   0x6878             LDR      R0,[R7, #+4]
   \   00000386   0x....             LDR.N    R1,??DataTable5_7  ;; 0xe000e100
   \   00000388   0x6809             LDR      R1,[R1, #+0]
   \   0000038A   0x03C9             LSLS     R1,R1,#+15
   \   0000038C   0xD503             BPL.N    ??halInternalSleep_25
   \   0000038E   0x0101             LSLS     R1,R0,#+4
   \   00000390   0xBF44             ITT      MI 
   \   00000392   0x2120             MOVMI    R1,#+32
   \   00000394   0x6221             STRMI    R1,[R4, #+32]
    838                    WAKE_CORE = WAKE_CORE_FIELD;
    839                    //[[
    840                    SLEEP_TRACE_ADD_MARKER('g');
    841                    //]]
    842                  }
    843                  //
    844                  //
    845                  //The SleepTMR CMPA is linked to a real ISR.  If the SleepTMR CMPA
    846                  //interrupt is enabled and CMPA is a wake event, then pend the CMPA
    847                  //interrupt (force the second level interrupt).
    848                  if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) &&
    849                      (halInternalWakeEvent&BIT(CMPA_INTERNAL_WAKE_EVENT_BIT)) ) {
   \                     ??halInternalSleep_25:
   \   00000396   0xF8D8 0x1040      LDR      R1,[R8, #+64]
   \   0000039A   0x0789             LSLS     R1,R1,#+30
   \   0000039C   0xD504             BPL.N    ??halInternalSleep_26
   \   0000039E   0x01C1             LSLS     R1,R0,#+7
   \   000003A0   0xBF44             ITT      MI 
   \   000003A2   0x2102             MOVMI    R1,#+2
   \   000003A4   0xF8C8 0x100C      STRMI    R1,[R8, #+12]
    850                    INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPA;
    851                    //[[
    852                    SLEEP_TRACE_ADD_MARKER('h');
    853                    //]]
    854                  }
    855                  //
    856                  //The SleepTMR CMPB is linked to a real ISR.  If the SleepTMR CMPB
    857                  //interrupt is enabled and CMPB is a wake event, then pend the CMPB
    858                  //interrupt (force the second level interrupt).
    859                  if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPB) &&
    860                      (halInternalWakeEvent&BIT(CMPB_INTERNAL_WAKE_EVENT_BIT)) ) {
   \                     ??halInternalSleep_26:
   \   000003A8   0xF8D8 0x1040      LDR      R1,[R8, #+64]
   \   000003AC   0x0749             LSLS     R1,R1,#+29
   \   000003AE   0xD504             BPL.N    ??halInternalSleep_27
   \   000003B0   0x0181             LSLS     R1,R0,#+6
   \   000003B2   0xBF44             ITT      MI 
   \   000003B4   0x2104             MOVMI    R1,#+4
   \   000003B6   0xF8C8 0x100C      STRMI    R1,[R8, #+12]
    861                    INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPB;
    862                    //[[
    863                    SLEEP_TRACE_ADD_MARKER('i');
    864                    //]]
    865                  }
    866                  //
    867                  //The SleepTMR WRAP is linked to a real ISR.  If the SleepTMR WRAP
    868                  //interrupt is enabled and WRAP is a wake event, then pend the WRAP
    869                  //interrupt (force the second level interrupt).
    870                  if( (INT_SLEEPTMRCFG&INT_SLEEPTMRWRAP) &&
    871                      (halInternalWakeEvent&BIT(WRAP_INTERNAL_WAKE_EVENT_BIT)) ) {
   \                     ??halInternalSleep_27:
   \   000003BA   0xF8D8 0x1040      LDR      R1,[R8, #+64]
   \   000003BE   0x07C9             LSLS     R1,R1,#+31
   \   000003C0   0xD503             BPL.N    ??halInternalSleep_28
   \   000003C2   0x0141             LSLS     R1,R0,#+5
   \   000003C4   0xBF48             IT       MI 
   \   000003C6   0xF8C8 0xA00C      STRMI    R10,[R8, #+12]
    872                    INT_SLEEPTMRFORCE = INT_SLEEPTMRWRAP;
    873                    //[[
    874                    SLEEP_TRACE_ADD_MARKER('j');
    875                    //]]
    876                  }
    877                  //
    878                  //
    879                  //The four IRQs are linked to a real ISR.  If any of the four IRQs
    880                  //triggered, then pend their ISR
    881                  //
    882                  //If the IRQA interrupt mode is enabled and IRQA (PB0) is wake
    883                  //event, then pend the interrupt.
    884                  if( ((GPIO_INTCFGA&GPIO_INTMOD)!=0) &&
    885                      (halInternalWakeEvent&BIT(PORTB_PIN(0))) ) {
   \                     ??halInternalSleep_28:
   \   000003CA   0xF8D9 0x104C      LDR      R1,[R9, #+76]
   \   000003CE   0xF011 0x0FE0      TST      R1,#0xE0
   \   000003D2   0xD005             BEQ.N    ??halInternalSleep_29
   \   000003D4   0x05C1             LSLS     R1,R0,#+23
   \   000003D6   0xD503             BPL.N    ??halInternalSleep_29
    886                    INT_PENDSET = INT_IRQA;
   \   000003D8   0x....             LDR.N    R1,??DataTable5_12  ;; 0xe000e200
   \   000003DA   0xF44F 0x5280      MOV      R2,#+4096
   \   000003DE   0x600A             STR      R2,[R1, #+0]
    887                    //[[
    888                    SLEEP_TRACE_ADD_MARKER('k');
    889                    //]]
    890                  }
    891                  //If the IRQB interrupt mode is enabled and IRQB (PB6) is wake
    892                  //event, then pend the interrupt.
    893                  if( ((GPIO_INTCFGB&GPIO_INTMOD)!=0) &&
    894                      (halInternalWakeEvent&BIT(PORTB_PIN(6))) ) {
   \                     ??halInternalSleep_29:
   \   000003E0   0xF8D9 0x1050      LDR      R1,[R9, #+80]
   \   000003E4   0xF011 0x0FE0      TST      R1,#0xE0
   \   000003E8   0xD005             BEQ.N    ??halInternalSleep_30
   \   000003EA   0x0441             LSLS     R1,R0,#+17
   \   000003EC   0xD503             BPL.N    ??halInternalSleep_30
    895                    INT_PENDSET = INT_IRQB;
   \   000003EE   0x....             LDR.N    R1,??DataTable5_12  ;; 0xe000e200
   \   000003F0   0xF44F 0x5200      MOV      R2,#+8192
   \   000003F4   0x600A             STR      R2,[R1, #+0]
    896                    //[[
    897                    SLEEP_TRACE_ADD_MARKER('l');
    898                    //]]
    899                  }
    900                  //If the IRQC interrupt mode is enabled and IRQC (GPIO_IRQCSEL) is wake
    901                  //event, then pend the interrupt.
    902                  if( ((GPIO_INTCFGC&GPIO_INTMOD)!=0) &&
    903                      (halInternalWakeEvent&BIT(GPIO_IRQCSEL)) ) {
   \                     ??halInternalSleep_30:
   \   000003F6   0xF8D9 0x1054      LDR      R1,[R9, #+84]
   \   000003FA   0xF011 0x0FE0      TST      R1,#0xE0
   \   000003FE   0xBF1E             ITTT     NE 
   \   00000400   0x68E9             LDRNE    R1,[R5, #+12]
   \   00000402   0xFA0A 0xF101      LSLNE    R1,R10,R1
   \   00000406   0x4208             TSTNE    R0,R1
   \   00000408   0xD003             BEQ.N    ??halInternalSleep_31
    904                    INT_PENDSET = INT_IRQC;
   \   0000040A   0x....             LDR.N    R1,??DataTable5_12  ;; 0xe000e200
   \   0000040C   0xF44F 0x4280      MOV      R2,#+16384
   \   00000410   0x600A             STR      R2,[R1, #+0]
    905                    //[[
    906                    SLEEP_TRACE_ADD_MARKER('m');
    907                    //]]
    908                  }
    909                  //If the IRQD interrupt mode is enabled and IRQD (GPIO_IRQDSEL) is wake
    910                  //event, then pend the interrupt.
    911                  if( ((GPIO_INTCFGD&GPIO_INTMOD)!=0) &&
    912                      (halInternalWakeEvent&BIT(GPIO_IRQDSEL)) ) {
   \                     ??halInternalSleep_31:
   \   00000412   0xF8D9 0x1058      LDR      R1,[R9, #+88]
   \   00000416   0xF011 0x0FE0      TST      R1,#0xE0
   \   0000041A   0xBF1E             ITTT     NE 
   \   0000041C   0x6929             LDRNE    R1,[R5, #+16]
   \   0000041E   0xFA0A 0xF101      LSLNE    R1,R10,R1
   \   00000422   0x4208             TSTNE    R0,R1
   \   00000424   0xD003             BEQ.N    ??halInternalSleep_32
    913                    INT_PENDSET = INT_IRQD;
   \   00000426   0x....             LDR.N    R1,??DataTable5_12  ;; 0xe000e200
   \   00000428   0xF44F 0x4200      MOV      R2,#+32768
   \   0000042C   0x600A             STR      R2,[R1, #+0]
    914                    //[[
    915                    SLEEP_TRACE_ADD_MARKER('n');
    916                    //]]
    917                  }
    918                  
    919                  //Due to FogBugz 11909/11920, SLEEPTMR_CNT may not have updated yet so
    920                  //we must ensure that the CNT register updates before returning.  It's
    921                  //only necessary to wait for the CNT to update when we've gone to
    922                  //sleep, the SLEEPTMR is enabled, and the sleep mode used a timer.
    923                  //This code could delay for up to 1ms, but will return as soon as it
    924                  //can.  In the situation where the chip slept for a known amount of
    925                  //time, this code will not delay and instead the system timer will
    926                  //report a fake, but accurate time.
    927                  if((!skipSleep) &&
    928                     (SLEEPTMR_CFG&SLEEPTMR_ENABLE) &&
    929                     (SLEEPTMR_CLKEN&SLEEPTMR_CLK10KEN) &&
    930                     (sleepMode!=SLEEPMODE_NOTIMER)) {
   \                     ??halInternalSleep_32:
   \   0000042E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000432   0xD170             BNE.N    ??halInternalSleep_33
   \   00000434   0x....             LDR.N    R1,??DataTable5_14  ;; 0x4000600c
   \   00000436   0x6809             LDR      R1,[R1, #+0]
   \   00000438   0x0509             LSLS     R1,R1,#+20
   \   0000043A   0xD56C             BPL.N    ??halInternalSleep_33
   \   0000043C   0x6861             LDR      R1,[R4, #+4]
   \   0000043E   0x0789             LSLS     R1,R1,#+30
   \   00000440   0xD569             BPL.N    ??halInternalSleep_33
   \   00000442   0xF89D 0x1068      LDRB     R1,[SP, #+104]
   \   00000446   0x2904             CMP      R1,#+4
   \   00000448   0xD065             BEQ.N    ??halInternalSleep_33
    931                    int32u currSleepTmrCnt;
    932                    
    933                    #ifdef BUG11909_WORKAROUND_C
    934                    //THIS WORKAROUND IS NOT PROVEN 100% RELIABLE.  THIS SHOULD NOT BE
    935                    //USED UNTIL IT IS PROVEN PERFECTLY RELIABLE.
    936                    //This workaround attempts to force the SLEEPTMR_CNT to tick sooner
    937                    //than normal.  It does so by toggling between the clock sources
    938                    //to get the CNT to increment.  There is a chance the SLEEPTMR_CNT
    939                    //could become random doing this!
    940                    {
    941                      currSleepTmrCnt = SLEEPTMR_CNTH<<16;
    942                      currSleepTmrCnt |= SLEEPTMR_CNTL;
    943                      if(currSleepTmrCnt == wakeupSleepTmrCnt) {
    944                        int32u GPIO_PCOUT_SAVED = GPIO_PCOUT;
    945                        int32u GPIO_PCCFGH_SAVED = GPIO_PCCFGH;
    946                        int32u SLEEPTMR_CFG_SAVED = SLEEPTMR_CFG;
    947                        //It is not necessary to do anything with SLEEPTMR_CLKEN.
    948                        GPIO_PCSET = PC7;
    949                        SET_REG_FIELD(GPIO_PCCFGH, PC7_CFG, GPIOCFG_OUT);
    950                        do {
    951                          //Toggling between RC/XTAL will produce a clock edge
    952                          //into the timer and cause CNT to increment.
    953                          SLEEPTMR_CFG ^= SLEEPTMR_CLKSEL;
    954                          currSleepTmrCnt = SLEEPTMR_CNTH<<16;
    955                          currSleepTmrCnt |= SLEEPTMR_CNTL;
    956                        } while(currSleepTmrCnt == wakeupSleepTmrCnt);
    957                        GPIO_PCOUT = GPIO_PCOUT_SAVED;
    958                        GPIO_PCCFGH = GPIO_PCCFGH_SAVED;
    959                        SLEEPTMR_CFG = SLEEPTMR_CFG_SAVED;
    960                        forceSleepTmrCnt = FALSE;
    961                      }
    962                    }
    963                    #endif //BUG11909_WORKAROUND_C
    964                    
    965                    //Knowing that halSleepTimerIsr is about to be taken (when
    966                    //interrupts get enabled) tells us that the chip woke up due
    967                    //to the timer and therefore sleepTmrArtificalCnt is valid
    968                    //and needs to be forced.  This allows us to bypass delaying
    969                    //for SLEEPTMR_CNT to tick forward.  For FogBugz 11909/11920
    970                    //workaround.
    971                    if((INT_CFGSET&INT_SLEEPTMR) && (INT_PENDSET&INT_SLEEPTMR)) {
   \   0000044A   0x....             LDR.N    R1,??DataTable5_7  ;; 0xe000e100
   \   0000044C   0x6809             LDR      R1,[R1, #+0]
   \   0000044E   0x06C9             LSLS     R1,R1,#+27
   \   00000450   0xD542             BPL.N    ??halInternalSleep_34
   \   00000452   0x....             LDR.N    R1,??DataTable5_12  ;; 0xe000e200
   \   00000454   0x6809             LDR      R1,[R1, #+0]
   \   00000456   0x06C9             LSLS     R1,R1,#+27
   \   00000458   0xD53E             BPL.N    ??halInternalSleep_34
    972                      //sleepTmrArtificalCnt was set before sleeping
    973                      //by halSleepForQuarterSeconds
    974                      forceSleepTmrCnt = TRUE;
   \   0000045A   0xF887 0xA000      STRB     R10,[R7, #+0]
   \   0000045E   0xE05A             B.N      ??halInternalSleep_33
    975                    } else {
   \                     ??halInternalSleep_21:
   \   00000460   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000464   0xF47F 0xAF10      BNE.W    ??halInternalSleep_22
   \   00000468   0x....             LDR.N    R0,??DataTable5_5  ;; 0x40004004
   \   0000046A   0x6980             LDR      R0,[R0, #+24]
   \   0000046C   0x0840             LSRS     R0,R0,#+1
   \   0000046E   0x0040             LSLS     R0,R0,#+1
   \   00000470   0x....             LDR.N    R1,??DataTable5_5  ;; 0x40004004
   \   00000472   0x6188             STR      R0,[R1, #+24]
   \   00000474   0x....             LDR.N    R0,??DataTable5_8  ;; 0xe000ed04
   \   00000476   0x68C0             LDR      R0,[R0, #+12]
   \   00000478   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000047C   0x....             LDR.N    R1,??DataTable5_8  ;; 0xe000ed04
   \   0000047E   0x60C8             STR      R0,[R1, #+12]
   \   00000480   0x....             LDR.N    R0,??DataTable5_15
   \   00000482   0xF880 0xA000      STRB     R10,[R0, #+0]
   \   00000486   0xF24F 0x010F      MOVW     R1,#+61455
   \   0000048A   0x....             LDR.N    R2,??DataTable5_16
   \   0000048C   0x8813             LDRH     R3,[R2, #+0]
   \   0000048E   0xF240 0x2C07      MOVW     R12,#+519
   \   00000492   0x4563             CMP      R3,R12
   \   00000494   0xBF04             ITT      EQ 
   \   00000496   0x8853             LDRHEQ   R3,[R2, #+2]
   \   00000498   0x428B             CMPEQ    R3,R1
   \   0000049A   0xD103             BNE.N    ??halInternalSleep_35
   \   0000049C   0xF24C 0x333C      MOVW     R3,#+49980
   \   000004A0   0x8053             STRH     R3,[R2, #+2]
   \   000004A2   0x46D3             MOV      R11,R10
   \                     ??halInternalSleep_35:
   \   000004A4   0x....             LDR.N    R3,??DataTable5_8  ;; 0xe000ed04
   \   000004A6   0x681B             LDR      R3,[R3, #+0]
   \   000004A8   0xF043 0x5380      ORR      R3,R3,#0x10000000
   \   000004AC   0x.... 0x....      LDR.W    R12,??DataTable5_8  ;; 0xe000ed04
   \   000004B0   0xF8CC 0x3000      STR      R3,[R12, #+0]
   \                     ??halInternalSleep_36:
   \   000004B4   0x7803             LDRB     R3,[R0, #+0]
   \   000004B6   0x2B00             CMP      R3,#+0
   \   000004B8   0xD1FC             BNE.N    ??halInternalSleep_36
   \   000004BA   0xF1BB 0x0F00      CMP      R11,#+0
   \   000004BE   0xBF1C             ITT      NE 
   \   000004C0   0x8051             STRHNE   R1,[R2, #+2]
   \   000004C2   0xF04F 0x0B00      MOVNE    R11,#+0
   \   000004C6   0x....             LDR.N    R0,??DataTable5_14  ;; 0x4000600c
   \   000004C8   0x6840             LDR      R0,[R0, #+4]
   \   000004CA   0x0400             LSLS     R0,R0,#+16
   \   000004CC   0x60B8             STR      R0,[R7, #+8]
   \   000004CE   0x....             LDR.N    R1,??DataTable5_14  ;; 0x4000600c
   \   000004D0   0x6889             LDR      R1,[R1, #+8]
   \   000004D2   0x4308             ORRS     R0,R1,R0
   \   000004D4   0x60B8             STR      R0,[R7, #+8]
   \   000004D6   0xE6DD             B.N      ??halInternalSleep_23
    976                      int16u us = 1000;
   \                     ??halInternalSleep_34:
   \   000004D8   0xF44F 0x717A      MOV      R1,#+1000
    977                      int32u beginTime;
    978                      forceSleepTmrCnt = FALSE;
   \   000004DC   0x2200             MOVS     R2,#+0
   \   000004DE   0x703A             STRB     R2,[R7, #+0]
    979                      //It is possible to be in a situation where the SLEEPTMR is no
    980                      //longer ticking (32k XTAL issues).  To guard against getting
    981                      //stuck in this loop, use the MAC Timer to timeout after 1ms (since
    982                      //that is the maximum time this loop would normally delay for).
    983                      MAC_TIMER_CTRL |= MAC_TIMER_CTRL_MAC_TIMER_EN;
   \   000004E0   0x....             LDR.N    R2,??DataTable5_17  ;; 0x40002038
   \   000004E2   0x6D53             LDR      R3,[R2, #+84]
   \   000004E4   0xF043 0x0301      ORR      R3,R3,#0x1
   \   000004E8   0x6553             STR      R3,[R2, #+84]
    984                      if((OSC24M_CTRL&OSC24M_CTRL_OSC24M_SEL)!=OSC24M_CTRL_OSC24M_SEL) {
   \   000004EA   0x....             LDR.N    R3,??DataTable5_5  ;; 0x40004004
   \   000004EC   0x699B             LDR      R3,[R3, #+24]
   \   000004EE   0x07DB             LSLS     R3,R3,#+31
   \   000004F0   0xBF58             IT       PL 
   \   000004F2   0xF44F 0x71FA      MOVPL    R1,#+500
    985                        us >>= 1;
    986                      }
    987                      beginTime = MAC_TIMER;
   \   000004F6   0x6813             LDR      R3,[R2, #+0]
    988                      do{
    989                        currSleepTmrCnt = SLEEPTMR_CNTH<<16;
   \                     ??halInternalSleep_37:
   \   000004F8   0x....             LDR.N    R4,??DataTable5_14  ;; 0x4000600c
   \   000004FA   0x6864             LDR      R4,[R4, #+4]
    990                        currSleepTmrCnt |= SLEEPTMR_CNTL;
   \   000004FC   0x....             LDR.N    R5,??DataTable5_14  ;; 0x4000600c
   \   000004FE   0x68AD             LDR      R5,[R5, #+8]
    991                      }while((currSleepTmrCnt == wakeupSleepTmrCnt) &&
    992                             (((MAC_TIMER-beginTime)&MAC_TIMER_MAC_TIMER_MASK) < us));
   \   00000500   0xEA45 0x4404      ORR      R4,R5,R4, LSL #+16
   \   00000504   0x68BD             LDR      R5,[R7, #+8]
   \   00000506   0x42AC             CMP      R4,R5
   \   00000508   0xD105             BNE.N    ??halInternalSleep_33
   \   0000050A   0x6814             LDR      R4,[R2, #+0]
   \   0000050C   0x1AE4             SUBS     R4,R4,R3
   \   0000050E   0x0324             LSLS     R4,R4,#+12
   \   00000510   0x0B24             LSRS     R4,R4,#+12
   \   00000512   0x428C             CMP      R4,R1
   \   00000514   0xD3F0             BCC.N    ??halInternalSleep_37
    993                    }
    994                  }
    995                }
    996                
    997                //[[
    998                SLEEP_TRACE_1SEC_DELAY(3);
    999                SLEEP_TRACE_ADD_MARKER('o');
   1000                //]]
   1001                
   1002                //Mark the wake events valid just before exiting
   1003                halInternalWakeEvent |= BIT32(WAKEINFOVALID_INTERNAL_WAKE_EVENT_BIT);
   \                     ??halInternalSleep_33:
   \   00000516   0xF040 0x4000      ORR      R0,R0,#0x80000000
   \   0000051A   0x6078             STR      R0,[R7, #+4]
   1004                
   1005                //We are now reconfigured, appropriate ISRs are pended, and ready to go,
   1006                //so enable interrupts!
   1007                INTERRUPTS_ON();
   \   0000051C   0xB01B             ADD      SP,SP,#+108
   \   0000051E   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000522   0x.... 0x....      B.W      _enableBasePri
   1008                
   1009                //[[
   1010                SLEEP_TRACE_ADD_MARKER('p');
   1011                //]]
   1012                
   1013                break; //and deep sleeping is done!
   1014              
   1015              case SLEEPMODE_IDLE:
   1016                //Only the CPU is idled.  The rest of the chip continues runing
   1017                //normally.  The chip will wake from any interrupt.
   1018                {
   1019                  boolean restoreWatchdog = halInternalWatchDogEnabled();
   \                     ??halInternalSleep_5:
   \   00000526   0x.... 0x....      BL       halInternalWatchDogEnabled
   \   0000052A   0x4604             MOV      R4,R0
   1020                  //disable watchdog while sleeping (since we can't reset it asleep)
   1021                  halInternalDisableWatchDog(MICRO_DISABLE_WATCH_DOG_KEY);
   \   0000052C   0x20A5             MOVS     R0,#+165
   \   0000052E   0x.... 0x....      BL       halInternalDisableWatchDog
   1022                  //Normal ATOMIC/INTERRUPTS_OFF/INTERRUPTS_ON uses the BASEPRI mask
   1023                  //to juggle priority levels so that the fault handlers can always
   1024                  //be serviced.  But, the WFI instruction is only capable of
   1025                  //working with the PRIMASK bit.  Therefore, we have to switch from
   1026                  //using BASEPRI to PRIMASK to keep interrupts disabled so that the
   1027                  //WFI can return on an interrupt
   1028                  //Globally disable interrupts with PRIMASK
   1029                  _setPriMask();
   \   00000532   0x.... 0x....      BL       _setPriMask
   1030                  //Bring the BASEPRI up to 0 to allow interrupts (but still disabled
   1031                  //with PRIMASK)
   1032                  INTERRUPTS_ON();
   \   00000536   0x.... 0x....      BL       _enableBasePri
   1033                  //an internal function call is made here instead of injecting the
   1034                  //"WFI" assembly instruction because injecting assembly code will
   1035                  //cause the compiler's optimizer to reduce efficiency.
   1036                  #ifdef FLASH_ACCESS_FLASH_LP
   1037                  BYPASS_MPU(
   1038                    int32u FLASH_ACCESS_SAVED = FLASH_ACCESS;
   1039                    FLASH_ACCESS &= ~FLASH_ACCESS_FLASH_LP;
   1040                    halInternalIdleSleep();
   1041                    FLASH_ACCESS = FLASH_ACCESS_SAVED;
   1042                  )
   \   0000053A   0x....             LDR.N    R5,??DataTable5_18  ;; 0xe000ed94
   \   0000053C   0x682E             LDR      R6,[R5, #+0]
   \   0000053E   0x6828             LDR      R0,[R5, #+0]
   \   00000540   0x0840             LSRS     R0,R0,#+1
   \   00000542   0x0040             LSLS     R0,R0,#+1
   \   00000544   0x6028             STR      R0,[R5, #+0]
   \   00000546   0x.... 0x....      BL       _executeBarrierInstructions
   \   0000054A   0x....             LDR.N    R7,??DataTable5_19  ;; 0x40008000
   \   0000054C   0xF8D7 0x8000      LDR      R8,[R7, #+0]
   \   00000550   0x6838             LDR      R0,[R7, #+0]
   \   00000552   0xF020 0x0040      BIC      R0,R0,#0x40
   \   00000556   0x6038             STR      R0,[R7, #+0]
   \   00000558   0x.... 0x....      BL       halInternalIdleSleep
   \   0000055C   0xF8C7 0x8000      STR      R8,[R7, #+0]
   \   00000560   0x602E             STR      R6,[R5, #+0]
   \   00000562   0x.... 0x....      BL       _executeBarrierInstructions
   1043                  #else //FLASH_ACCESS_FLASH_LP
   1044                  halInternalIdleSleep();
   1045                  #endif //FLASH_ACCESS_FLASH_LP
   1046                  //restart watchdog if it was running when we entered sleep
   1047                  if(restoreWatchdog)
   \   00000566   0xB10C             CBZ.N    R4,??halInternalSleep_38
   1048                    halInternalEnableWatchDog();
   \   00000568   0x.... 0x....      BL       halInternalEnableWatchDog
   1049                  //The WFI instruction does not actually clear the PRIMASK bit, it
   1050                  //only allows the PRIMASK bit to be bypassed.  Therefore, we must
   1051                  //manually clear PRIMASK to reenable all interrupts.
   1052                  _clearPriMask();
   \                     ??halInternalSleep_38:
   \   0000056C   0xB01B             ADD      SP,SP,#+108
   \   0000056E   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000572   0x.... 0x....      B.W      _clearPriMask
   1053                }
   1054                break;
   1055                
   1056              default:
   1057                //Oops!  Invalid sleepMode parameter.
   1058                assert(0);
   \                     ??halInternalSleep_6:
   \   00000576   0xB507             PUSH {R0,R1,R2,LR}
   \   00000578   0xF240 0x4122      MOVW     R1,#+1058
   \   0000057C   0x.... 0x....      ADR.W    R0,`?<Constant "sleep.c">`
   \   00000580   0xB01B             ADD      SP,SP,#+108
   \   00000582   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000586   0x.... 0x....      B.W      halInternalAssertFailed
   1059            }
   1060          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x9A00             LDR      R2,[SP, #+0]
   \   00000002   0x68EB             LDR      R3,[R5, #+12]
   \   00000004   0xFA0A 0xF303      LSL      R3,R10,R3
   \   00000008   0x421A             TST      R2,R3
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x....             LDR.N    R2,??DataTable5_12  ;; 0xe000e200
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0x4770             BX       LR
   1061          
   1062          

   \                                 In section .text, align 2, keep-with-next
   1063          void halSleepWithOptions(SleepModes sleepMode, int32u gpioWakeBitMask)
   1064          {
   1065            //configure all GPIO wake sources
   1066            GPIO_PAWAKE = (gpioWakeBitMask>>0)&0xFF;
   \                     halSleepWithOptions:
   \   00000000   0x....             LDR.N    R2,??DataTable5_2  ;; 0x4000bc08
   \   00000002   0xB2CB             UXTB     R3,R1
   \   00000004   0x6013             STR      R3,[R2, #+0]
   1067            GPIO_PBWAKE = (gpioWakeBitMask>>8)&0xFF;
   \   00000006   0xF3C1 0x2307      UBFX     R3,R1,#+8,#+8
   \   0000000A   0x6053             STR      R3,[R2, #+4]
   1068            GPIO_PCWAKE = (gpioWakeBitMask>>16)&0xFF;
   \   0000000C   0xF3C1 0x4107      UBFX     R1,R1,#+16,#+8
   \   00000010   0x6091             STR      R1,[R2, #+8]
   1069            
   1070            //use the defines found in the board file to choose our wakeup source(s)
   1071            WAKE_SEL = 0;  //start with no wake sources
   \   00000012   0x....             LDR.N    R1,??DataTable5_20  ;; 0x40000020
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x600B             STR      R3,[R1, #+0]
   1072            
   1073            //if any of the GPIO wakeup monitor bits are set, enable the top level
   1074            //GPIO wakeup monitor
   1075            if((GPIO_PAWAKE)||(GPIO_PBWAKE)||(GPIO_PCWAKE)) {
   \   00000018   0x6813             LDR      R3,[R2, #+0]
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xBF04             ITT      EQ 
   \   0000001E   0x6853             LDREQ    R3,[R2, #+4]
   \   00000020   0x2B00             CMPEQ    R3,#+0
   \   00000022   0xD101             BNE.N    ??halSleepWithOptions_0
   \   00000024   0x6892             LDR      R2,[R2, #+8]
   \   00000026   0xB11A             CBZ.N    R2,??halSleepWithOptions_1
   1076              WAKE_SEL |= GPIO_WAKE;
   \                     ??halSleepWithOptions_0:
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000002E   0x600A             STR      R2,[R1, #+0]
   1077            }
   1078            
   1079            //NOTE: The use of WAKE_CDBGPWRUPREQ should not be necessary since asserting
   1080            //CDBGPWRUPREQ will bring the chip to DS0 where the debug components are
   1081            //maintained but it's not necessary to completely wake to the running state.
   1082            
   1083            //always wakeup when the debugger attempts to access the chip
   1084            WAKE_SEL |= WAKE_CSYSPWRUPREQ;
   \                     ??halSleepWithOptions_1:
   \   00000030   0x680A             LDR      R2,[R1, #+0]
   \   00000032   0xF442 0x7200      ORR      R2,R2,#0x200
   \   00000036   0x600A             STR      R2,[R1, #+0]
   1085            
   1086            //always wakeup when the debug channel attempts to access the chip
   1087            WAKE_SEL |= WAKE_WAKE_CORE;
   \   00000038   0x680A             LDR      R2,[R1, #+0]
   \   0000003A   0xF042 0x0280      ORR      R2,R2,#0x80
   \   0000003E   0x600A             STR      R2,[R1, #+0]
   1088            //the timer wakeup sources are enabled below in POWERSAVE, if needed
   1089            
   1090            //wake sources are configured so do the actual sleeping
   1091            halInternalSleep(sleepMode);
   \   00000040   0x....             B.N      halInternalSleep
   1092          }
   1093          
   1094          
   1095          #if defined(WAKE_ON_PA0) &&\
   1096              defined(WAKE_ON_PA1) &&\
   1097              defined(WAKE_ON_PA2) &&\
   1098              defined(WAKE_ON_PA3) &&\
   1099              defined(WAKE_ON_PA4) &&\
   1100              defined(WAKE_ON_PA5) &&\
   1101              defined(WAKE_ON_PA6) &&\
   1102              defined(WAKE_ON_PA7) &&\
   1103              defined(WAKE_ON_PB0) &&\
   1104              defined(WAKE_ON_PB1) &&\
   1105              defined(WAKE_ON_PB2) &&\
   1106              defined(WAKE_ON_PB3) &&\
   1107              defined(WAKE_ON_PB4) &&\
   1108              defined(WAKE_ON_PB5) &&\
   1109              defined(WAKE_ON_PB6) &&\
   1110              defined(WAKE_ON_PB7) &&\
   1111              defined(WAKE_ON_PC0) &&\
   1112              defined(WAKE_ON_PC1) &&\
   1113              defined(WAKE_ON_PC2) &&\
   1114              defined(WAKE_ON_PC3) &&\
   1115              defined(WAKE_ON_PC4) &&\
   1116              defined(WAKE_ON_PC5) &&\
   1117              defined(WAKE_ON_PC6) &&\
   1118              defined(WAKE_ON_PC7)

   \                                 In section .text, align 2, keep-with-next
   1119          void halSleep(SleepModes sleepMode)
   1120          {
   1121            //configure all GPIO wake sources
   1122            int32u gpioWakeBitMask  = (((WAKE_ON_PA0 << PA0_BIT)|
   1123                                        (WAKE_ON_PA1 << PA1_BIT)|
   1124                                        (WAKE_ON_PA2 << PA2_BIT)|
   1125                                        (WAKE_ON_PA3 << PA3_BIT)|
   1126                                        (WAKE_ON_PA4 << PA4_BIT)|
   1127                                        (WAKE_ON_PA5 << PA5_BIT)|
   1128                                        (WAKE_ON_PA6 << PA6_BIT)|
   1129                                        (WAKE_ON_PA7 << PA7_BIT))<<0) |
   1130                                      (((WAKE_ON_PB0 << PB0_BIT)|
   1131                                        (WAKE_ON_PB1 << PB1_BIT)|
   1132                                        (WAKE_ON_PB2 << PB2_BIT)|
   1133                                        (WAKE_ON_PB3 << PB3_BIT)|
   1134                                        (WAKE_ON_PB4 << PB4_BIT)|
   1135                                        (WAKE_ON_PB5 << PB5_BIT)|
   1136                                        (WAKE_ON_PB6 << PB6_BIT)|
   1137                                        (WAKE_ON_PB7 << PB7_BIT))<<8) |
   1138                                      (((WAKE_ON_PC0 << PC0_BIT)|
   1139                                        (WAKE_ON_PC1 << PC1_BIT)|
   1140                                        (WAKE_ON_PC2 << PC2_BIT)|
   1141                                        (WAKE_ON_PC3 << PC3_BIT)|
   1142                                        (WAKE_ON_PC4 << PC4_BIT)|
   1143                                        (WAKE_ON_PC5 << PC5_BIT)|
   1144                                        (WAKE_ON_PC6 << PC6_BIT)|
   1145                                        (WAKE_ON_PC7 << PC7_BIT))<<16);
   1146            
   1147            halSleepWithOptions(sleepMode, gpioWakeBitMask);
   \                     halSleep:
   \   00000000   0x....             LDR.N    R1,??DataTable5_21
   \   00000002   0x7809             LDRB     R1,[R1, #+0]
   \   00000004   0x0189             LSLS     R1,R1,#+6
   \   00000006   0xF441 0x0180      ORR      R1,R1,#0x400000
   \   0000000A   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000000E   0x....             B.N      halSleepWithOptions
   1148          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     forceSleepTmrCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40000004         DC32     0x40000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x4000BC08         DC32     0x4000bc08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x4000A014         DC32     0x4000a014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x4000A814         DC32     0x4000a814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40004004         DC32     0x40004004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40005000         DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x4000B008         DC32     0x4000b008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x4000B408         DC32     0x4000b408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x4000B808         DC32     0x4000b808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0xE000E200         DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x4000600C         DC32     0x4000600c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x........         DC32     halPendSvSaveContext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x........         DC32     halResetInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x40002038         DC32     0x40002038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0xE000ED94         DC32     0xe000ed94

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x40000020         DC32     0x40000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0x........         DC32     halInternalWakeOnLedOrRho

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "sleep.c">`:
   \   00000000   0x73 0x6C          DC8 "sleep.c"
   \              0x65 0x65    
   \              0x70 0x2E    
   \              0x63 0x00    
   1149          #endif
   1150          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  halGetWakeInfo
        0  halInternalMimickLvReset
      144  halInternalSleep
               0 -> _clearPriMask
             144 -> _clearPriMask
             144 -> _disableBasePri
               0 -> _enableBasePri
             144 -> _enableBasePri
             144 -> _executeBarrierInstructions
             144 -> _setPriMask
               0 -> halInternalAssertFailed
             144 -> halInternalDisableWatchDog
             144 -> halInternalEnableMPU
             144 -> halInternalEnableWatchDog
             144 -> halInternalIdleSleep
             144 -> halInternalWatchDogEnabled
        0  halSleep
               0 -> halSleepWithOptions
        0  halSleepWithOptions
               0 -> halInternalSleep


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "sleep.c">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       6  ?Subroutine0
      12  ?Subroutine1
      12  forceSleepTmrCnt
          halInternalWakeEvent
          wakeupSleepTmrCnt
       8  halGetWakeInfo
       2  halInternalMimickLvReset
    1418  halInternalSleep
      16  halSleep
      66  halSleepWithOptions

 
    12 bytes in section .bss
 1 624 bytes in section .text
 
 1 624 bytes of CODE memory
    12 bytes of DATA memory

Errors: none
Warnings: none
