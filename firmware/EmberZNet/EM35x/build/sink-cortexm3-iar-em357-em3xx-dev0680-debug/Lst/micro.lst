###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     02/Jul/2013  21:36:41 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\micro.c                                        #
#    Command line =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\micro.c -D DEBUG -D                            #
#                    "BOARD_HEADER=\"hal/micro/cortexm3/em35x/board/dev0680.h #
#                    \"" -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/ia #
#                    r.h\"" -D HAL_MICRO -D CORTEXM3 -D CORTEXM3_EM357 -D     #
#                    PHY_EM3XX -D BOARD_DEV0680 -D                            #
#                    "CONFIGURATION_HEADER=\"app/sensor/sensor-configuration. #
#                    h\"" -D SINK_APP -D EMBER_SERIAL1_MODE=EMBER_SERIAL_FIFO #
#                     -D EMBER_SERIAL1_TX_QUEUE_SIZE=128 -D                   #
#                    EMBER_SERIAL1_RX_QUEUE_SIZE=16 -D EMBER_SERIAL0_DEBUG    #
#                    -D EMBER_SERIAL0_MODE=EMBER_SERIAL_FIFO -D               #
#                    EMBER_SERIAL0_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL0_RX_QUEUE_SIZE=64 -D                        #
#                    SCAN_DEBUG_PRINT_ENABLE -D USE_BOOTLOADER_LIB -D         #
#                    "__SOURCEFILE__=\"micro.c\"" -lC                         #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\            #
#                    --diag_suppress Pa050 -o F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\build\sink-cortexm3-iar-em357-em3xx-dev0 #
#                    680-debug\Obj\ --debug --endian=little --cpu=Cortex-M3   #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I F:\Firmware\emberZNet\firmware\EmberZNet\EM35x #
#                    \hal\micro\cortexm3\ -I F:\Firmware\emberZNet\firmware\E #
#                    mberZNet\EM35x\app\sensor\ewb-em357\..\..\..\ -I         #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\STACK\ -I                           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\HAL\ -I                             #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -Ohz --use_c++_inline              #
#    List file    =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\micro.lst   #
#    Object file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Obj\micro.o     #
#                                                                             #
#                                                                             #
###############################################################################

F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro\cortexm3\micro.c
      1          /*
      2           * File: micro.c
      3           * Description: EM3XX micro specific full HAL functions
      4           *
      5           *
      6           * Copyright 2008, 2009 by Ember Corporation. All rights reserved.          *80*
      7           */
      8          //[[ Author(s): Brooks Barrett, Lee Taylor ]]
      9          
     10          
     11          #include PLATFORM_HEADER
     12          #include "stack/include/ember.h"
     13          #include "include/error.h"
     14          
     15          #include "hal/hal.h"
     16          #include "app/util/serial/serial.h"
     17          #include "hal/micro/cortexm3/diagnostic.h"
     18          #include "hal/micro/cortexm3/memmap.h"
     19          #include "hal/micro/cortexm3/flash.h"
     20          
     21          
     22          // halInit is called on first initial boot, not on wakeup from sleep.

   \                                 In section .text, align 2, keep-with-next
     23          void halInit(void)
     24          {
   \                     halInit:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     25            //[[ Strip emulator only code from official build
     26            #ifdef EMBER_EMU_TEST
     27              //On the emulator, give our fake XTAL reasonable thresholds so the cal
     28              //algorithm ends up at 4.
     29              EMU_OSC24M_CTRL =((0x8<<EMU_OSC24M_CTRL_OSC24M_THRESH_H_BIT) |
     30                                (0x2<<EMU_OSC24M_CTRL_OSC24M_THRESH_L_BIT) |
     31                                (0x0<<EMU_OSC24M_CTRL_OSC24M_THRESH_STOP_BIT));
     32            #endif
     33            //]]
     34            
     35            halCommonStartXtal();
   \   00000002   0x.... 0x....      BL       halCommonTryToSwitchToXtal
     36            
     37            halInternalSetRegTrim(FALSE);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       halInternalSetRegTrim
     38            
     39            GPIO_DBGCFG |= GPIO_DBGCFGRSVD;
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable25  ;; 0x4000bc00
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000016   0x6020             STR      R0,[R4, #+0]
     40            
     41            #ifndef DISABLE_WATCHDOG
     42              halInternalEnableWatchDog();
   \   00000018   0x.... 0x....      BL       halInternalEnableWatchDog
     43            #endif
     44            
     45            halCommonCalibratePads();
   \   0000001C   0x.... 0x....      BL       halCommonCalibratePads
     46            
     47            halInternalInitBoard();
   \   00000020   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0:
   \   00000024   0x788D             LDRB     R5,[R1, #+2]
   \   00000026   0x60DD             STR      R5,[R3, #+12]
   \   00000028   0x898D             LDRH     R5,[R1, #+12]
   \   0000002A   0x6005             STR      R5,[R0, #+0]
   \   0000002C   0x89CD             LDRH     R5,[R1, #+14]
   \   0000002E   0x6045             STR      R5,[R0, #+4]
   \   00000030   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_3:
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0xF020 0x0010      BIC      R0,R0,#0x10
   \   0000003A   0x6020             STR      R0,[R4, #+0]
   \   0000003C   0x.... 0x....      BL       halInternalInitAdc
   \   00000040   0x.... 0x....      BL       halInternalRestartUart
   \   00000044   0x.... 0x....      BL       halInternalInitButton
     48            
     49            halCommonSwitchToXtal();
   \   00000048   0x.... 0x....      BL       halCommonSwitchToXtal
     50            
     51            #ifndef DISABLE_RC_CALIBRATION
     52              halInternalCalibrateFastRc();
   \   0000004C   0x.... 0x....      BL       halInternalCalibrateFastRc
     53            #endif//DISABLE_RC_CALIBRATION
     54            
     55            halInternalStartSystemTimer();
   \   00000050   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000054   0x.... 0x....      B.W      halInternalStartSystemTimer
     56            
     57            #ifdef INTERRUPT_DEBUGGING
     58              //When debugging interrupts/ATOMIC, ensure that our
     59              //debug pin is properly enabled and idle low.
     60              I_OUT(I_PORT, I_PIN, I_CFG_HL);
     61              I_CLR(I_PORT, I_PIN);
     62            #endif //INTERRUPT_DEBUGGING
     63            
     64            #ifdef USB_CERT_TESTING
     65            halInternalPowerDownBoard();
     66            #endif
     67          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x8A08             LDRH     R0,[R1, #+16]
   \   00000002   0x6010             STR      R0,[R2, #+0]
   \   00000004   0x8A48             LDRH     R0,[R1, #+18]
   \   00000006   0x6050             STR      R0,[R2, #+4]
   \   00000008   0x8A88             LDRH     R0,[R1, #+20]
   \   0000000A   0x6018             STR      R0,[R3, #+0]
   \   0000000C   0x8AC8             LDRH     R0,[R1, #+22]
   \   0000000E   0x6058             STR      R0,[R3, #+4]
   \   00000010   0x....             B.N      halStackRadioPowerDownBoard

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x....             LDR.N    R0,??DataTable25_1  ;; 0x4000b000
   \   00000002   0x....             LDR.N    R1,??DataTable25_2
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x60C2             STR      R2,[R0, #+12]
   \   00000008   0x....             LDR.N    R2,??DataTable25_3  ;; 0x4000b400
   \   0000000A   0x784B             LDRB     R3,[R1, #+1]
   \   0000000C   0x60D3             STR      R3,[R2, #+12]
   \   0000000E   0x....             LDR.N    R3,??DataTable25_4  ;; 0x4000b800
   \   00000010   0x4770             BX       LR
     68          
     69          

   \                                 In section .text, align 2, keep-with-next
     70          void halReboot(void)
     71          {
     72            halInternalSysReset(RESET_SOFTWARE_REBOOT);
   \                     halReboot:
   \   00000000   0xF240 0x6001      MOVW     R0,#+1537
   \   00000004   0x.... 0x....      B.W      halInternalSysReset
     73          }
     74          

   \                                 In section .text, align 2, keep-with-next
     75          void halPowerDown(void)
     76          {
   \                     halPowerDown:
   \   00000000   0xB510             PUSH     {R4,LR}
     77            halInternalPowerDownUart();
   \   00000002   0x.... 0x....      BL       halInternalPowerDownUart
     78            
     79            halInternalPowerDownBoard();
   \   00000006   0x....             LDR.N    R0,??DataTable25_1  ;; 0x4000b000
   \   00000008   0x....             LDR.N    R1,??DataTable25_2
   \   0000000A   0x790A             LDRB     R2,[R1, #+4]
   \   0000000C   0x60C2             STR      R2,[R0, #+12]
   \   0000000E   0x....             LDR.N    R2,??DataTable25_3  ;; 0x4000b400
   \   00000010   0x794B             LDRB     R3,[R1, #+5]
   \   00000012   0x60D3             STR      R3,[R2, #+12]
   \   00000014   0x....             LDR.N    R3,??DataTable25_4  ;; 0x4000b800
   \   00000016   0x798C             LDRB     R4,[R1, #+6]
   \   00000018   0x60DC             STR      R4,[R3, #+12]
   \   0000001A   0x8B0C             LDRH     R4,[R1, #+24]
   \   0000001C   0x6004             STR      R4,[R0, #+0]
   \   0000001E   0x8B4C             LDRH     R4,[R1, #+26]
   \   00000020   0x6044             STR      R4,[R0, #+4]
   \   00000022   0x8B88             LDRH     R0,[R1, #+28]
   \   00000024   0x6010             STR      R0,[R2, #+0]
   \   00000026   0x8BC8             LDRH     R0,[R1, #+30]
   \   00000028   0x6050             STR      R0,[R2, #+4]
   \   0000002A   0x8C08             LDRH     R0,[R1, #+32]
   \   0000002C   0x6018             STR      R0,[R3, #+0]
   \   0000002E   0x8C48             LDRH     R0,[R1, #+34]
   \   00000030   0x6058             STR      R0,[R3, #+4]
     80          }
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
     81          
     82          // halPowerUp is called from sleep state, not from first initial boot.

   \                                 In section .text, align 2, keep-with-next
     83          void halPowerUp(void)
     84          {
   \                     halPowerUp:
   \   00000000   0xB510             PUSH     {R4,LR}
     85            //[[ Strip emulator only code from official build
     86            #ifdef EMBER_EMU_TEST
     87              //On the emulator, give our fake XTAL reasonable thresholds so the cal
     88              //algorithm ends up at 4.
     89              EMU_OSC24M_CTRL =((0x8<<EMU_OSC24M_CTRL_OSC24M_THRESH_H_BIT) |
     90                                (0x2<<EMU_OSC24M_CTRL_OSC24M_THRESH_L_BIT) |
     91                                (0x0<<EMU_OSC24M_CTRL_OSC24M_THRESH_STOP_BIT));
     92            #endif
     93            //]]
     94          
     95            halInternalPowerUpKickXtal();
   \   00000002   0x.... 0x....      BL       halInternalPowerUpKickXtal
     96          
     97            halCommonCalibratePads();
   \   00000006   0x.... 0x....      BL       halCommonCalibratePads
     98          
     99            halInternalPowerUpBoard();
   \   0000000A   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   0000000E   0x788C             LDRB     R4,[R1, #+2]
   \   00000010   0x60DC             STR      R4,[R3, #+12]
   \   00000012   0x898C             LDRH     R4,[R1, #+12]
   \   00000014   0x6004             STR      R4,[R0, #+0]
   \   00000016   0x89CC             LDRH     R4,[R1, #+14]
   \   00000018   0x6044             STR      R4,[R0, #+4]
   \   0000001A   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_2:
   \   0000001E   0x....             LDR.N    R0,??DataTable25  ;; 0x4000bc00
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000026   0x6001             STR      R1,[R0, #+0]
   \   00000028   0x.... 0x....      BL       halInternalInitAdc
    100          
    101            halInternalBlockUntilXtal();
   \   0000002C   0x.... 0x....      BL       halInternalBlockUntilXtal
    102          
    103            halInternalPowerUpUart();
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x.... 0x....      B.W      halInternalPowerUpUart
    104          }
    105          
    106          
    107          //If the board file defines runtime powerup/powerdown GPIO configuration,
    108          //instantiate the variables and implement halStackRadioPowerDownBoard/
    109          //halStackRadioPowerUpBoard which the stack will use to control the
    110          //power state of radio specific GPIO.  If the board file does not define
    111          //runtime GPIO configuration, the compile time configuration will work as
    112          //it always has.
    113          #if defined(DEFINE_POWERUP_GPIO_CFG_VARIABLES)           && \
    114              defined(DEFINE_POWERUP_GPIO_OUTPUT_DATA_VARIABLES)   && \
    115              defined(DEFINE_POWERDOWN_GPIO_CFG_VARIABLES)         && \
    116              defined(DEFINE_POWERDOWN_GPIO_OUTPUT_DATA_VARIABLES) && \
    117              defined(DEFINE_GPIO_RADIO_POWER_BOARD_MASK_VARIABLE)
    118          
    119          
    120          DEFINE_POWERUP_GPIO_CFG_VARIABLES();
    121          DEFINE_POWERUP_GPIO_OUTPUT_DATA_VARIABLES();
    122          DEFINE_POWERDOWN_GPIO_CFG_VARIABLES();
    123          DEFINE_POWERDOWN_GPIO_OUTPUT_DATA_VARIABLES();
    124          DEFINE_GPIO_RADIO_POWER_BOARD_MASK_VARIABLE();
    125                 
    126          

   \                                 In section .text, align 2, keep-with-next
    127          static void rmwRadioPowerCfgReg(int16u radioPowerCfg[],
    128                                          int32u volatile * cfgReg,
    129                                          int8u cfgVar)
    130          {
   \                     rmwRadioPowerCfgReg:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    131            int32u temp = *cfgReg;
   \   00000002   0x680B             LDR      R3,[R1, #+0]
   \   00000004   0x....             LDR.N    R4,??DataTable25_2
   \   00000006   0x6A64             LDR      R4,[R4, #+36]
   \   00000008   0x250F             MOVS     R5,#+15
   \   0000000A   0x0096             LSLS     R6,R2,#+2
   \   0000000C   0xFA05 0xF606      LSL      R6,R5,R6
   \   00000010   0x4234             TST      R4,R6
   \   00000012   0xD012             BEQ.N    ??rmwRadioPowerCfgReg_0
    132            int8u i;
    133            
    134            //don't waste time with a register that doesn't have anything to be done
    135            if(gpioRadioPowerBoardMask&(0xF<<(4*cfgVar))) {
    136              //loop over the 4 pins of the cfgReg
    137              for(i=0; i<4; i++) {
   \   00000014   0x2600             MOVS     R6,#+0
    138                if((gpioRadioPowerBoardMask>>((4*cfgVar)+i))&1) {
   \                     ??rmwRadioPowerCfgReg_1:
   \   00000016   0xEB06 0x0782      ADD      R7,R6,R2, LSL #+2
   \   0000001A   0xFA24 0xF707      LSR      R7,R4,R7
   \   0000001E   0x07FF             LSLS     R7,R7,#+31
   \   00000020   0xD508             BPL.N    ??rmwRadioPowerCfgReg_2
    139                  //read-modify-write the pin's cfg if the mask says it pertains
    140                  //to the radio's power state
    141                  temp &= ~(0xF<<(4*i));
    142                  temp |= (radioPowerCfg[cfgVar]&(0xF<<(4*i)));
   \   00000022   0x00B7             LSLS     R7,R6,#+2
   \   00000024   0xFA05 0xF707      LSL      R7,R5,R7
   \   00000028   0x43BB             BICS     R3,R3,R7
   \   0000002A   0xF830 0xC012      LDRH     R12,[R0, R2, LSL #+1]
   \   0000002E   0xEA07 0x070C      AND      R7,R7,R12
   \   00000032   0x433B             ORRS     R3,R7,R3
    143                }
    144              }
   \                     ??rmwRadioPowerCfgReg_2:
   \   00000034   0x1C76             ADDS     R6,R6,#+1
   \   00000036   0x2E04             CMP      R6,#+4
   \   00000038   0xDBED             BLT.N    ??rmwRadioPowerCfgReg_1
    145            }
    146            
    147            *cfgReg = temp;
   \                     ??rmwRadioPowerCfgReg_0:
   \   0000003A   0x600B             STR      R3,[R1, #+0]
    148          }
   \   0000003C   0xBDF0             POP      {R4-R7,PC}       ;; return
    149          
    150          

   \                                 In section .text, align 2, keep-with-next
    151          static void rmwRadioPowerOutReg(int8u radioPowerOut[],
    152                                          int32u volatile * outReg,
    153                                          int8u outVar)
    154          {
   \                     rmwRadioPowerOutReg:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    155            int32u temp = *outReg;
   \   00000002   0x680B             LDR      R3,[R1, #+0]
   \   00000004   0x....             LDR.N    R4,??DataTable25_2
   \   00000006   0x6A64             LDR      R4,[R4, #+36]
   \   00000008   0x25FF             MOVS     R5,#+255
   \   0000000A   0x00D6             LSLS     R6,R2,#+3
   \   0000000C   0x40B5             LSLS     R5,R5,R6
   \   0000000E   0x422C             TST      R4,R5
   \   00000010   0xD00F             BEQ.N    ??rmwRadioPowerOutReg_0
    156            int8u i;
    157            
    158            //don't waste time with a register that doesn't have anything to be done
    159            if(gpioRadioPowerBoardMask&(0xFF<<(8*outVar))) {
    160              //loop over the 8 pins of the outReg
    161              for(i=0; i<8; i++) {
   \   00000012   0x2500             MOVS     R5,#+0
    162                if((gpioRadioPowerBoardMask>>((8*outVar)+i))&1) {
   \                     ??rmwRadioPowerOutReg_1:
   \   00000014   0xEB05 0x06C2      ADD      R6,R5,R2, LSL #+3
   \   00000018   0xFA24 0xF606      LSR      R6,R4,R6
   \   0000001C   0x07F6             LSLS     R6,R6,#+31
   \   0000001E   0xD505             BPL.N    ??rmwRadioPowerOutReg_2
    163                  //read-modify-write the pin's out if the mask says it pertains
    164                  //to the radio's power state
    165                  temp &= ~(0x1<<(1*i));
    166                  temp |= (radioPowerOut[outVar]&(0x1<<(1*i)));
   \   00000020   0x2601             MOVS     R6,#+1
   \   00000022   0x40AE             LSLS     R6,R6,R5
   \   00000024   0x43B3             BICS     R3,R3,R6
   \   00000026   0x5C17             LDRB     R7,[R2, R0]
   \   00000028   0x403E             ANDS     R6,R6,R7
   \   0000002A   0x4333             ORRS     R3,R6,R3
    167                }
    168              }
   \                     ??rmwRadioPowerOutReg_2:
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   \   0000002E   0x2D08             CMP      R5,#+8
   \   00000030   0xDBF0             BLT.N    ??rmwRadioPowerOutReg_1
    169            }
    170            
    171            *outReg = temp;
   \                     ??rmwRadioPowerOutReg_0:
   \   00000032   0x600B             STR      R3,[R1, #+0]
    172          }
   \   00000034   0xBDF0             POP      {R4-R7,PC}       ;; return
    173          
    174          

   \                                 In section .text, align 2, keep-with-next
    175          void halStackRadioPowerDownBoard(void)
    176          {
   \                     halStackRadioPowerDownBoard:
   \   00000000   0xB510             PUSH     {R4,LR}
    177            if(gpioRadioPowerBoardMask == 0) {
   \   00000002   0x....             LDR.N    R4,??DataTable25_2
   \   00000004   0x6A60             LDR      R0,[R4, #+36]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD027             BEQ.N    ??halStackRadioPowerDownBoard_0
    178              //If the mask indicates there are no special GPIOs for the
    179              //radio that need their power state to be conrolled by the stack,
    180              //don't bother attempting to do anything.
    181              return;
    182            }
    183            
    184            rmwRadioPowerOutReg(gpioOutPowerDown, &GPIO_PAOUT, 0);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x....             LDR.N    R1,??DataTable25_5  ;; 0x4000b00c
   \   0000000E   0x1D20             ADDS     R0,R4,#+4
   \   00000010   0x.... 0x....      BL       rmwRadioPowerOutReg
    185            rmwRadioPowerOutReg(gpioOutPowerDown, &GPIO_PBOUT, 1);
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable25_6  ;; 0x4000b40c
   \   00000018   0x1D20             ADDS     R0,R4,#+4
   \   0000001A   0x.... 0x....      BL       rmwRadioPowerOutReg
    186            rmwRadioPowerOutReg(gpioOutPowerDown, &GPIO_PCOUT, 2);
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0x....             LDR.N    R1,??DataTable25_7  ;; 0x4000b80c
   \   00000022   0x1D20             ADDS     R0,R4,#+4
   \   00000024   0x.... 0x....      BL       rmwRadioPowerOutReg
    187            
    188            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PACFGL, 0);
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x....             LDR.N    R1,??DataTable25_1  ;; 0x4000b000
   \   0000002C   0x.... 0x....      BL       ?Subroutine3
    189            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PACFGH, 1);
   \                     ??CrossCallReturnLabel_8:
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x....             LDR.N    R1,??DataTable25_8  ;; 0x4000b004
   \   00000034   0x.... 0x....      BL       ?Subroutine3
    190            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PBCFGL, 2);
   \                     ??CrossCallReturnLabel_7:
   \   00000038   0x2202             MOVS     R2,#+2
   \   0000003A   0x....             LDR.N    R1,??DataTable25_3  ;; 0x4000b400
   \   0000003C   0x.... 0x....      BL       ?Subroutine3
    191            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PBCFGH, 3);
   \                     ??CrossCallReturnLabel_6:
   \   00000040   0x2203             MOVS     R2,#+3
   \   00000042   0x....             LDR.N    R1,??DataTable25_9  ;; 0x4000b404
   \   00000044   0x.... 0x....      BL       ?Subroutine3
    192            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PCCFGL, 4);
   \                     ??CrossCallReturnLabel_5:
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0x....             LDR.N    R1,??DataTable25_4  ;; 0x4000b800
   \   0000004C   0x.... 0x....      BL       ?Subroutine3
    193            rmwRadioPowerCfgReg(gpioCfgPowerDown, &GPIO_PCCFGH, 5);
   \                     ??CrossCallReturnLabel_4:
   \   00000050   0x2205             MOVS     R2,#+5
   \   00000052   0x....             LDR.N    R1,??DataTable25_10  ;; 0x4000b804
   \   00000054   0xF104 0x0018      ADD      R0,R4,#+24
   \   00000058   0x....             B.N      ?Subroutine0
   \                     ??halStackRadioPowerDownBoard_0:
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    194          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0xF104 0x0018      ADD      R0,R4,#+24
   \   00000004   0x....             B.N      rmwRadioPowerCfgReg

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE8BD 0x4010      POP      {R4,LR}
   \   00000004   0x....             B.N      rmwRadioPowerCfgReg
    195          
    196          

   \                                 In section .text, align 2, keep-with-next
    197          void halStackRadioPowerUpBoard(void)
    198          {
   \                     halStackRadioPowerUpBoard:
   \   00000000   0xB510             PUSH     {R4,LR}
    199            if(gpioRadioPowerBoardMask == 0) {
   \   00000002   0x....             LDR.N    R4,??DataTable25_2
   \   00000004   0x6A60             LDR      R0,[R4, #+36]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD027             BEQ.N    ??halStackRadioPowerUpBoard_0
    200              //If the mask indicates there are no special GPIOs for the
    201              //radio that need their power state to be conrolled by the stack,
    202              //don't bother attempting to do anything.
    203              return;
    204            }
    205            
    206            rmwRadioPowerOutReg(gpioOutPowerUp, &GPIO_PAOUT, 0);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x....             LDR.N    R1,??DataTable25_5  ;; 0x4000b00c
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       rmwRadioPowerOutReg
    207            rmwRadioPowerOutReg(gpioOutPowerUp, &GPIO_PBOUT, 1);
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable25_6  ;; 0x4000b40c
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       rmwRadioPowerOutReg
    208            rmwRadioPowerOutReg(gpioOutPowerUp, &GPIO_PCOUT, 2);
   \   0000001E   0x2202             MOVS     R2,#+2
   \   00000020   0x....             LDR.N    R1,??DataTable25_7  ;; 0x4000b80c
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       rmwRadioPowerOutReg
    209            
    210            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PACFGL, 0);
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x....             LDR.N    R1,??DataTable25_1  ;; 0x4000b000
   \   0000002C   0x.... 0x....      BL       ?Subroutine4
    211            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PACFGH, 1);
   \                     ??CrossCallReturnLabel_13:
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x....             LDR.N    R1,??DataTable25_8  ;; 0x4000b004
   \   00000034   0x.... 0x....      BL       ?Subroutine4
    212            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PBCFGL, 2);
   \                     ??CrossCallReturnLabel_12:
   \   00000038   0x2202             MOVS     R2,#+2
   \   0000003A   0x....             LDR.N    R1,??DataTable25_3  ;; 0x4000b400
   \   0000003C   0x.... 0x....      BL       ?Subroutine4
    213            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PBCFGH, 3);
   \                     ??CrossCallReturnLabel_11:
   \   00000040   0x2203             MOVS     R2,#+3
   \   00000042   0x....             LDR.N    R1,??DataTable25_9  ;; 0x4000b404
   \   00000044   0x.... 0x....      BL       ?Subroutine4
    214            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PCCFGL, 4);
   \                     ??CrossCallReturnLabel_10:
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0x....             LDR.N    R1,??DataTable25_4  ;; 0x4000b800
   \   0000004C   0x.... 0x....      BL       ?Subroutine4
    215            rmwRadioPowerCfgReg(gpioCfgPowerUp, &GPIO_PCCFGH, 5);
   \                     ??CrossCallReturnLabel_9:
   \   00000050   0x2205             MOVS     R2,#+5
   \   00000052   0x....             LDR.N    R1,??DataTable25_10  ;; 0x4000b804
   \   00000054   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000058   0x....             B.N      ?Subroutine0
   \                     ??halStackRadioPowerUpBoard_0:
   \   0000005A   0xBD10             POP      {R4,PC}          ;; return
    216          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000004   0x....             B.N      rmwRadioPowerCfgReg
    217          
    218          #else
    219          
    220          //If the board file uses traditional compile time powerup/powerdown GPIO
    221          //configuration, stub halStackRadioPowerDownBoard/halStackRadioPowerUpBoard
    222          //which the stack would have used to control the power state of radio
    223          //relevant GPIO.  With compile time configuration, only the traditional
    224          //halInternalPowerDownBoard and halInternalPowerUpBoard funtions configure
    225          //the GPIO.
    226          
    227          void halStackRadioPowerDownBoard(void) {}
    228          void halStackRadioPowerUpBoard(void) {}
    229          
    230          #endif
    231          

   \                                 In section .text, align 2, keep-with-next
    232          void halStackProcessBootCount(void)
    233          {
    234            //Note: Becuase this always counts up at every boot (called from emberInit),
    235            //and non-volatile storage has a finite number of write cycles, this will
    236            //eventually stop working.  Disable this token call if non-volatile write
    237            //cycles need to be used sparingly.
    238            halCommonIncrementCounterToken(TOKEN_STACK_BOOT_COUNTER);
   \                     halStackProcessBootCount:
   \   00000000   0x2003             MOVS     R0,#+3
   \   00000002   0x.... 0x....      B.W      halInternalIncrementCounterToken
    239          }
    240          
    241          

   \                                 In section .text, align 2, keep-with-next
    242          PGM_P halGetResetString(void)
    243          {
   \                     halGetResetString:
   \   00000000   0xB580             PUSH     {R7,LR}
    244            // Table used to convert from reset types to reset strings.
    245            #define RESET_BASE_DEF(basename, value, string)  string,
    246            #define RESET_EXT_DEF(basename, extname, extvalue, string)  /*nothing*/
    247            static PGM char resetStringTable[][4] = {
    248              #include "reset-def.h"
    249            };
    250            #undef RESET_BASE_DEF
    251            #undef RESET_EXT_DEF
    252          
    253            return resetStringTable[halGetResetInfo()];
   \   00000002   0x.... 0x....      BL       halGetResetInfo
   \   00000006   0x.... 0x....      ADR.W    R1,??resetStringTable
   \   0000000A   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    254          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??resetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x46 0x49          DC8 "FIB"
   \              0x42 0x00    
   \   00000008   0x42 0x54          DC8 "BTL"
   \              0x4C 0x00    
   \   0000000C   0x45 0x58          DC8 "EXT"
   \              0x54 0x00    
   \   00000010   0x50 0x57          DC8 "PWR"
   \              0x52 0x00    
   \   00000014   0x57 0x44          DC8 "WDG"
   \              0x47 0x00    
   \   00000018   0x20 0x53          DC8 " SW"
   \              0x57 0x00    
   \   0000001C   0x43 0x52          DC8 "CRS"
   \              0x53 0x00    
   \   00000020   0x46 0x53          DC8 "FSH"
   \              0x48 0x00    
   \   00000024   0x42 0x41          DC8 "BAD"
   \              0x44 0x00    
   \   00000028   0x46 0x4C          DC8 "FLT"
   \              0x54 0x00    
    255          
    256          // Note that this API should be used in conjunction with halGetResetString
    257          //  to get the full information, as this API does not provide a string for
    258          //  the base reset type

   \                                 In section .text, align 2, keep-with-next
    259          PGM_P halGetExtendedResetString(void)
    260          {
   \                     halGetExtendedResetString:
   \   00000000   0xB580             PUSH     {R7,LR}
    261            // Create a table of reset strings for each extended reset type
    262            typedef PGM char ResetStringTableType[][4];
    263            #define RESET_BASE_DEF(basename, value, string)   \
    264                                   }; static ResetStringTableType basename##ResetStringTable = {
    265            #define RESET_EXT_DEF(basename, extname, extvalue, string)  string,
    266            {
    267              #include "reset-def.h"
    268            };
    269            #undef RESET_BASE_DEF
    270            #undef RESET_EXT_DEF
    271            
    272            // Create a table of pointers to each of the above tables
    273            #define RESET_BASE_DEF(basename, value, string)  (ResetStringTableType *)basename##ResetStringTable,
    274            #define RESET_EXT_DEF(basename, extname, extvalue, string)  /*nothing*/
    275            static ResetStringTableType * PGM extendedResetStringTablePtrs[] = {
    276              #include "reset-def.h"
    277            };
    278            #undef RESET_BASE_DEF
    279            #undef RESET_EXT_DEF
    280          
    281            int16u extResetInfo = halGetExtendedResetInfo();
   \   00000002   0x.... 0x....      BL       halGetExtendedResetInfo
    282            // access the particular table of extended strings we are interested in
    283            ResetStringTableType *extendedResetStringTable = 
    284                              extendedResetStringTablePtrs[RESET_BASE_TYPE(extResetInfo)];
    285          
    286            // return the string from within the proper table
    287            return (*extendedResetStringTable)[((extResetInfo)&0xFF)];
   \   00000006   0xB2C1             UXTB     R1,R0
   \   00000008   0x0400             LSLS     R0,R0,#+16
   \   0000000A   0x0E00             LSRS     R0,R0,#+24
   \   0000000C   0x.... 0x....      ADR.W    R2,??extendedResetStringTablePtrs
   \   00000010   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000014   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000018   0xBD02             POP      {R1,PC}          ;; return
    288            
    289          }

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::UNKNOWNResetStringTable[1][4]
   \                     ??UNKNOWNResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::FIBResetStringTable[22][4]
   \                     ??FIBResetStringTable:
   \   00000000   0x47 0x4F          DC8 "GO "
   \              0x20 0x00    
   \   00000004   0x42 0x54          DC8 "BTL"
   \              0x4C 0x00    
   \   00000008   0x47 0x4F          DC8 "GO2"
   \              0x32 0x00    
   \   0000000C   0x47 0x4F          DC8 "GO3"
   \              0x33 0x00    
   \   00000010   0x47 0x4F          DC8 "GO4"
   \              0x34 0x00    
   \   00000014   0x47 0x4F          DC8 "GO5"
   \              0x35 0x00    
   \   00000018   0x47 0x4F          DC8 "GO6"
   \              0x36 0x00    
   \   0000001C   0x47 0x4F          DC8 "GO7"
   \              0x37 0x00    
   \   00000020   0x47 0x4F          DC8 "GO8"
   \              0x38 0x00    
   \   00000024   0x47 0x4F          DC8 "GO9"
   \              0x39 0x00    
   \   00000028   0x47 0x4F          DC8 "GOA"
   \              0x41 0x00    
   \   0000002C   0x47 0x4F          DC8 "GOB"
   \              0x42 0x00    
   \   00000030   0x47 0x4F          DC8 "GOC"
   \              0x43 0x00    
   \   00000034   0x47 0x4F          DC8 "GOD"
   \              0x44 0x00    
   \   00000038   0x47 0x4F          DC8 "GOE"
   \              0x45 0x00    
   \   0000003C   0x47 0x4F          DC8 "GOF"
   \              0x46 0x00    
   \   00000040   0x4A 0x4D          DC8 "JMP"
   \              0x50 0x00    
   \   00000044   0x42 0x44          DC8 "BDR"
   \              0x52 0x00    
   \   00000048   0x55 0x50          DC8 "UPR"
   \              0x52 0x00    
   \   0000004C   0x42 0x54          DC8 "BTM"
   \              0x4D 0x00    
   \   00000050   0x4D 0x53          DC8 "MSM"
   \              0x4D 0x00    
   \   00000054   0x46 0x54          DC8 "FTL"
   \              0x4C 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::BOOTLOADERResetStringTable[8][4]
   \                     ??BOOTLOADERResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x47 0x4F          DC8 "GO "
   \              0x20 0x00    
   \   00000008   0x42 0x54          DC8 "BTL"
   \              0x4C 0x00    
   \   0000000C   0x42 0x41          DC8 "BAD"
   \              0x44 0x00    
   \   00000010   0x46 0x54          DC8 "FTL"
   \              0x4C 0x00    
   \   00000014   0x46 0x52          DC8 "FRC"
   \              0x43 0x00    
   \   00000018   0x4F 0x54          DC8 "OTA"
   \              0x41 0x00    
   \   0000001C   0x44 0x53          DC8 "DSL"
   \              0x4C 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::EXTERNALResetStringTable[2][4]
   \                     ??EXTERNALResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x50 0x49          DC8 "PIN"
   \              0x4E 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::POWERONResetStringTable[3][4]
   \                     ??POWERONResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x48 0x56          DC8 "HV "
   \              0x20 0x00    
   \   00000008   0x4C 0x56          DC8 "LV "
   \              0x20 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::WATCHDOGResetStringTable[3][4]
   \                     ??WATCHDOGResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x45 0x58          DC8 "EXP"
   \              0x50 0x00    
   \   00000008   0x4C 0x57          DC8 "LWM"
   \              0x4D 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::SOFTWAREResetStringTable[3][4]
   \                     ??SOFTWAREResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x52 0x42          DC8 "RBT"
   \              0x54 0x00    
   \   00000008   0x44 0x53          DC8 "DSL"
   \              0x4C 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::CRASHResetStringTable[2][4]
   \                     ??CRASHResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x41 0x53          DC8 "AST"
   \              0x54 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::FLASHResetStringTable[3][4]
   \                     ??FLASHResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x56 0x46          DC8 "VFY"
   \              0x59 0x00    
   \   00000008   0x49 0x4E          DC8 "INH"
   \              0x48 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::FATALResetStringTable[4][4]
   \                     ??FATALResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x4C 0x43          DC8 "LCK"
   \              0x4B 0x00    
   \   00000008   0x58 0x54          DC8 "XTL"
   \              0x4C 0x00    
   \   0000000C   0x4F 0x42          DC8 "OBF"
   \              0x46 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute char const halGetExtendedResetString::FAULTResetStringTable[8][4]
   \                     ??FAULTResetStringTable:
   \   00000000   0x55 0x4E          DC8 "UNK"
   \              0x4B 0x00    
   \   00000004   0x48 0x52          DC8 "HRD"
   \              0x44 0x00    
   \   00000008   0x4D 0x45          DC8 "MEM"
   \              0x4D 0x00    
   \   0000000C   0x42 0x55          DC8 "BUS"
   \              0x53 0x00    
   \   00000010   0x55 0x53          DC8 "USG"
   \              0x47 0x00    
   \   00000014   0x44 0x42          DC8 "DBG"
   \              0x47 0x00    
   \   00000018   0x44 0x4D          DC8 "DMA"
   \              0x41 0x00    
   \   0000001C   0x56 0x43          DC8 "VCT"
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??extendedResetStringTablePtrs:
   \   00000000   0x........         DC32 ??UNKNOWNResetStringTable, ??FIBResetStringTable
   \              0x........   
   \   00000008   0x........         DC32 ??BOOTLOADERResetStringTable, ??EXTERNALResetStringTable
   \              0x........   
   \   00000010   0x........         DC32 ??POWERONResetStringTable, ??WATCHDOGResetStringTable
   \              0x........   
   \   00000018   0x........         DC32 ??SOFTWAREResetStringTable, ??CRASHResetStringTable
   \              0x........   
   \   00000020   0x........         DC32 ??FLASHResetStringTable, ??FATALResetStringTable
   \              0x........   
   \   00000028   0x........         DC32 ??FAULTResetStringTable
    290          
    291          // Translate EM3xx reset codes to the codes previously used by the EM2xx.
    292          // If there is no corresponding code, return the EM3xx base code with bit 7 set.

   \                                 In section .text, align 4, keep-with-next
    293          int8u halGetEm2xxResetInfo(void)
    294          {
   \                     halGetEm2xxResetInfo:
   \   00000000   0xB510             PUSH     {R4,LR}
    295            int8u reset = halGetResetInfo();
   \   00000002   0x.... 0x....      BL       halGetResetInfo
   \   00000006   0x4604             MOV      R4,R0
    296          
    297            // Any reset with an extended value field of zero is considered an unknown
    298            // reset, except for FIB resets.
    299            if ( (RESET_EXTENDED_FIELD(halGetExtendedResetInfo()) == 0) && 
    300                 (reset != RESET_FIB) ) {
   \   00000008   0x.... 0x....      BL       halGetExtendedResetInfo
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0xB908             CBNZ.N   R0,??halGetEm2xxResetInfo_1
   \   00000010   0x2C01             CMP      R4,#+1
   \   00000012   0xD107             BNE.N    ??halGetEm2xxResetInfo_2
    301               return EM2XX_RESET_UNKNOWN;
    302            }
    303          
    304           switch (reset) {
   \                     ??halGetEm2xxResetInfo_1:
   \   00000014   0x2C07             CMP      R4,#+7
   \   00000016   0xD811             BHI.N    ??halGetEm2xxResetInfo_3
   \   00000018   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??halGetEm2xxResetInfo_0:
   \   0000001C   0x04 0x10          DC8      0x4,0x10,0x6,0x8
   \              0x06 0x08    
   \   00000020   0x08 0x0A          DC8      0x8,0xA,0xC,0xE
   \              0x0C 0x0E    
    305            case RESET_UNKNOWN:
    306              return EM2XX_RESET_UNKNOWN;
   \                     ??halGetEm2xxResetInfo_2:
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD10             POP      {R4,PC}
    307            case RESET_BOOTLOADER:
    308              return EM2XX_RESET_BOOTLOADER;
   \                     ??halGetEm2xxResetInfo_4:
   \   00000028   0x2009             MOVS     R0,#+9
   \   0000002A   0xBD10             POP      {R4,PC}
    309            case RESET_EXTERNAL:      // map pin resets to poweron for EM2xx compatibility
    310          //    return EM2XX_RESET_EXTERNAL;  
    311            case RESET_POWERON:
    312              return EM2XX_RESET_POWERON;
   \                     ??halGetEm2xxResetInfo_5:
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xBD10             POP      {R4,PC}
    313            case RESET_WATCHDOG:
    314              return EM2XX_RESET_WATCHDOG;
   \                     ??halGetEm2xxResetInfo_6:
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0xBD10             POP      {R4,PC}
    315            case RESET_SOFTWARE:
    316              return EM2XX_RESET_SOFTWARE;
   \                     ??halGetEm2xxResetInfo_7:
   \   00000034   0x200B             MOVS     R0,#+11
   \   00000036   0xBD10             POP      {R4,PC}
    317            case RESET_CRASH:
    318              return EM2XX_RESET_ASSERT;
   \                     ??halGetEm2xxResetInfo_8:
   \   00000038   0x2006             MOVS     R0,#+6
   \   0000003A   0xBD10             POP      {R4,PC}
    319            default:
    320              return (reset | 0x80);      // set B7 for all other reset codes
   \                     ??halGetEm2xxResetInfo_3:
   \   0000003C   0xF044 0x0080      ORR      R0,R4,#0x80
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    321            }
    322          }
    323          
    324          static boolean rhoActive;
    325          

   \                                 In section .text, align 2, keep-with-next
    326          boolean halRadioHoldOffIsActive(void)
    327          {
    328            return rhoActive;
   \                     halRadioHoldOffIsActive:
   \   00000000   0x....             LDR.N    R0,??DataTable25_2
   \   00000002   0x7A00             LDRB     R0,[R0, #+8]
   \   00000004   0x4770             BX       LR               ;; return
    329          }

   \                                 In section .data, align 4
   \                     gpioOutPowerUp:
   \   00000000   0xE8 0x4F          DC8 232, 79, 228, 0
   \              0xE4 0x00    
   \                     gpioOutPowerDown:
   \   00000004   0xEF 0x56          DC8 239, 86, 101, 0
   \              0x65 0x00    
   \   00000008   0x00               DC8 0
    330          
    331          #ifdef  RHO_GPIO // BOARD_HEADER supports Radio HoldOff
    332          int8u WAKE_ON_LED_RHO_VAR = WAKE_ON_LED_RHO;
   \                     halInternalWakeOnLedOrRho:
   \   00000009   0x00               DC8 0
   \   0000000A   0x00               DC8 0
   \   0000000B   0x00               DC8 0
   \                     gpioCfgPowerUp:
   \   0000000C   0x1949 0x1199      DC16 6473, 4505, 34961, 38921, 18708, 6164
   \              0x8891 0x9809
   \              0x4914 0x1814
   \                     gpioCfgPowerDown:
   \   00000018   0x1888 0x1188      DC16 6280, 4488, 34833, 34945, 33048, 6168
   \              0x8811 0x8881
   \              0x8118 0x1818
   \                     gpioRadioPowerBoardMask:
   \   00000024   0x00000000         DC32 0
    333          
    334          extern void emRadioHoldOffIsr(boolean active);
    335          
    336          static boolean rhoEnabled;
    337          

   \                                 In section .text, align 2, keep-with-next
    338          boolean halGetRadioHoldOff(void)
    339          {
    340            return rhoEnabled;
   \                     halGetRadioHoldOff:
   \   00000000   0x....             LDR.N    R0,??DataTable25_2
   \   00000002   0x7A80             LDRB     R0,[R0, #+10]
   \   00000004   0x4770             BX       LR               ;; return
    341          }
    342          
    343          // Return active state of Radio HoldOff GPIO pin

   \                                 In section .text, align 2, keep-with-next
    344          boolean halInternalRhoPinIsActive(void)
    345          {
    346            return (!!(RHO_IN & BIT(RHO_GPIO&7)) == !!RHO_ASSERTED);
   \                     halInternalRhoPinIsActive:
   \   00000000   0x....             LDR.N    R0,??DataTable25_11  ;; 0x4000b008
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0980             LSRS     R0,R0,#+6
   \   00000006   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000000A   0x4770             BX       LR               ;; return
    347          }
    348          

   \                                 In section .text, align 2, keep-with-next
    349          void RHO_ISR(void)
    350          {
    351            boolean rhoStateNow;
    352          
    353            //clear int before read to avoid potential of missing interrupt
    354            INT_MISS = RHO_MISS_BIT;     //clear missed RHO interrupt flag
   \                     halIrqDIsr:
   \   00000000   0x....             LDR.N    R0,??DataTable25_12  ;; 0x4000a814
   \   00000002   0xF44F 0x4100      MOV      R1,#+32768
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    355            INT_GPIOFLAG = RHO_FLAG_BIT; //clear top level RHO interrupt flag
   \   00000008   0x2108             MOVS     R1,#+8
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    356          
    357            if (rhoEnabled) { //Ignore if not enabled
   \   0000000C   0x....             LDR.N    R1,??DataTable25_2
   \   0000000E   0x7A88             LDRB     R0,[R1, #+10]
   \   00000010   0xB150             CBZ.N    R0,??halIrqDIsr_0
    358              rhoStateNow = halInternalRhoPinIsActive();
   \   00000012   0x....             LDR.N    R0,??DataTable25_11  ;; 0x4000b008
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0980             LSRS     R0,R0,#+6
   \   00000018   0xF000 0x0001      AND      R0,R0,#0x1
    359              if (rhoActive != rhoStateNow) {
   \   0000001C   0x7A0B             LDRB     R3,[R1, #+8]
   \   0000001E   0x4283             CMP      R3,R0
   \   00000020   0xBF1C             ITT      NE 
   \   00000022   0x7208             STRBNE   R0,[R1, #+8]
   \   00000024   0x.... 0x....      BNE.W    emRadioHoldOffIsr
    360                //state changed
    361                rhoActive = rhoStateNow;
    362                emRadioHoldOffIsr(rhoActive); //Notify Radio land of state change
    363              } else {
    364                //state unchanged -- probably a glitch or too quick to matter
    365              }
    366            }
    367          }
   \                     ??halIrqDIsr_0:
   \   00000028   0x4770             BX       LR               ;; return
    368          

   \                                 In section .text, align 2, keep-with-next
    369          void halSetRadioHoldOff(boolean enabled)
    370          {
   \                     halSetRadioHoldOff:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    371            rhoEnabled = enabled;
   \   00000006   0x....             LDR.N    R5,??DataTable25_2
   \   00000008   0x72AC             STRB     R4,[R5, #+10]
    372          
    373            //start from a fresh state just in case
    374            RHO_INTCFG = 0;              //disable RHO triggering
   \   0000000A   0x....             LDR.N    R7,??DataTable25_12  ;; 0x4000a814
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x65B8             STR      R0,[R7, #+88]
    375            INT_CFGCLR = RHO_INT_EN_BIT; //clear RHO top level int enable
   \   00000010   0xF44F 0x4800      MOV      R8,#+32768
   \   00000014   0x....             LDR.N    R0,??DataTable25_13  ;; 0xe000e180
   \   00000016   0xF8C0 0x8000      STR      R8,[R0, #+0]
    376            INT_GPIOFLAG = RHO_FLAG_BIT; //clear stale RHO interrupt
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0x6038             STR      R0,[R7, #+0]
    377            INT_MISS = RHO_MISS_BIT;     //clear stale missed RHO interrupt
   \   0000001E   0xF8C7 0x800C      STR      R8,[R7, #+12]
    378          
    379            // Reconfigure GPIOs for desired state
    380            ADJUST_GPIO_CONFIG_LED_RHO(enabled);
   \   00000022   0x.... 0x....      BL       _disableBasePri
   \   00000026   0x....             LDR.N    R6,??DataTable25_8  ;; 0x4000b004
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0x6831             LDR      R1,[R6, #+0]
   \   0000002C   0xF421 0x6170      BIC      R1,R1,#0xF00
   \   00000030   0xD014             BEQ.N    ??halSetRadioHoldOff_0
   \   00000032   0xF441 0x6100      ORR      R1,R1,#0x800
   \   00000036   0x6031             STR      R1,[R6, #+0]
   \   00000038   0x68B1             LDR      R1,[R6, #+8]
   \   0000003A   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000003E   0x60B1             STR      R1,[R6, #+8]
   \   00000040   0x2108             MOVS     R1,#+8
   \   00000042   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_14:
   \   00000046   0xF001 0x01BF      AND      R1,R1,#0xBF
   \   0000004A   0x7029             STRB     R1,[R5, #+0]
   \   0000004C   0x2108             MOVS     R1,#+8
   \   0000004E   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_16:
   \   00000052   0xF001 0x01BF      AND      R1,R1,#0xBF
   \   00000056   0x7129             STRB     R1,[R5, #+4]
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0xE013             B.N      ??halSetRadioHoldOff_1
   \                     ??halSetRadioHoldOff_0:
   \   0000005C   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000060   0x6031             STR      R1,[R6, #+0]
   \   00000062   0x68B1             LDR      R1,[R6, #+8]
   \   00000064   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000068   0x60B1             STR      R1,[R6, #+8]
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_15:
   \   00000070   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000074   0x7029             STRB     R1,[R5, #+0]
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_17:
   \   0000007C   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000080   0x7129             STRB     R1,[R5, #+4]
   \   00000082   0x2100             MOVS     R1,#+0
   \                     ??halSetRadioHoldOff_1:
   \   00000084   0x7269             STRB     R1,[R5, #+9]
   \   00000086   0x.... 0x....      BL       _writeBasePri
    381          
    382            if (enabled) {
   \   0000008A   0xB14C             CBZ.N    R4,??halSetRadioHoldOff_2
    383              RHO_SEL();                   //point IRQ at the desired pin
   \   0000008C   0x....             LDR.N    R0,??DataTable25_14  ;; 0x4000bc18
   \   0000008E   0x2106             MOVS     R1,#+6
   \   00000090   0x6001             STR      R1,[R0, #+0]
    384              RHO_INTCFG  = (0 << GPIO_INTFILT_BIT)    //0 = no filter
    385                            | (3 << GPIO_INTMOD_BIT);  //3 = both edges
   \   00000092   0x2060             MOVS     R0,#+96
   \   00000094   0x65B8             STR      R0,[R7, #+88]
    386              rhoActive = halInternalRhoPinIsActive();//grab state before enable int
   \   00000096   0x6870             LDR      R0,[R6, #+4]
    387            } else {
   \   00000098   0x0980             LSRS     R0,R0,#+6
   \   0000009A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000009E   0xE001             B.N      ??halSetRadioHoldOff_3
    388              // No need to change the IRQ selector
    389              RHO_INTCFG  = (0 << GPIO_INTFILT_BIT)    //0 = no filter
    390                            | (0 << GPIO_INTMOD_BIT);  //0 = disabled
   \                     ??halSetRadioHoldOff_2:
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x65B8             STR      R0,[R7, #+88]
    391              rhoActive = FALSE; // Force state off when disabling
   \                     ??halSetRadioHoldOff_3:
   \   000000A4   0x7228             STRB     R0,[R5, #+8]
    392            }
    393          
    394            emRadioHoldOffIsr(rhoActive); //Notify Radio land of configured state
   \   000000A6   0x7A28             LDRB     R0,[R5, #+8]
   \   000000A8   0x.... 0x....      BL       emRadioHoldOffIsr
    395          
    396            if (enabled) {
   \   000000AC   0xB114             CBZ.N    R4,??halSetRadioHoldOff_4
    397              INT_CFGSET = RHO_INT_EN_BIT; //set top level interrupt enable
   \   000000AE   0x....             LDR.N    R0,??DataTable25_15  ;; 0xe000e100
   \   000000B0   0xF8C0 0x8000      STR      R8,[R0, #+0]
    398              // Interrupt on now, ISR will maintain rhoActive
    399            } else {
    400              // Interrupt already disabled above, leave it off
    401            }
    402          }
   \                     ??halSetRadioHoldOff_4:
   \   000000B4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0x8B6A             LDRH     R2,[R5, #+26]
   \   00000002   0xF361 0x220B      BFI      R2,R1,#+8,#+4
   \   00000006   0x836A             STRH     R2,[R5, #+26]
   \   00000008   0x7929             LDRB     R1,[R5, #+4]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   0x89EA             LDRH     R2,[R5, #+14]
   \   00000002   0xF361 0x220B      BFI      R2,R1,#+8,#+4
   \   00000006   0x81EA             STRH     R2,[R5, #+14]
   \   00000008   0x7829             LDRB     R1,[R5, #+0]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x4000BC00         DC32     0x4000bc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x4000B000         DC32     0x4000b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x........         DC32     gpioOutPowerUp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x4000B400         DC32     0x4000b400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0x4000B800         DC32     0x4000b800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \   00000000   0x4000B00C         DC32     0x4000b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \   00000000   0x4000B40C         DC32     0x4000b40c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \   00000000   0x4000B80C         DC32     0x4000b80c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \   00000000   0x4000B004         DC32     0x4000b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_9:
   \   00000000   0x4000B404         DC32     0x4000b404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_10:
   \   00000000   0x4000B804         DC32     0x4000b804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_11:
   \   00000000   0x4000B008         DC32     0x4000b008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_12:
   \   00000000   0x4000A814         DC32     0x4000a814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_13:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_14:
   \   00000000   0x4000BC18         DC32     0x4000bc18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_15:
   \   00000000   0xE000E100         DC32     0xe000e100
    403          #endif//RHO_GPIO // Board header supports Radio HoldOff

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  halGetEm2xxResetInfo
              8 -> halGetExtendedResetInfo
              8 -> halGetResetInfo
        8  halGetExtendedResetString
              8 -> halGetExtendedResetInfo
        0  halGetRadioHoldOff
        8  halGetResetString
              8 -> halGetResetInfo
       16  halInit
             16 -> halCommonCalibratePads
             16 -> halCommonSwitchToXtal
             16 -> halCommonTryToSwitchToXtal
             16 -> halInternalCalibrateFastRc
             16 -> halInternalEnableWatchDog
             16 -> halInternalInitAdc
             16 -> halInternalInitButton
             16 -> halInternalRestartUart
             16 -> halInternalSetRegTrim
              0 -> halInternalStartSystemTimer
             16 -> halStackRadioPowerDownBoard
        0  halInternalRhoPinIsActive
        0  halIrqDIsr
              0 -> emRadioHoldOffIsr
        8  halPowerDown
              8 -> halInternalPowerDownUart
        8  halPowerUp
              8 -> halCommonCalibratePads
              8 -> halInternalBlockUntilXtal
              8 -> halInternalInitAdc
              8 -> halInternalPowerUpKickXtal
              0 -> halInternalPowerUpUart
              8 -> halStackRadioPowerDownBoard
        0  halRadioHoldOffIsActive
        0  halReboot
              0 -> halInternalSysReset
       24  halSetRadioHoldOff
             24 -> _disableBasePri
             24 -> _writeBasePri
             24 -> emRadioHoldOffIsr
        0  halStackProcessBootCount
              0 -> halInternalIncrementCounterToken
        8  halStackRadioPowerDownBoard
              0 -> rmwRadioPowerCfgReg
              8 -> rmwRadioPowerCfgReg
              8 -> rmwRadioPowerOutReg
        8  halStackRadioPowerUpBoard
              0 -> rmwRadioPowerCfgReg
              8 -> rmwRadioPowerCfgReg
              8 -> rmwRadioPowerOutReg
       20  rmwRadioPowerCfgReg
       20  rmwRadioPowerOutReg


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
       6  ?Subroutine0
      18  ?Subroutine1
      18  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
      12  ?Subroutine5
      12  ?Subroutine6
      32  BOOTLOADERResetStringTable
       8  CRASHResetStringTable
       8  EXTERNALResetStringTable
      16  FATALResetStringTable
      32  FAULTResetStringTable
      88  FIBResetStringTable
      12  FLASHResetStringTable
      12  POWERONResetStringTable
      12  SOFTWAREResetStringTable
       4  UNKNOWNResetStringTable
      12  WATCHDOGResetStringTable
      44  extendedResetStringTablePtrs
      40  gpioOutPowerUp
          gpioOutPowerDown
          rhoActive
          halInternalWakeOnLedOrRho
          rhoEnabled
          gpioCfgPowerUp
          gpioCfgPowerDown
          gpioRadioPowerBoardMask
      66  halGetEm2xxResetInfo
      26  halGetExtendedResetString
       6  halGetRadioHoldOff
      16  halGetResetString
      88  halInit
      12  halInternalRhoPinIsActive
      42  halIrqDIsr
      52  halPowerDown
      56  halPowerUp
       6  halRadioHoldOffIsActive
       8  halReboot
     184  halSetRadioHoldOff
       6  halStackProcessBootCount
      92  halStackRadioPowerDownBoard
      92  halStackRadioPowerUpBoard
      44  resetStringTable
      62  rmwRadioPowerCfgReg
      54  rmwRadioPowerOutReg

 
    40 bytes in section .data
   236 bytes in section .rodata
 1 098 bytes in section .text
 
 1 098 bytes of CODE  memory
   236 bytes of CONST memory
    40 bytes of DATA  memory

Errors: none
Warnings: none
