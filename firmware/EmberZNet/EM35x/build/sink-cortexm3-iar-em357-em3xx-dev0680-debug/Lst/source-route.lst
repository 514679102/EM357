###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     02/Jul/2013  21:36:53 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\util\ #
#                    source-route.c                                           #
#    Command line =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\util\ #
#                    source-route.c -D DEBUG -D "BOARD_HEADER=\"hal/micro/cor #
#                    texm3/em35x/board/dev0680.h\"" -D                        #
#                    "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/iar.h\""  #
#                    -D HAL_MICRO -D CORTEXM3 -D CORTEXM3_EM357 -D PHY_EM3XX  #
#                    -D BOARD_DEV0680 -D "CONFIGURATION_HEADER=\"app/sensor/s #
#                    ensor-configuration.h\"" -D SINK_APP -D                  #
#                    EMBER_SERIAL1_MODE=EMBER_SERIAL_FIFO -D                  #
#                    EMBER_SERIAL1_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL1_RX_QUEUE_SIZE=16 -D EMBER_SERIAL0_DEBUG    #
#                    -D EMBER_SERIAL0_MODE=EMBER_SERIAL_FIFO -D               #
#                    EMBER_SERIAL0_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL0_RX_QUEUE_SIZE=64 -D                        #
#                    SCAN_DEBUG_PRINT_ENABLE -D USE_BOOTLOADER_LIB -D         #
#                    "__SOURCEFILE__=\"source-route.c\"" -lC                  #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\            #
#                    --diag_suppress Pa050 -o F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\build\sink-cortexm3-iar-em357-em3xx-dev0 #
#                    680-debug\Obj\ --debug --endian=little --cpu=Cortex-M3   #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I F:\Firmware\emberZNet\firmware\EmberZNet\EM35x #
#                    \app\util\ -I F:\Firmware\emberZNet\firmware\EmberZNet\E #
#                    M35x\app\sensor\ewb-em357\..\..\..\ -I                   #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\STACK\ -I                           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\HAL\ -I                             #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -Ohz --use_c++_inline              #
#    List file    =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\source-rout #
#                    e.lst                                                    #
#    Object file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Obj\source-rout #
#                    e.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\util\source-route.c
      1          // File: source-route.c
      2          //
      3          // Description: Example code for managing source routes on a node-based gateway.
      4          // For host-based gateways refer to source-route-host.c.
      5          //
      6          // New source routes are added to the table in the
      7          // emberIncomingRouteRecordHandler() callback. Adding a route results in routes
      8          // to all intermediate relays as well.
      9          //
     10          // For every outgoing packet, the stack calls emberAppendSourceRouteHandler().
     11          // If a source route to the destination is found, it is added to the packet.
     12          //
     13          // In this implementation, the maximum table size is 255 entries since a
     14          // one-byte index is used and the index 0xFF is reserved.
     15          // 
     16          // Copyright 2007 by Ember Corporation. All rights reserved.                *80*
     17          
     18          #include PLATFORM_HEADER
     19          
     20          #include "stack/include/ember.h"
     21          #include "app/util/security/security.h"
     22          #include "source-route-common.h"
     23          
     24          // AppBuilder includes this file and uses the define below to turn off source
     25          // routing. This doesnt affect non-AppBuilder applications.
     26          #ifndef ZA_NO_SOURCE_ROUTING
     27          
     28          
     29          // ZigBee protocol limitations effectively constrain us to a 11-hop source route
     30          // in the worst case scenario (for a 12-hop delivery in total), so we enforce
     31          // a threshold value on the relayCount and ignore source route operations beyond
     32          // this threshold.  See explanatory comment in emberAppendSourceRouteHandler()
     33          // for more details about this.
     34          // This value could be reduced at the designer's discretion, but not increased
     35          // beyond 11 without causing routing problems.
     36          #define MAX_RELAY_COUNT    11
     37          
     38          #ifndef EXTERNAL_TABLE

   \                                 In section .bss, align 4
     39          static SourceRouteTableEntry table[EMBER_SOURCE_ROUTE_TABLE_SIZE];
   \                     table:
   \   00000000                      DS8 60

   \                                 In section .data, align 1
     40          int8u sourceRouteTableSize = EMBER_SOURCE_ROUTE_TABLE_SIZE;
   \                     sourceRouteTableSize:
   \   00000000   0x0F               DC8 15

   \                                 In section .data, align 4
     41          SourceRouteTableEntry *sourceRouteTable = table;
   \                     sourceRouteTable:
   \   00000000   0x........         DC32 table
     42          #endif
     43          
     44          

   \                                 In section .text, align 2, keep-with-next
     45          void emberIncomingRouteRecordHandler(EmberNodeId source,
     46                                               EmberEUI64 sourceEui,
     47                                               int8u relayCount,
     48                                               EmberMessageBuffer header,
     49                                               int8u relayListIndex)
     50          {
   \                     emberIncomingRouteRecordHandler:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x461E             MOV      R6,R3
     51            int8u previous;
     52            int8u i;
     53          
     54            // If the following message has APS Encryption, our node will need to know
     55            // the IEEE Address of the source in order to properly decrypt.
     56            securityAddToAddressCache(source, sourceEui);
   \   0000000A   0x.... 0x....      BL       securityAddToAddressCache
     57          
     58            if (sourceRouteTableSize == 0) {
   \   0000000E   0x....             LDR.N    R0,??DataTable1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xB1B8             CBZ.N    R0,??emberIncomingRouteRecordHandler_0
     59              return;
     60            }
     61          
     62            // Ignore over-sized source routes, since we can't reuse them reliably anyway.
     63            if (relayCount > MAX_RELAY_COUNT) {
   \   00000014   0x2D0C             CMP      R5,#+12
   \   00000016   0xD215             BCS.N    ??emberIncomingRouteRecordHandler_0
     64              return;
     65            }
     66          
     67            // The source of the route record is furthest from the gateway. We start there
     68            // and work closer.
     69            previous = sourceRouteAddEntry(source, NULL_INDEX);
   \   00000018   0x21FF             MOVS     R1,#+255
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       sourceRouteAddEntry
   \   00000020   0x4680             MOV      R8,R0
     70          
     71            // Go through the relay list and add them to the source route table.
     72            for (i = 0; i < relayCount; i++) {
   \   00000022   0x2700             MOVS     R7,#+0
   \   00000024   0x9C06             LDR      R4,[SP, #+24]
   \   00000026   0xE00A             B.N      ??emberIncomingRouteRecordHandler_1
     73              int8u index = relayListIndex + ((int8u) (i << 1));
     74              EmberNodeId id = emberGetLinkedBuffersLowHighInt16u(header, index);
   \                     ??emberIncomingRouteRecordHandler_2:
   \   00000028   0xEB04 0x0147      ADD      R1,R4,R7, LSL #+1
   \   0000002C   0xB2C9             UXTB     R1,R1
   \   0000002E   0x4630             MOV      R0,R6
   \   00000030   0x.... 0x....      BL       emberGetLinkedBuffersLowHighInt16u
     75              // We pass the index of the previous entry to link the route together.
     76              previous = sourceRouteAddEntry(id, previous);
   \   00000034   0x4641             MOV      R1,R8
   \   00000036   0x.... 0x....      BL       sourceRouteAddEntry
   \   0000003A   0x4680             MOV      R8,R0
     77            }
   \   0000003C   0x1C7F             ADDS     R7,R7,#+1
   \                     ??emberIncomingRouteRecordHandler_1:
   \   0000003E   0xB2FF             UXTB     R7,R7
   \   00000040   0x42AF             CMP      R7,R5
   \   00000042   0xD3F1             BCC.N    ??emberIncomingRouteRecordHandler_2
   \                     ??emberIncomingRouteRecordHandler_0:
   \   00000044   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     78          }
     79          

   \                                 In section .text, align 2, keep-with-next
     80          int8u emberAppendSourceRouteHandler(EmberNodeId destination,
     81                                              EmberMessageBuffer header)
     82          {
   \                     emberAppendSourceRouteHandler:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4689             MOV      R9,R1
     83            int8u foundIndex = sourceRouteFindIndex(destination);
   \   00000006   0x.... 0x....      BL       sourceRouteFindIndex
     84            int8u relayCount = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
     85            int8u addedBytes;
     86            int8u bufferLength = emberMessageBufferLength(header);
   \   0000000C   0x....             LDR.N    R1,??DataTable1_1
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0xF819 0xA001      LDRB     R10,[R9, R1]
     87            int8u i;
     88          
     89            if (foundIndex == NULL_INDEX) {
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xD019             BEQ.N    ??emberAppendSourceRouteHandler_0
     90              return 0;
     91            }
     92          
     93            // Find out what the relay count is.
     94            i = foundIndex;
   \   00000018   0x4680             MOV      R8,R0
   \   0000001A   0x4645             MOV      R5,R8
   \   0000001C   0x....             LDR.N    R7,??DataTable1_2
   \   0000001E   0xE000             B.N      ??emberAppendSourceRouteHandler_1
     95            while (sourceRouteTable[i].closerIndex != NULL_INDEX) {
     96              i = sourceRouteTable[i].closerIndex;
     97              relayCount++;
   \                     ??emberAppendSourceRouteHandler_2:
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \                     ??emberAppendSourceRouteHandler_1:
   \   00000022   0x6838             LDR      R0,[R7, #+0]
   \   00000024   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000028   0x7885             LDRB     R5,[R0, #+2]
   \   0000002A   0x2DFF             CMP      R5,#+255
   \   0000002C   0xD1F8             BNE.N    ??emberAppendSourceRouteHandler_2
     98            }
     99          
    100            // Per Ember Case 10096, we need to protect against oversized source
    101            // routes that will overflow the PHY packet length (127).  Since the
    102            // worst-case packet overhead is the APS-encrypted, NWK-encrypted,
    103            // tunneled key delivery sent by the Trust Center during
    104            // authentication of new devices, and this leaves enough only room
    105            // for an 11-hop source route frame, we abort our route-appending
    106            // operation if the resulting source route contains more than 11
    107            // relays.  Unless a route already exists to the destination, this
    108            // will likely result in the stack not sending the packet at all,
    109            // but this is better than forcing too much data into the packet
    110            // (which, as of this writing, will trigger an assert in mac.c and
    111            // cause a reset).
    112          
    113            if (MAX_RELAY_COUNT < relayCount) {
   \   0000002E   0xB2F6             UXTB     R6,R6
   \   00000030   0x2E0C             CMP      R6,#+12
   \   00000032   0xD20B             BCS.N    ??emberAppendSourceRouteHandler_0
    114              return 0;
    115            }
    116          
    117            addedBytes = 2 + ((int8u) (relayCount << 1));
   \   00000034   0x0070             LSLS     R0,R6,#+1
   \   00000036   0x1C84             ADDS     R4,R0,#+2
    118          
    119            if (header != EMBER_NULL_MESSAGE_BUFFER) {
   \   00000038   0xF1B9 0x0FFF      CMP      R9,#+255
   \   0000003C   0xD028             BEQ.N    ??emberAppendSourceRouteHandler_3
    120              // Two bytes for the relay count and relay index.
    121              int8u bufferIndex = bufferLength;
    122          
    123              if (emberSetLinkedBuffersLength(header, bufferLength + addedBytes)
    124                  != EMBER_SUCCESS) {
   \   0000003E   0xEB04 0x010A      ADD      R1,R4,R10
   \   00000042   0xB2C9             UXTB     R1,R1
   \   00000044   0x4648             MOV      R0,R9
   \   00000046   0x.... 0x....      BL       emberSetLinkedBuffersLength
   \   0000004A   0xB108             CBZ.N    R0,??emberAppendSourceRouteHandler_4
    125                return 0;
   \                     ??emberAppendSourceRouteHandler_0:
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE020             B.N      ??emberAppendSourceRouteHandler_5
    126              }
    127          
    128              // Set the relay count and relay index.
    129              emberSetLinkedBuffersByte(header, bufferIndex++, relayCount);
   \                     ??emberAppendSourceRouteHandler_4:
   \   00000050   0x4632             MOV      R2,R6
   \   00000052   0x4651             MOV      R1,R10
   \   00000054   0x4648             MOV      R0,R9
   \   00000056   0x.... 0x....      BL       emberSetLinkedBuffersByte
   \   0000005A   0xF10A 0x0501      ADD      R5,R10,#+1
    130              emberSetLinkedBuffersByte(header,
    131                                        bufferIndex++,
    132                                        (0 < relayCount
    133                                         ? relayCount - 1
    134                                         : 0));
   \   0000005E   0x2E00             CMP      R6,#+0
   \   00000060   0xBF14             ITE      NE 
   \   00000062   0x1E72             SUBNE    R2,R6,#+1
   \   00000064   0x2200             MOVEQ    R2,#+0
   \   00000066   0xB2D2             UXTB     R2,R2
   \   00000068   0xB2E9             UXTB     R1,R5
   \   0000006A   0x4648             MOV      R0,R9
   \   0000006C   0x.... 0x....      BL       emberSetLinkedBuffersByte
   \   00000070   0x1C6E             ADDS     R6,R5,#+1
    135          
    136              // Fill in the relay list. The first relay in the list is the closest to the
    137              // destination (furthest from the gateway).
    138              i = foundIndex;
   \   00000072   0x4645             MOV      R5,R8
   \   00000074   0xE006             B.N      ??emberAppendSourceRouteHandler_6
    139              while (sourceRouteTable[i].closerIndex != NULL_INDEX) {
    140                i = sourceRouteTable[i].closerIndex;
    141                emberSetLinkedBuffersLowHighInt16u(header, 
    142                                                   bufferIndex,
    143                                                   sourceRouteTable[i].destination);
   \                     ??emberAppendSourceRouteHandler_7:
   \   00000076   0xF830 0x2025      LDRH     R2,[R0, R5, LSL #+2]
   \   0000007A   0xB2F1             UXTB     R1,R6
   \   0000007C   0x4648             MOV      R0,R9
   \   0000007E   0x.... 0x....      BL       emberSetLinkedBuffersLowHighInt16u
    144                bufferIndex += 2;
   \   00000082   0x1CB6             ADDS     R6,R6,#+2
    145              }
   \                     ??emberAppendSourceRouteHandler_6:
   \   00000084   0x6838             LDR      R0,[R7, #+0]
   \   00000086   0xEB00 0x0185      ADD      R1,R0,R5, LSL #+2
   \   0000008A   0x788D             LDRB     R5,[R1, #+2]
   \   0000008C   0x2DFF             CMP      R5,#+255
   \   0000008E   0xD1F2             BNE.N    ??emberAppendSourceRouteHandler_7
    146            }
    147          
    148            return addedBytes;
   \                     ??emberAppendSourceRouteHandler_3:
   \   00000090   0xB2E0             UXTB     R0,R4
   \                     ??emberAppendSourceRouteHandler_5:
   \   00000092   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    149          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     sourceRouteTableSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     emMessageBufferLengths

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     sourceRouteTable
    150          #endif //ZA_NO_SOURCE_ROUTING

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  emberAppendSourceRouteHandler
             32 -> emberSetLinkedBuffersByte
             32 -> emberSetLinkedBuffersLength
             32 -> emberSetLinkedBuffersLowHighInt16u
             32 -> sourceRouteFindIndex
       24  emberIncomingRouteRecordHandler
             24 -> emberGetLinkedBuffersLowHighInt16u
             24 -> securityAddToAddressCache
             24 -> sourceRouteAddEntry


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
     150  emberAppendSourceRouteHandler
      72  emberIncomingRouteRecordHandler
       4  sourceRouteTable
       1  sourceRouteTableSize
      60  table

 
  60 bytes in section .bss
   5 bytes in section .data
 234 bytes in section .text
 
 234 bytes of CODE memory
  65 bytes of DATA memory

Errors: none
Warnings: none
