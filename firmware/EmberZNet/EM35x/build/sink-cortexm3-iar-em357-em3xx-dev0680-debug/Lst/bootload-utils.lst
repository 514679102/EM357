###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     02/Jul/2013  21:36:21 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\util\ #
#                    bootload\bootload-utils.c                                #
#    Command line =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\util\ #
#                    bootload\bootload-utils.c -D DEBUG -D                    #
#                    "BOARD_HEADER=\"hal/micro/cortexm3/em35x/board/dev0680.h #
#                    \"" -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/ia #
#                    r.h\"" -D HAL_MICRO -D CORTEXM3 -D CORTEXM3_EM357 -D     #
#                    PHY_EM3XX -D BOARD_DEV0680 -D                            #
#                    "CONFIGURATION_HEADER=\"app/sensor/sensor-configuration. #
#                    h\"" -D SINK_APP -D EMBER_SERIAL1_MODE=EMBER_SERIAL_FIFO #
#                     -D EMBER_SERIAL1_TX_QUEUE_SIZE=128 -D                   #
#                    EMBER_SERIAL1_RX_QUEUE_SIZE=16 -D EMBER_SERIAL0_DEBUG    #
#                    -D EMBER_SERIAL0_MODE=EMBER_SERIAL_FIFO -D               #
#                    EMBER_SERIAL0_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL0_RX_QUEUE_SIZE=64 -D                        #
#                    SCAN_DEBUG_PRINT_ENABLE -D USE_BOOTLOADER_LIB -D         #
#                    "__SOURCEFILE__=\"bootload-utils.c\"" -lC                #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\            #
#                    --diag_suppress Pa050 -o F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\build\sink-cortexm3-iar-em357-em3xx-dev0 #
#                    680-debug\Obj\ --debug --endian=little --cpu=Cortex-M3   #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I F:\Firmware\emberZNet\firmware\EmberZNet\EM35x #
#                    \app\util\bootload\ -I F:\Firmware\emberZNet\firmware\Em #
#                    berZNet\EM35x\app\sensor\ewb-em357\..\..\..\ -I          #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\STACK\ -I                           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\HAL\ -I                             #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -Ohz --use_c++_inline              #
#    List file    =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\bootload-ut #
#                    ils.lst                                                  #
#    Object file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Obj\bootload-ut #
#                    ils.o                                                    #
#                                                                             #
#                                                                             #
###############################################################################

F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\util\bootload\bootload-utils.c
      1          // *******************************************************************
      2          // * bootload-utils.c
      3          // * 
      4          // * Utilities used for bootloading.
      5          // * See bootload-utils.h for more complete description
      6          // *
      7          // * Copyright 2006-2010 by Ember Corporation. All rights reserved.         *80*
      8          // *******************************************************************
      9          
     10          #include PLATFORM_HEADER     // Micro and compiler specific typedefs and macros
     11          
     12          // Ember stack and related utilities
     13          #include "stack/include/ember.h"         // Main stack definitions
     14          #include "stack/include/packet-buffer.h" // Linked message buffers
     15          #include "stack/include/error.h"         // Status codes
     16          
     17          // HAL
     18          #include "hal/hal.h" 
     19          #if defined(XAP2B)
     20            #include "hal/micro/xap2b/em250/memmap.h"   // location of application
     21            #include "hal/micro/xap2b/em250/em250-ebl.h"  // ebl file format
     22            #include "hal/micro/xap2b/em250/flash.h"      // flash read mechanism
     23          #elif defined(CORTEXM3)
     24            #include "hal/micro/cortexm3/flash.h"      // flash read mechanism
     25          #endif
     26          
     27          // Application utilities
     28          #include "app/util/serial/serial.h"
     29          #include "app/util/zigbee-framework/zigbee-device-library.h"
     30          #include "app/util/bootload/bootload-utils-internal.h"  // internal declaration
     31          #include "app/util/bootload/bootload-utils.h"           // public interface
     32          
     33          // The variables below are used in bootloader-demo-v2.c, hence, need to be
     34          // defined in case USE_BOOTLOADER_LIB is not defined.
     35          // Making a handy broadcast EUI64 address
     36          EmberEUI64 broadcastEui64 = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
     37          
     38          // Initialize bootload state to normal (not currently participate in 
     39          // bootloading)
     40          bootloadState blState = BOOTLOAD_STATE_NORMAL;
     41          
     42          #ifdef  USE_BOOTLOADER_LIB
     43          // ***********************************************
     44          // NOTE: applications that use the bootload utilities need to 
     45          // define EMBER_APPLICATION_HAS_BOOTLOAD_HANDLERS
     46          // within their CONFIGURATION_HEADER
     47          // ***********************************************
     48          
     49          // There are two main bootload modes (serial and passthru) that 
     50          // determines the responsibilities of the source node whether to bootload
     51          // itself via serial (uart) interface, or to receive the image data via xmodem 
     52          // from the host PC to bootload another node.
     53          bootloadMode blMode = BOOTLOAD_MODE_NONE;
     54          
     55          // bootload (xmodem) protocols variables
     56          int8u currentRetriesRemaining;

   \                                 In section .bss, align 4
     57          int8u xmodemBlock[XMODEM_BLOCK_SIZE];
   \                     xmodemBlock:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
     58          int8u bootloadBuffer[MAX_BOOTLOAD_MESSAGE_SIZE];
   \                     bootloadBuffer:
   \   00000000                      DS8 72
     59          int8u expectedBlockNumber = 1;

   \                                 In section .bss, align 1
     60          int8u currentIndex = 0;
   \                     currentIndex:
   \   00000000                      DS8 1
     61          #ifndef SBL_LIB_TARGET   //dont do remote bootload
     62          int32u flashStreamCrc = INITIAL_CRC;
     63          #endif
     64          // XModem protocol supports packet of 128 bytes in length, however, 
     65          // we can only send it in BOOTLOAD_OTA_SIZE (64 bytes) at a time
     66          // over the air (OTA).  Hence, XModem packets are divided into two
     67          // over-the-air messages. Values of the over-the-air block number are 
     68          // (2*expectedBlockNumber) and (2*expectedBlockNumber)-1
     69          int8u currentOTABlock; 
     70          
     71          // Eui64 address of the target node
     72          EmberEUI64 targetAddress;
     73          
     74          // To keep track of how much time we should wait.  A simple timeout mechanism
     75          int8u actionTimer;
     76          
     77          // Port for serial prints and bootloading
     78          int8u appSerial = 0;
     79          int8u bootloadSerial = 1;
     80          
     81          // Generic global variables

   \                                 In section .bss, align 1
     82          EmberStatus emberStatus;
   \                     emberStatus:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     83          boolean booleanStatus;
   \                     booleanStatus:
   \   00000000                      DS8 1
     84          
     85          // Authentication block contains necessary information to perform
     86          // security measure before going into bootload mode
     87          #pragma align authBlock
     88          int8u authBlock[BOOTLOAD_AUTH_COMMON_SIZE];
     89          
     90          // This message buffer stores the key while waiting for the challenge to be sent
     91          // by the target node stack.
     92          static EmberMessageBuffer signingKey = EMBER_NULL_MESSAGE_BUFFER;
     93          
     94          // This message buffer stores the authentication challenge while waiting for
     95          // the authentication response to come back from the requesting node.
     96          static EmberMessageBuffer challenge = EMBER_NULL_MESSAGE_BUFFER;
     97          
     98          // Forward declaration of functions used internally by bootload 
     99          // utilities library.  These functions are defined by bootload utility
    100          // library.
    101          static int8u isTheSameEui64(EmberEUI64 source, EmberEUI64 target);
    102          static int8u bootloadMakeHeader(int8u *message, int8u type);
    103          static void sendRadioMessage(int8u type, boolean isBroadcast);
    104          #ifndef SBL_LIB_TARGET   // can be a source node
    105           static void xmodemReceiveAndForward(void);
    106           static void printEui(EmberEUI64 eui);
    107           static boolean isSleepy(EmberEUI64 eui);
    108           #ifndef SBL_LIB_SRC_NO_PASSTHRU // used in passthru mode
    109            static int8u xmodemReadSerialByte(int8u timeout, int8u *byte);
    110            static int8u xmodemReceiveBlock(void);
    111            static void xmodemSendReady(void);
    112           #endif
    113           static boolean bootloadSendImage(int8u type);
    114          #endif // SBL_LIB_TARGET
    115          
    116          
    117          #define sendMACImageSegment() sendRadioMessage(XMODEM_SOH, FALSE)
    118          #define sendMACCompleteSegment() sendRadioMessage(XMODEM_EOT, FALSE)
    119          
    120          void emAesEncrypt(int8u block[16], int8u *key);
    121          
    122          
    123          // ****************************************************************
    124          // Public functions that can be called from the application to utilize
    125          // bootload features.
    126          // ****************************************************************
    127          
    128          // -------------------------------------------------------------------------
    129          // Initialize serial port

   \                                 In section .text, align 2, keep-with-next
    130          void bootloadUtilInit(int8u appPort, int8u bootloadPort)
    131          {
   \                     bootloadUtilInit:
   \   00000000   0xB510             PUSH     {R4,LR}
    132            appSerial = appPort;
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable26
   \   00000006   0x71A0             STRB     R0,[R4, #+6]
    133            bootloadSerial = bootloadPort;
   \   00000008   0x71E1             STRB     R1,[R4, #+7]
    134            emberSerialInit(bootloadSerial, BOOTLOAD_BAUD_RATE, PARITY_NONE, 1);
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x210F             MOVS     R1,#+15
   \   00000010   0x79E0             LDRB     R0,[R4, #+7]
   \   00000012   0xE8BD 0x4010      POP      {R4,LR}
   \   00000016   0x.... 0x....      B.W      emberSerialInit
    135          }
    136          
    137          #ifndef SBL_LIB_SRC_NO_PASSTHRU
    138          // -------------------------------------------------------------------------
    139          // Send bootload request to initiate bootload transaction with the target node.

   \                                 In section .text, align 2, keep-with-next
    140          EmberStatus bootloadUtilSendRequest(EmberEUI64 targetEui,
    141                                              int16u mfgId,
    142                                              int8u hardwareTag[BOOTLOAD_HARDWARE_TAG_SIZE],
    143                                              int8u encryptKey[BOOTLOAD_AUTH_COMMON_SIZE],
    144                                              bootloadMode mode)
    145          {
   \                     bootloadUtilSendRequest:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x4698             MOV      R8,R3
   \   0000000A   0x9906             LDR      R1,[SP, #+24]
    146            int8u index;
    147            EmberMessageBuffer buffer = EMBER_NULL_MESSAGE_BUFFER;
    148            EmberStatus status;
    149          
    150            if (IS_BOOTLOADING) {
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable26
   \   00000010   0x7822             LDRB     R2,[R4, #+0]
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x2A0B             CMPNE    R2,#+11
   \   00000018   0x2001             MOVNE    R0,#+1
    151              // Another bootload launch request is in progress.
    152              bl_print("TX error: already in bootloading\r\n");
    153              return EMBER_ERR_FATAL;
   \   0000001A   0xD132             BNE.N    ??bootloadUtilSendRequest_0
    154            }
    155          
    156            blMode = mode;
   \   0000001C   0x7061             STRB     R1,[R4, #+1]
    157            
    158            // Save the target eui for later use in bootloading (after launch).
    159            MEMCOPY(targetAddress, targetEui, EUI64_SIZE);
   \   0000001E   0x2208             MOVS     R2,#+8
   \   00000020   0x4601             MOV      R1,R0
   \   00000022   0xF104 0x0014      ADD      R0,R4,#+20
   \   00000026   0x.... 0x....      BL       halCommonMemCopy
    160            
    161            index = bootloadMakeHeader(bootloadBuffer, XMODEM_LAUNCH_REQUEST);
   \   0000002A   0x.... 0x....      LDR.W    R7,??DataTable26_1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x7038             STRB     R0,[R7, #+0]
   \   00000032   0x204C             MOVS     R0,#+76
   \   00000034   0x7078             STRB     R0,[R7, #+1]
    162          
    163            // create bootload launch request payload
    164            bootloadBuffer[index++] = LOW_BYTE(mfgId);
   \   00000036   0x70BD             STRB     R5,[R7, #+2]
    165            bootloadBuffer[index++] = HIGH_BYTE(mfgId);
   \   00000038   0x0A28             LSRS     R0,R5,#+8
   \   0000003A   0x70F8             STRB     R0,[R7, #+3]
    166            MEMCOPY(&bootloadBuffer[index], hardwareTag, BOOTLOAD_HARDWARE_TAG_SIZE);
   \   0000003C   0x2210             MOVS     R2,#+16
   \   0000003E   0x4631             MOV      R1,R6
   \   00000040   0x1D38             ADDS     R0,R7,#+4
   \   00000042   0x.... 0x....      BL       halCommonMemCopy
    167            index += BOOTLOAD_HARDWARE_TAG_SIZE;
    168            
    169            // Save the key to use later when sending the authentication response.
    170            signingKey = emberFillLinkedBuffers(encryptKey, BOOTLOAD_AUTH_COMMON_SIZE);
   \   00000046   0x2110             MOVS     R1,#+16
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0x.... 0x....      BL       emberFillLinkedBuffers
   \   0000004E   0x7220             STRB     R0,[R4, #+8]
    171          
    172            if (EMBER_NULL_MESSAGE_BUFFER == signingKey) {
   \   00000050   0x28FF             CMP      R0,#+255
   \   00000052   0xBF08             IT       EQ 
   \   00000054   0x2618             MOVEQ    R6,#+24
   \   00000056   0xD013             BEQ.N    ??bootloadUtilSendRequest_1
    173              // Not enough buffers were available for the authentication key.
    174              status = EMBER_NO_BUFFERS;
    175            }
    176            else {
    177              // copy the message into buffers
    178              buffer = emberFillLinkedBuffers(bootloadBuffer, index);
   \   00000058   0x2114             MOVS     R1,#+20
   \   0000005A   0x4638             MOV      R0,R7
   \   0000005C   0x.... 0x....      BL       emberFillLinkedBuffers
   \   00000060   0x4605             MOV      R5,R0
    179          
    180              // check to make sure a buffer is available
    181              if (buffer == EMBER_NULL_MESSAGE_BUFFER) {
   \   00000062   0x2DFF             CMP      R5,#+255
   \   00000064   0xD10F             BNE.N    ??bootloadUtilSendRequest_2
    182                bl_print("TX error: Out Of Buffers\r\n");
    183                status = EMBER_NO_BUFFERS;
   \   00000066   0x2618             MOVS     R6,#+24
    184              }
    185              else if ( emberSendBootloadMessage(FALSE, targetAddress, buffer)
    186                      !=EMBER_SUCCESS ) {
    187                blState = BOOTLOAD_STATE_NORMAL;
    188                blMode = BOOTLOAD_MODE_NONE;
    189                status = EMBER_ERR_FATAL;
    190              } else {
    191                // message sent successfully.
    192                blState = BOOTLOAD_STATE_WAIT_FOR_AUTH_CHALLENGE;
    193                actionTimer = TIMEOUT_AUTH_CHALLENGE;
    194                status = EMBER_SUCCESS;
    195              }
    196            }
    197          
    198            if (EMBER_SUCCESS != status) {
    199              // We failed somewhere above.  Release the key buffer if it was allocated.
    200              if (signingKey != EMBER_NULL_MESSAGE_BUFFER) {
   \                     ??bootloadUtilSendRequest_3:
   \   00000068   0x7A20             LDRB     R0,[R4, #+8]
   \   0000006A   0x28FF             CMP      R0,#+255
   \   0000006C   0xD003             BEQ.N    ??bootloadUtilSendRequest_4
    201                emberReleaseMessageBuffer(signingKey);
   \   0000006E   0x.... 0x....      BL       emReleaseMessageBuffer
    202                signingKey = EMBER_NULL_MESSAGE_BUFFER;
   \   00000072   0x20FF             MOVS     R0,#+255
   \   00000074   0x7220             STRB     R0,[R4, #+8]
    203              }
    204            }
    205          
    206            // Done with buffer.
    207            if (buffer != EMBER_NULL_MESSAGE_BUFFER) {
   \                     ??bootloadUtilSendRequest_4:
   \   00000076   0x2DFF             CMP      R5,#+255
   \   00000078   0xD002             BEQ.N    ??bootloadUtilSendRequest_1
    208              emberReleaseMessageBuffer(buffer);
   \                     ??bootloadUtilSendRequest_5:
   \   0000007A   0x4628             MOV      R0,R5
   \   0000007C   0x.... 0x....      BL       emReleaseMessageBuffer
    209            }
    210            
    211            return status;
   \                     ??bootloadUtilSendRequest_1:
   \   00000080   0x4630             MOV      R0,R6
   \                     ??bootloadUtilSendRequest_0:
   \   00000082   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??bootloadUtilSendRequest_2:
   \   00000086   0x462A             MOV      R2,R5
   \   00000088   0xF104 0x0114      ADD      R1,R4,#+20
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      BL       emberSendBootloadMessage
   \   00000092   0xB120             CBZ.N    R0,??bootloadUtilSendRequest_6
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x7020             STRB     R0,[R4, #+0]
   \   00000098   0x7060             STRB     R0,[R4, #+1]
   \   0000009A   0x2601             MOVS     R6,#+1
   \   0000009C   0xE7E4             B.N      ??bootloadUtilSendRequest_3
   \                     ??bootloadUtilSendRequest_6:
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0x7020             STRB     R0,[R4, #+0]
   \   000000A2   0x200F             MOVS     R0,#+15
   \   000000A4   0x7160             STRB     R0,[R4, #+5]
   \   000000A6   0x2600             MOVS     R6,#+0
   \   000000A8   0xE7E7             B.N      ??bootloadUtilSendRequest_5
    212          }
    213          #endif //!defined(SBL_LIB_SRC_NO_PASSTHRU)
    214          
    215          // A utility function called after a node has received bootload launch request
    216          // message.  The challenge message is part of the handshake process that needs
    217          // to be completed before a node goes into bootloader mode.

   \                                 In section .text, align 2, keep-with-next
    218          static EmberStatus bootloadSendAuthChallenge(EmberEUI64 sourceEui) {
   \                     bootloadSendAuthChallenge:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    219            int8u index, challengeStart;
    220            EmberMessageBuffer message = EMBER_NULL_MESSAGE_BUFFER;
    221            int32u macTimer;
    222            EmberStatus status;
    223            int16u blVersion; // if the version is invalid, the value is 0xFFFF
    224          
    225            index = bootloadMakeHeader(bootloadBuffer, XMODEM_AUTH_CHALLENGE);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable26_1
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x7028             STRB     R0,[R5, #+0]
   \   0000000C   0x2063             MOVS     R0,#+99
   \   0000000E   0x7068             STRB     R0,[R5, #+1]
    226            challengeStart = index;
    227            
    228            // The authentication challenge is the entire bootload payload.
    229            // 1st byte -- a version setting.
    230            bootloadBuffer[index++] = 0x01;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x70A8             STRB     R0,[R5, #+2]
    231            // Send bootloader version here also.
    232            // {2:blVersion}
    233            blVersion = halGetStandaloneBootloaderVersion();
   \   00000014   0x.... 0x....      BL       halGetStandaloneBootloaderVersion
    234            bootloadBuffer[index++] = HIGH_BYTE(blVersion); // bootloader version
   \   00000018   0x1201             ASRS     R1,R0,#+8
   \   0000001A   0x70E9             STRB     R1,[R5, #+3]
    235            bootloadBuffer[index++] = LOW_BYTE(blVersion);  // bootloader build
   \   0000001C   0x7128             STRB     R0,[R5, #+4]
    236            // (1:plat)
    237            bootloadBuffer[index++] = PLAT;                 // Needed in case blVersion unknown
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0x7168             STRB     R0,[R5, #+5]
    238            // (1:micro)
    239            bootloadBuffer[index++] = MICRO;                // Needed in case blVersion unknown
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x71A8             STRB     R0,[R5, #+6]
    240            // (1:phy)
    241            bootloadBuffer[index++] = PHY;                  // Needed in case blVersion unknown
   \   00000026   0x71E8             STRB     R0,[R5, #+7]
    242            // The second part of the challenge is the local eui.
    243            MEMCOPY(&bootloadBuffer[index], emLocalEui64, EUI64_SIZE);
   \   00000028   0x2208             MOVS     R2,#+8
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable26_2
   \   0000002E   0xF105 0x0008      ADD      R0,R5,#+8
   \   00000032   0x.... 0x....      BL       halCommonMemCopy
    244            index += EUI64_SIZE;
    245            // The next part of the challenge is a snapshot of the mac timer.
    246            macTimer = halStackGetInt32uSymbolTick();
   \   00000036   0x.... 0x....      BL       halStackGetInt32uSymbolTick
   \   0000003A   0x9000             STR      R0,[SP, #+0]
    247            // The em250's mac timer is 20 bits long.  Disregard the first byte (zero),
    248            // even for other devices that may have a 32-bit symbol timer.
    249            MEMCOPY(&bootloadBuffer[index], &(((int8u*)(&macTimer))[1]), 3);
   \   0000003C   0x2203             MOVS     R2,#+3
   \   0000003E   0xF10D 0x0101      ADD      R1,SP,#+1
   \   00000042   0xF105 0x0010      ADD      R0,R5,#+16
   \   00000046   0x.... 0x....      BL       halCommonMemCopy
    250            index += 3;
   \   0000004A   0x2613             MOVS     R6,#+19
   \   0000004C   0xE003             B.N      ??bootloadSendAuthChallenge_0
    251            // The rest of the challenge is padded with random data.
    252            while ( (index-challengeStart) < BOOTLOAD_AUTH_CHALLENGE_SIZE) {
    253              bootloadBuffer[index++] = halCommonGetRandom();
   \                     ??bootloadSendAuthChallenge_1:
   \   0000004E   0x.... 0x....      BL       halCommonGetRandom
   \   00000052   0x5570             STRB     R0,[R6, R5]
   \   00000054   0x1C76             ADDS     R6,R6,#+1
    254            }
   \                     ??bootloadSendAuthChallenge_0:
   \   00000056   0xB2F6             UXTB     R6,R6
   \   00000058   0x1EB0             SUBS     R0,R6,#+2
   \   0000005A   0x2810             CMP      R0,#+16
   \   0000005C   0xDBF7             BLT.N    ??bootloadSendAuthChallenge_1
    255          
    256            // Save the challenge so that the response can be verified when received.
    257            if (challenge != EMBER_NULL_MESSAGE_BUFFER) {
   \   0000005E   0x.... 0x....      LDR.W    R7,??DataTable26
   \   00000062   0x7A78             LDRB     R0,[R7, #+9]
   \   00000064   0x28FF             CMP      R0,#+255
   \   00000066   0xBF18             IT       NE 
   \   00000068   0x.... 0x....      BLNE     emReleaseMessageBuffer
    258              emberReleaseMessageBuffer(challenge);
    259              // would set challenge to null, but it is set immediately after.
    260              //challenge = EMBER_NULL_MESSAGE_BUFFER;
    261            }
    262            challenge = emberFillLinkedBuffers(&bootloadBuffer[challengeStart],
    263                                               BOOTLOAD_AUTH_CHALLENGE_SIZE);
   \   0000006C   0x2110             MOVS     R1,#+16
   \   0000006E   0x1CA8             ADDS     R0,R5,#+2
   \   00000070   0x.... 0x....      BL       emberFillLinkedBuffers
   \   00000074   0x7278             STRB     R0,[R7, #+9]
    264            if (EMBER_NULL_MESSAGE_BUFFER == challenge) {
   \   00000076   0x28FF             CMP      R0,#+255
   \   00000078   0xD00B             BEQ.N    ??bootloadSendAuthChallenge_2
    265              // Not enough buffers were available for the challenge.
    266              status = EMBER_NO_BUFFERS;
    267            }
    268            else {  
    269              // Copy the message into buffers.
    270              message = emberFillLinkedBuffers(bootloadBuffer, index);
   \   0000007A   0x4631             MOV      R1,R6
   \   0000007C   0x4628             MOV      R0,R5
   \   0000007E   0x.... 0x....      BL       emberFillLinkedBuffers
   \   00000082   0x4605             MOV      R5,R0
    271              if (EMBER_NULL_MESSAGE_BUFFER == message) {
   \   00000084   0x2DFF             CMP      R5,#+255
   \   00000086   0xD106             BNE.N    ??bootloadSendAuthChallenge_3
    272                // Not enough buffers were available for the message.
    273                // Clean up the challenge.
    274                emberReleaseMessageBuffer(challenge);
   \   00000088   0x7A78             LDRB     R0,[R7, #+9]
   \   0000008A   0x.... 0x....      BL       emReleaseMessageBuffer
    275                challenge = EMBER_NULL_MESSAGE_BUFFER;
   \   0000008E   0x20FF             MOVS     R0,#+255
   \   00000090   0x7278             STRB     R0,[R7, #+9]
    276                status = EMBER_NO_BUFFERS;
   \                     ??bootloadSendAuthChallenge_2:
   \   00000092   0x2418             MOVS     R4,#+24
   \   00000094   0xE00A             B.N      ??bootloadSendAuthChallenge_4
    277              }
    278              else {
    279                // Send the message.
    280                if ( emberSendBootloadMessage(FALSE, sourceEui, message)
    281                   !=EMBER_SUCCESS ) {
   \                     ??bootloadSendAuthChallenge_3:
   \   00000096   0x462A             MOV      R2,R5
   \   00000098   0x4621             MOV      R1,R4
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      BL       emberSendBootloadMessage
   \   000000A0   0x0004             MOVS     R4,R0
   \   000000A2   0xBF18             IT       NE 
   \   000000A4   0x2401             MOVNE    R4,#+1
    282                  status = EMBER_ERR_FATAL;
    283                  bl_print("Error: send auth challenge failed\r\n");
    284                } else {
    285                  status = EMBER_SUCCESS;
    286                }
    287              }
    288            }  
    289          
    290            // Done with buffer.
    291            if (message != EMBER_NULL_MESSAGE_BUFFER) {
    292              emberReleaseMessageBuffer(message);
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0x.... 0x....      BL       emReleaseMessageBuffer
    293            }
    294            
    295            return status;
   \                     ??bootloadSendAuthChallenge_4:
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    296          }
    297          
    298          // A utility function called after a node has received a challenge
    299          // message.  After the target has received a valid response message, it will go
    300          // into bootloader mode.

   \                                 In section .text, align 4, keep-with-next
    301          static EmberStatus bootloadSendAuthResponse(int8u* authenticationBlock,
    302                                               EmberEUI64 targetEui) {
   \                     bootloadSendAuthResponse:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    303            int8u index;
    304            EmberMessageBuffer message;
    305            EmberStatus status;
    306          
    307            index = bootloadMakeHeader(bootloadBuffer, XMODEM_AUTH_RESPONSE);
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable26_1
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x7030             STRB     R0,[R6, #+0]
   \   0000000E   0x2072             MOVS     R0,#+114
   \   00000010   0x7070             STRB     R0,[R6, #+1]
    308            
    309            // AES encrypt the challenge in place to yield the response.
    310            assert(signingKey != EMBER_NULL_MESSAGE_BUFFER);
   \   00000012   0x.... 0x....      LDR.W    R7,??DataTable26
   \   00000016   0x7A38             LDRB     R0,[R7, #+8]
   \   00000018   0x28FF             CMP      R0,#+255
   \   0000001A   0xD106             BNE.N    ??bootloadSendAuthResponse_0
   \   0000001C   0xB507             PUSH {R0,R1,R2,LR}
   \   0000001E   0xF44F 0x719B      MOV      R1,#+310
   \   00000022   0x.... 0x....      ADR.W    R0,`?<Constant "bootload-utils.c">`
   \   00000026   0x.... 0x....      BL       halInternalAssertFailed
    311            emAesEncrypt(authenticationBlock, emberMessageBufferContents(signingKey));
   \                     ??bootloadSendAuthResponse_0:
   \   0000002A   0x7A38             LDRB     R0,[R7, #+8]
   \   0000002C   0x.... 0x....      BL       emberMessageBufferContents
   \   00000030   0x4601             MOV      R1,R0
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       emAesEncrypt
    312            
    313            // The authentication response is the entire bootload payload.
    314            MEMCOPY(&bootloadBuffer[index],authenticationBlock,
    315                    BOOTLOAD_AUTH_RESPONSE_SIZE);
   \   00000038   0x2210             MOVS     R2,#+16
   \   0000003A   0x4621             MOV      R1,R4
   \   0000003C   0x1CB0             ADDS     R0,R6,#+2
   \   0000003E   0x.... 0x....      BL       halCommonMemCopy
    316            index += BOOTLOAD_AUTH_RESPONSE_SIZE;
    317          
    318            // Copy the message into buffers.
    319            message = emberFillLinkedBuffers(bootloadBuffer, index);
   \   00000042   0x2112             MOVS     R1,#+18
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       emberFillLinkedBuffers
   \   0000004A   0x4604             MOV      R4,R0
    320            if (EMBER_NULL_MESSAGE_BUFFER == message) {
   \   0000004C   0x2CFF             CMP      R4,#+255
   \   0000004E   0xBF08             IT       EQ 
   \   00000050   0x2518             MOVEQ    R5,#+24
   \   00000052   0xD00A             BEQ.N    ??bootloadSendAuthResponse_1
    321              // Not enough buffers were available for the message.
    322              // Clean up the challenge.
    323              status = EMBER_NO_BUFFERS;
    324            }
    325            else {
    326              // Send the message.
    327              if (emberSendBootloadMessage(FALSE, targetEui, message) != EMBER_SUCCESS) {
   \   00000054   0x4622             MOV      R2,R4
   \   00000056   0x4629             MOV      R1,R5
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       emberSendBootloadMessage
   \   0000005E   0x0005             MOVS     R5,R0
   \   00000060   0xBF18             IT       NE 
   \   00000062   0x2501             MOVNE    R5,#+1
    328                status = EMBER_ERR_FATAL;
    329                bl_print("Error: send auth response failed\r\n");
    330              } else {
    331                // The challenge was sent successfully.
    332                status = EMBER_SUCCESS;
    333              }
    334            }
    335          
    336            // Done with buffer.
    337            if (message != EMBER_NULL_MESSAGE_BUFFER) {
    338              emberReleaseMessageBuffer(message);
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       emReleaseMessageBuffer
    339            }
    340          
    341            emberReleaseMessageBuffer(signingKey);
   \                     ??bootloadSendAuthResponse_1:
   \   0000006A   0x7A38             LDRB     R0,[R7, #+8]
   \   0000006C   0x.... 0x....      BL       emReleaseMessageBuffer
    342            signingKey = EMBER_NULL_MESSAGE_BUFFER;
   \   00000070   0x20FF             MOVS     R0,#+255
   \   00000072   0x7238             STRB     R0,[R7, #+8]
    343            
    344            return status;
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    345          }
    346          
    347          
    348          // -------------------------------------------------------------------------
    349          // Send bootload query.  The function is called by the source node to get
    350          // necessary information about nodes.

   \                                 In section .text, align 2, keep-with-next
    351          void bootloadUtilSendQuery(EmberEUI64 target)
    352          {
   \                     bootloadUtilSendQuery:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    353            MEMCOPY(targetAddress, target, EUI64_SIZE);
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable26
   \   00000008   0x.... 0x....      BL       ?Subroutine0
    354            if(isTheSameEui64(broadcastEui64, target)) {
   \                     ??CrossCallReturnLabel_1:
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0xF105 0x000C      ADD      R0,R5,#+12
   \   00000012   0x.... 0x....      BL       isTheSameEui64
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xBF14             ITE      NE 
   \   0000001A   0x2101             MOVNE    R1,#+1
   \   0000001C   0x2100             MOVEQ    R1,#+0
    355              sendRadioMessage(XMODEM_QUERY, TRUE);
    356            } else {
    357              sendRadioMessage(XMODEM_QUERY, FALSE);
   \   0000001E   0x2051             MOVS     R0,#+81
   \   00000020   0x.... 0x....      BL       sendRadioMessage
    358            }
    359            blState = BOOTLOAD_STATE_QUERY;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7028             STRB     R0,[R5, #+0]
    360            actionTimer = TIMEOUT_QUERY;
   \   00000028   0x2019             MOVS     R0,#+25
   \   0000002A   0x7168             STRB     R0,[R5, #+5]
    361          }
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x2208             MOVS     R2,#+8
   \   00000002   0x4621             MOV      R1,R4
   \   00000004   0xF105 0x0014      ADD      R0,R5,#+20
   \   00000008   0x.... 0x....      B.W      halCommonMemCopy
    362          
    363          
    364          // -------------------------------------------------------------------------
    365          // Initiate bootloading process with remote node that is already in bootload
    366          // mode.  The function is normally used to perform bootload recovery on the 
    367          // nodes that have failed to bootload.  If failure happens during bootload, 
    368          // the nodes will be in bootload mode and stay on the current channel, if
    369          // it has not been power cycled.

   \                                 In section .text, align 2, keep-with-next
    370          void bootloadUtilStartBootload(EmberEUI64 target, bootloadMode mode)
    371          {
   \                     bootloadUtilStartBootload:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    372          
    373            currentRetriesRemaining = NUM_PKT_RETRIES;
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable26
   \   00000008   0x200A             MOVS     R0,#+10
   \   0000000A   0x70A8             STRB     R0,[R5, #+2]
    374            actionTimer = TIMEOUT_QUERY;
   \   0000000C   0x2019             MOVS     R0,#+25
   \   0000000E   0x7168             STRB     R0,[R5, #+5]
    375            blMode = mode;
   \   00000010   0x7069             STRB     R1,[R5, #+1]
    376          
    377            MEMCOPY(targetAddress, target, EUI64_SIZE);
   \   00000012   0x.... 0x....      BL       ?Subroutine0
    378            if(isTheSameEui64(target, broadcastEui64)) {
   \                     ??CrossCallReturnLabel_0:
   \   00000016   0xF105 0x010C      ADD      R1,R5,#+12
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       isTheSameEui64
   \   00000020   0xB118             CBZ.N    R0,??bootloadUtilStartBootload_0
    379              blState = BOOTLOAD_STATE_START_BROADCAST_BOOTLOAD;
   \   00000022   0x2006             MOVS     R0,#+6
   \   00000024   0x7028             STRB     R0,[R5, #+0]
    380              sendRadioMessage(XMODEM_QUERY, TRUE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xE002             B.N      ??bootloadUtilStartBootload_1
    381            } else {
    382              blState = BOOTLOAD_STATE_START_UNICAST_BOOTLOAD;
   \                     ??bootloadUtilStartBootload_0:
   \   0000002A   0x2005             MOVS     R0,#+5
   \   0000002C   0x7028             STRB     R0,[R5, #+0]
    383              sendRadioMessage(XMODEM_QUERY, FALSE);
   \   0000002E   0x2100             MOVS     R1,#+0
   \                     ??bootloadUtilStartBootload_1:
   \   00000030   0x2051             MOVS     R0,#+81
   \   00000032   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000036   0x....             B.N      sendRadioMessage
    384            }
    385          }
    386          
    387          // -------------------------------------------------------------------------
    388          // Send authentication response to the end device target.  Normally called
    389          // by the parent as part of a process to bootload sleepy or mobile end device.

   \                                 In section .text, align 2, keep-with-next
    390          void bootloadUtilSendAuthResponse(EmberEUI64 target)
    391          {
   \                     bootloadUtilSendAuthResponse:
   \   00000000   0xB510             PUSH     {R4,LR}
    392            // Encrypt the challenge and send the result back as the response.
    393            if (EMBER_SUCCESS == bootloadSendAuthResponse(authBlock, target) ) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable26
   \   00000006   0x4601             MOV      R1,R0
   \   00000008   0xF104 0x001C      ADD      R0,R4,#+28
   \   0000000C   0x.... 0x....      BL       bootloadSendAuthResponse
   \   00000010   0xB918             CBNZ.N   R0,??bootloadUtilSendAuthResponse_0
    394              // Give the target time to reboot into the bootloader,
    395              // then start the bootload process.
    396              blState = BOOTLOAD_STATE_DELAY_BEFORE_START;
   \   00000012   0x2004             MOVS     R0,#+4
    397              actionTimer = TIMEOUT_START;
   \   00000014   0x2119             MOVS     R1,#+25
   \   00000016   0x7161             STRB     R1,[R4, #+5]
   \   00000018   0xE001             B.N      ??bootloadUtilSendAuthResponse_1
    398            }
    399            else {
    400              bl_print("unable to send authentication response\r\n");
    401              // Get out from bootload mode
    402              blState = BOOTLOAD_STATE_NORMAL;
   \                     ??bootloadUtilSendAuthResponse_0:
   \   0000001A   0x2000             MOVS     R0,#+0
    403              blMode = BOOTLOAD_MODE_NONE;
   \   0000001C   0x7060             STRB     R0,[R4, #+1]
   \                     ??bootloadUtilSendAuthResponse_1:
   \   0000001E   0x7020             STRB     R0,[R4, #+0]
    404            }
    405          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    406          
    407          // -------------------------------------------------------------------------
    408          // Bootload State Machine

   \                                 In section .text, align 4, keep-with-next
    409          void bootloadUtilTick(void)
    410          {
   \                     bootloadUtilTick:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
    411            static int16u lastBlinkTime = 0;
    412            int16u time;
    413          
    414            time = halCommonGetInt16uMillisecondTick();
   \   00000002   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
    415          
    416            if ( (int16u)(time - lastBlinkTime) > 200 /*ms*/ ) {
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable26
   \   0000000A   0x8961             LDRH     R1,[R4, #+10]
   \   0000000C   0x1A41             SUBS     R1,R0,R1
   \   0000000E   0xB289             UXTH     R1,R1
   \   00000010   0x29C9             CMP      R1,#+201
   \   00000012   0xD35D             BCC.N    ??bootloadUtilTick_1
    417              lastBlinkTime = time;
   \   00000014   0x8160             STRH     R0,[R4, #+10]
    418                  
    419              if (actionTimer == 0) {
   \   00000016   0x7960             LDRB     R0,[R4, #+5]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD157             BNE.N    ??bootloadUtilTick_2
    420                switch (blState)
   \   0000001C   0x78A2             LDRB     R2,[R4, #+2]
   \   0000001E   0x1E53             SUBS     R3,R2,#+1
   \   00000020   0x7861             LDRB     R1,[R4, #+1]
   \   00000022   0x7826             LDRB     R6,[R4, #+0]
   \   00000024   0x.... 0x....      ADR.W    R0,`?<Constant "bootload-utils.c">`
   \   00000028   0x25FF             MOVS     R5,#+255
   \   0000002A   0x2E0A             CMP      R6,#+10
   \   0000002C   0xD850             BHI.N    ??bootloadUtilTick_1
   \   0000002E   0xE8DF 0xF006      TBB      [PC, R6]
   \                     ??bootloadUtilTick_0:
   \   00000032   0x49 0x27          DC8      0x49,0x27,0x13,0x6
   \              0x13 0x06    
   \   00000036   0x20 0x2A          DC8      0x20,0x2A,0x2A,0x4F
   \              0x2A 0x4F    
   \   0000003A   0x4F 0x35          DC8      0x4F,0x35,0x35,0x0
   \              0x35 0x00    
    421                {  
    422                  case BOOTLOAD_STATE_WAIT_FOR_AUTH_RESPONSE:
    423                    // The authentication response was not received in time.
    424                    // We need to free the challenge buffer.
    425                    bl_print("do not receive auth response\r\n");
    426                    assert(challenge != EMBER_NULL_MESSAGE_BUFFER);
   \                     ??bootloadUtilTick_3:
   \   0000003E   0x7A61             LDRB     R1,[R4, #+9]
   \   00000040   0x29FF             CMP      R1,#+255
   \   00000042   0xD104             BNE.N    ??bootloadUtilTick_4
   \   00000044   0xB507             PUSH {R0,R1,R2,LR}
   \   00000046   0xF44F 0x71D5      MOV      R1,#+426
   \   0000004A   0x.... 0x....      BL       halInternalAssertFailed
    427                    emberReleaseMessageBuffer(challenge);
   \                     ??bootloadUtilTick_4:
   \   0000004E   0x7A60             LDRB     R0,[R4, #+9]
   \   00000050   0x.... 0x....      BL       emReleaseMessageBuffer
    428                    challenge = EMBER_NULL_MESSAGE_BUFFER;
   \   00000054   0x7265             STRB     R5,[R4, #+9]
    429                    // Abort this bootloader session.
    430                    blState = BOOTLOAD_STATE_NORMAL;
   \   00000056   0xE013             B.N      ??bootloadUtilTick_5
    431                    blMode = BOOTLOAD_MODE_NONE;
    432                    break;
    433          #ifndef SBL_LIB_TARGET
    434                  case BOOTLOAD_STATE_WAIT_FOR_AUTH_CHALLENGE:
    435                    // The authentication challenge was not received in time.
    436                    // We need to destroy the AES key.
    437                    bl_print("do not receive auth challenge\r\n");
    438                    assert(signingKey != EMBER_NULL_MESSAGE_BUFFER);
   \                     ??bootloadUtilTick_6:
   \   00000058   0x7A21             LDRB     R1,[R4, #+8]
   \   0000005A   0x29FF             CMP      R1,#+255
   \   0000005C   0xD104             BNE.N    ??bootloadUtilTick_7
   \   0000005E   0xB507             PUSH {R0,R1,R2,LR}
   \   00000060   0xF44F 0x71DB      MOV      R1,#+438
   \   00000064   0x.... 0x....      BL       halInternalAssertFailed
    439                    emberReleaseMessageBuffer(signingKey);
   \                     ??bootloadUtilTick_7:
   \   00000068   0x7A20             LDRB     R0,[R4, #+8]
   \   0000006A   0x.... 0x....      BL       emReleaseMessageBuffer
    440                    signingKey = EMBER_NULL_MESSAGE_BUFFER;
   \   0000006E   0x7225             STRB     R5,[R4, #+8]
    441                    // Abort this bootloader session.
    442                    blState = BOOTLOAD_STATE_NORMAL;
   \   00000070   0xE006             B.N      ??bootloadUtilTick_5
    443                    blMode = BOOTLOAD_MODE_NONE;
    444                    break;
    445                  case BOOTLOAD_STATE_DELAY_BEFORE_START:
    446                    // We have given the target node enough time to launch the bootloader.
    447                    // Now we start the actual bootloader procedure.
    448                    bl_print("start bootload\r\n");
    449                    bl_print("free buffer: %x\r\n", emPacketBufferFreeCount);
    450                    currentRetriesRemaining = NUM_PKT_RETRIES;
   \                     ??bootloadUtilTick_8:
   \   00000072   0x200A             MOVS     R0,#+10
   \   00000074   0x70A0             STRB     R0,[R4, #+2]
    451                    bootloadUtilStartBootload(targetAddress, blMode);
   \   00000076   0xF104 0x0014      ADD      R0,R4,#+20
   \   0000007A   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   0000007E   0x....             B.N      bootloadUtilStartBootload
    452                    break;
    453                  case BOOTLOAD_STATE_QUERY:
    454                    // Stop receiving query response
    455                    blState = BOOTLOAD_STATE_NORMAL;
   \                     ??bootloadUtilTick_5:
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x7020             STRB     R0,[R4, #+0]
    456                    blMode = BOOTLOAD_MODE_NONE;
   \   00000084   0xE020             B.N      ??bootloadUtilTick_9
    457                    break;
    458                  case BOOTLOAD_STATE_START_UNICAST_BOOTLOAD:
    459                  case BOOTLOAD_STATE_START_BROADCAST_BOOTLOAD:
    460                    if (currentRetriesRemaining > 0) {
   \                     ??bootloadUtilTick_10:
   \   00000086   0xB1D2             CBZ.N    R2,??bootloadUtilTick_11
    461                      bl_print("--> start bootload retry\r\n");
    462                      currentRetriesRemaining -= 1;
   \   00000088   0x70A3             STRB     R3,[R4, #+2]
    463                      if(blState == BOOTLOAD_STATE_START_UNICAST_BOOTLOAD) {
   \   0000008A   0x2E05             CMP      R6,#+5
   \   0000008C   0xBF0C             ITE      EQ 
   \   0000008E   0x2100             MOVEQ    R1,#+0
   \   00000090   0x2101             MOVNE    R1,#+1
    464                        sendRadioMessage(XMODEM_QUERY, FALSE);
    465                      } else {
    466                        sendRadioMessage(XMODEM_QUERY, TRUE);
   \   00000092   0x2051             MOVS     R0,#+81
   \   00000094   0x.... 0x....      BL       sendRadioMessage
    467                      }
    468                      actionTimer = TIMEOUT_QUERY;
   \   00000098   0x2019             MOVS     R0,#+25
   \   0000009A   0xE018             B.N      ??bootloadUtilTick_12
    469                    } else {
    470                      blState = BOOTLOAD_STATE_NORMAL;
    471                      bl_print("ERROR: do not see start bootload response\r\n");
    472                    }
    473                    break;
    474                  case BOOTLOAD_STATE_WAIT_FOR_COMPLETE_ACK:
    475                  case BOOTLOAD_STATE_WAIT_FOR_IMAGE_ACK:
    476                    // We didn't get an ack.  Retry (at the application level) in
    477                    // the hopes that it was a temporary problem.
    478                    if (currentRetriesRemaining > 0) {
   \                     ??bootloadUtilTick_13:
   \   0000009C   0xB15A             CBZ.N    R2,??bootloadUtilTick_14
    479                      bl_print("data retry %x\r\n", currentRetriesRemaining);
    480                      currentRetriesRemaining -= 1;
   \   0000009E   0x70A3             STRB     R3,[R4, #+2]
    481                      actionTimer = TIMEOUT_IMAGE_SEND;
   \   000000A0   0x200F             MOVS     R0,#+15
   \   000000A2   0x7160             STRB     R0,[R4, #+5]
    482                      if(blState == BOOTLOAD_STATE_WAIT_FOR_IMAGE_ACK) {
   \   000000A4   0x2E09             CMP      R6,#+9
   \   000000A6   0xBF07             ITTEE    EQ 
   \   000000A8   0x2100             MOVEQ    R1,#+0
   \   000000AA   0x2001             MOVEQ    R0,#+1
   \   000000AC   0x2100             MOVNE    R1,#+0
   \   000000AE   0x2004             MOVNE    R0,#+4
    483                        sendMACImageSegment();
    484                      } else {
    485                        sendMACCompleteSegment();
   \   000000B0   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   000000B4   0x....             B.N      sendRadioMessage
    486                      }
    487                    } else {
    488                      // If the source node doesn't get the ack from the target node in
    489                      // respond to its EOT packet, the source node will retry for
    490                      // NUM_PKT_RETRIES times.  If all retries fail, it will still 
    491                      // consider the bootloading to be completed and ask the user to go
    492                      // check the target node to verify that the application is loaded
    493                      // ok.  
    494                      if(blState == BOOTLOAD_STATE_WAIT_FOR_COMPLETE_ACK) {
   \                     ??bootloadUtilTick_14:
   \   000000B6   0x2E0A             CMP      R6,#+10
   \   000000B8   0xBF08             IT       EQ 
   \   000000BA   0x200B             MOVEQ    R0,#+11
    495                        bl_print("Send end of transmissiton to target node\r\n");
    496                        bl_print("Please check target node if the app is loaded successfully\r\n");
    497                        blState = BOOTLOAD_STATE_DONE;
   \   000000BC   0xD000             BEQ.N    ??bootloadUtilTick_15
    498                      } else {
    499                        blState = BOOTLOAD_STATE_NORMAL;
   \                     ??bootloadUtilTick_11:
   \   000000BE   0x2000             MOVS     R0,#+0
   \                     ??bootloadUtilTick_15:
   \   000000C0   0x7020             STRB     R0,[R4, #+0]
   \   000000C2   0xBD73             POP      {R0,R1,R4-R6,PC}
    500                      }
    501                    }
    502                    break;
    503          #endif // SBL_LIB_TARGET
    504                  case BOOTLOAD_STATE_NORMAL:
    505                    if(blMode != BOOTLOAD_MODE_NONE) {
   \                     ??bootloadUtilTick_16:
   \   000000C4   0xB121             CBZ.N    R1,??bootloadUtilTick_1
    506                      bl_print("ERROR: do not get response from target node\r\n");
    507                      blMode = BOOTLOAD_MODE_NONE;
   \   000000C6   0x2000             MOVS     R0,#+0
   \                     ??bootloadUtilTick_9:
   \   000000C8   0x7060             STRB     R0,[R4, #+1]
   \   000000CA   0xBD73             POP      {R0,R1,R4-R6,PC}
    508                    }
    509                  default:
    510                    break;
    511                  }
    512                } else {
    513                  actionTimer -= 1;
   \                     ??bootloadUtilTick_2:
   \   000000CC   0x1E40             SUBS     R0,R0,#+1
   \                     ??bootloadUtilTick_12:
   \   000000CE   0x7160             STRB     R0,[R4, #+5]
    514                }
    515            } //end check time
    516          }
   \                     ??bootloadUtilTick_1:
   \   000000D0   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .data, align 4
   \                     blState:
   \   00000000   0x00               DC8 0
   \                     blMode:
   \   00000001   0x00               DC8 0
   \                     currentRetriesRemaining:
   \   00000002   0x00               DC8 0
   \                     expectedBlockNumber:
   \   00000003   0x01               DC8 1
   \                     currentOTABlock:
   \   00000004   0x00               DC8 0
   \                     actionTimer:
   \   00000005   0x00               DC8 0
   \                     appSerial:
   \   00000006   0x00               DC8 0
   \                     bootloadSerial:
   \   00000007   0x01               DC8 1
   \   00000008   0xFF               DC8 255
   \   00000009   0xFF               DC8 255
   \   0000000A   0x0000             DC16 0
   \                     broadcastEui64:
   \   0000000C   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \                     targetAddress:
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     authBlock:
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     flashStreamCrc:
   \   00000000   0xFFFFFFFF         DC32 4294967295
    517          
    518          // ****************************************************************
    519          // Handlers and function callback
    520          // ****************************************************************
    521          

   \                                 In section .text, align 4, keep-with-next
    522          void emberIncomingBootloadMessageHandler(EmberEUI64 longId, 
    523                                                   EmberMessageBuffer message)
    524          {
   \                     emberIncomingBootloadMessageHandler:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08F             SUB      SP,SP,#+60
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x460E             MOV      R6,R1
    525            int8u type;
    526            int16u mfgId;  
    527          #ifndef SBL_LIB_TARGET
    528            int8u block;
    529            int8u hardwareTag[BOOTLOAD_HARDWARE_TAG_SIZE];
    530            int8s rssi;
    531            int8u length;
    532            int16u blVersion;
    533          #endif // SBL_LIB_TARGET
    534            
    535            type = emberGetLinkedBuffersByte(message, OFFSET_MESSAGE_TYPE);
    536            switch(type) {
   \   0000000A   0x.... 0x....      ADR.W    R7,`?<Constant "Please start .ebl upl...">`
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable26
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_21:
   \   00000018   0x2806             CMP      R0,#+6
   \   0000001A   0xF000 0x8103      BEQ.W    ??emberIncomingBootloadMessageHandler_0
   \   0000001E   0x2815             CMP      R0,#+21
   \   00000020   0xF000 0x8112      BEQ.W    ??emberIncomingBootloadMessageHandler_1
   \   00000024   0x284C             CMP      R0,#+76
   \   00000026   0xD009             BEQ.N    ??emberIncomingBootloadMessageHandler_2
   \   00000028   0x2851             CMP      R0,#+81
   \   0000002A   0xD05E             BEQ.N    ??emberIncomingBootloadMessageHandler_3
   \   0000002C   0x2852             CMP      R0,#+82
   \   0000002E   0xF000 0x808E      BEQ.W    ??emberIncomingBootloadMessageHandler_4
   \   00000032   0x2863             CMP      R0,#+99
   \   00000034   0xD065             BEQ.N    ??emberIncomingBootloadMessageHandler_5
   \   00000036   0x2872             CMP      R0,#+114
   \   00000038   0xD023             BEQ.N    ??emberIncomingBootloadMessageHandler_6
   \                     ??emberIncomingBootloadMessageHandler_7:
   \   0000003A   0xE12E             B.N      ??CrossCallReturnLabel_39
    537              case XMODEM_LAUNCH_REQUEST:
    538                {
    539                  int8u hardwareTag[BOOTLOAD_HARDWARE_TAG_SIZE];
    540                  // Extract the manufacturer Id (transmitted low byte first).
    541                  mfgId = HIGH_LOW_TO_INT(emberGetLinkedBuffersByte(message,OFFSET_MFG_ID+1),
    542                                          emberGetLinkedBuffersByte(message,OFFSET_MFG_ID));
   \                     ??emberIncomingBootloadMessageHandler_2:
   \   0000003C   0x2103             MOVS     R1,#+3
   \   0000003E   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_20:
   \   00000042   0x4607             MOV      R7,R0
   \   00000044   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_26:
   \   00000048   0x4604             MOV      R4,R0
    543                  // Extract the hardware tag.
    544                  emberCopyFromLinkedBuffers(message,
    545                                             OFFSET_HARDWARE_TAG,
    546                                             hardwareTag,
    547                                             BOOTLOAD_HARDWARE_TAG_SIZE);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0x2310             MOVS     R3,#+16
   \   00000050   0x2204             MOVS     R2,#+4
   \   00000052   0x4631             MOV      R1,R6
   \   00000054   0xA801             ADD      R0,SP,#+4
   \   00000056   0x.... 0x....      BL       emReallyCopyToLinkedBuffers
    548                  if (bootloadUtilLaunchRequestHandler(mfgId,hardwareTag,longId)) {
   \   0000005A   0x4642             MOV      R2,R8
   \   0000005C   0xA901             ADD      R1,SP,#+4
   \   0000005E   0xEB04 0x2007      ADD      R0,R4,R7, LSL #+8
   \   00000062   0xB280             UXTH     R0,R0
   \   00000064   0x.... 0x....      BL       bootloadUtilLaunchRequestHandler
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xF000 0x80F8      BEQ.W    ??emberIncomingBootloadMessageHandler_8
    549                    // The application has agreed to launch the bootloader.
    550                    // Authenticate the requesting node before launching the bootloader.
    551                    if (EMBER_SUCCESS == bootloadSendAuthChallenge(longId) ) {
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x.... 0x....      BL       bootloadSendAuthChallenge
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xF040 0x80F2      BNE.W    ??emberIncomingBootloadMessageHandler_8
    552                      // The challenge was sent successfully.
    553                      blState = BOOTLOAD_STATE_WAIT_FOR_AUTH_RESPONSE;
   \   0000007A   0x2003             MOVS     R0,#+3
   \   0000007C   0x7028             STRB     R0,[R5, #+0]
    554                      actionTimer = TIMEOUT_AUTH_RESPONSE;
   \   0000007E   0x200F             MOVS     R0,#+15
   \   00000080   0xE063             B.N      ??emberIncomingBootloadMessageHandler_9
    555                    }
    556                    else {
    557                      bl_print("unable to send authentication challenge\r\n");
    558                      // Abort bootload session.
    559                      blState = BOOTLOAD_STATE_NORMAL;
    560                      blMode = BOOTLOAD_MODE_NONE;
    561                    }
    562                  }
    563                  else {
    564                    bl_print("application refused to launch bootloader\r\n");
    565                    // Abort bootload session.
    566                    blState = BOOTLOAD_STATE_NORMAL;
    567                    blMode = BOOTLOAD_MODE_NONE;
    568                  }
    569                }
    570                break;
    571          
    572              case XMODEM_AUTH_RESPONSE:
    573                if (BOOTLOAD_STATE_WAIT_FOR_AUTH_RESPONSE == blState) {
   \                     ??emberIncomingBootloadMessageHandler_6:
   \   00000082   0x7828             LDRB     R0,[R5, #+0]
   \   00000084   0x2803             CMP      R0,#+3
   \   00000086   0xD1D8             BNE.N    ??emberIncomingBootloadMessageHandler_7
    574                  int8u response[BOOTLOAD_AUTH_RESPONSE_SIZE];
    575                  int8u *challengePtr;
    576                  tokTypeMfgBootloadAesKey verificationKey;
    577          
    578                  // Extract the response.
    579                  emberCopyFromLinkedBuffers(message,
    580                                             OFFSET_AUTH_RESPONSE,
    581                                             response,
    582                                             BOOTLOAD_AUTH_RESPONSE_SIZE);
   \   00000088   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_8:
   \   0000008C   0xA806             ADD      R0,SP,#+24
   \   0000008E   0x.... 0x....      BL       emReallyCopyToLinkedBuffers
    583          
    584                  // Load the secret key to verify the response.
    585                  halCommonGetToken(&verificationKey, TOKEN_MFG_BOOTLOAD_AES_KEY);
   \   00000092   0x2310             MOVS     R3,#+16
   \   00000094   0x227F             MOVS     R2,#+127
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   0000009A   0x8801             LDRH     R1,[R0, #+0]
   \   0000009C   0xA801             ADD      R0,SP,#+4
   \   0000009E   0x.... 0x....      BL       halInternalGetTokenData
    586          
    587                  // Encrypt the challenge.
    588                  assert(challenge != EMBER_NULL_MESSAGE_BUFFER);
   \   000000A2   0x7A68             LDRB     R0,[R5, #+9]
   \   000000A4   0x28FF             CMP      R0,#+255
   \   000000A6   0xD106             BNE.N    ??emberIncomingBootloadMessageHandler_10
   \   000000A8   0xB507             PUSH {R0,R1,R2,LR}
   \   000000AA   0xF44F 0x7113      MOV      R1,#+588
   \   000000AE   0x.... 0x....      ADR.W    R0,`?<Constant "bootload-utils.c">`
   \   000000B2   0x.... 0x....      BL       halInternalAssertFailed
    589                  challengePtr = emberMessageBufferContents(challenge);
   \                     ??emberIncomingBootloadMessageHandler_10:
   \   000000B6   0x7A68             LDRB     R0,[R5, #+9]
   \   000000B8   0x.... 0x....      BL       emberMessageBufferContents
   \   000000BC   0x4604             MOV      R4,R0
    590                  emAesEncrypt(challengePtr, (int8u*)verificationKey);
   \   000000BE   0xA901             ADD      R1,SP,#+4
   \   000000C0   0x.... 0x....      BL       emAesEncrypt
    591                  
    592                  // Compare the response to the encrypted challenge.
    593                  if (!MEMCOMPARE(response,challengePtr,BOOTLOAD_AUTH_COMMON_SIZE) ) {
   \   000000C4   0x2210             MOVS     R2,#+16
   \   000000C6   0x4621             MOV      R1,R4
   \   000000C8   0xA806             ADD      R0,SP,#+24
   \   000000CA   0x.... 0x....      BL       halCommonMemCompare
   \   000000CE   0xB918             CBNZ.N   R0,??emberIncomingBootloadMessageHandler_11
    594                    // The response and the encrypted challenge match.
    595                    // Launch the bootloader.
    596                    // Would release the challenge buffer, but we are about to reboot.
    597                    // emberReleaseMessageBuffer(challenge);
    598                    // challenge = EMBER_NULL_MESSAGE_BUFFER;
    599                    bl_print("Handshake Complete\r\n");
    600                    halLaunchStandaloneBootloader(STANDALONE_BOOTLOADER_NORMAL_MODE);
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0x.... 0x....      BL       halLaunchStandaloneBootloader
   \   000000D6   0xE0E0             B.N      ??CrossCallReturnLabel_39
    601                  }
    602                  else {
    603                    // The response and the encrypted challenge do not match.
    604                    bl_print("authentication failed.\r\n");
    605                    // Get out from bootload mode
    606                    blState = BOOTLOAD_STATE_NORMAL;
   \                     ??emberIncomingBootloadMessageHandler_11:
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x7028             STRB     R0,[R5, #+0]
    607                    blMode = BOOTLOAD_MODE_NONE;
   \   000000DC   0x7068             STRB     R0,[R5, #+1]
    608                    emberReleaseMessageBuffer(challenge);
   \   000000DE   0x7A68             LDRB     R0,[R5, #+9]
   \   000000E0   0x.... 0x....      BL       emReleaseMessageBuffer
    609                    challenge = EMBER_NULL_MESSAGE_BUFFER;
   \   000000E4   0x20FF             MOVS     R0,#+255
   \   000000E6   0x7268             STRB     R0,[R5, #+9]
   \                     ??emberIncomingBootloadMessageHandler_12:
   \   000000E8   0xE0D7             B.N      ??CrossCallReturnLabel_39
    610                  }
    611                }
    612                break;
    613              case XMODEM_QUERY:
    614                  // Record the address of the node that sent this query message.
    615                  // Note that the targetAddress variable is used to store the destination
    616                  // address in this case, not the address of the actual bootload
    617                  // target node.
    618                  if (!IS_BOOTLOADING) {
   \                     ??emberIncomingBootloadMessageHandler_3:
   \   000000EA   0x7828             LDRB     R0,[R5, #+0]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xBF18             IT       NE 
   \   000000F0   0x280B             CMPNE    R0,#+11
   \   000000F2   0xD1F9             BNE.N    ??emberIncomingBootloadMessageHandler_12
    619                    MEMCOPY(targetAddress, longId, EUI64_SIZE);
   \   000000F4   0x.... 0x....      BL       ?Subroutine1
    620                    sendRadioMessage(XMODEM_QRESP, FALSE);
   \                     ??CrossCallReturnLabel_3:
   \   000000F8   0x2100             MOVS     R1,#+0
   \   000000FA   0x2052             MOVS     R0,#+82
   \   000000FC   0x.... 0x....      BL       sendRadioMessage
    621                    bl_print("rx neighbor query\r\n");
   \                     ??emberIncomingBootloadMessageHandler_13:
   \   00000100   0xE0CB             B.N      ??CrossCallReturnLabel_39
    622                  }
    623                break;
    624          
    625          #ifndef SBL_LIB_TARGET    
    626              case XMODEM_AUTH_CHALLENGE:
    627                if (BOOTLOAD_STATE_WAIT_FOR_AUTH_CHALLENGE == blState) {
   \                     ??emberIncomingBootloadMessageHandler_5:
   \   00000102   0x7828             LDRB     R0,[R5, #+0]
   \   00000104   0x2802             CMP      R0,#+2
   \   00000106   0xD1FB             BNE.N    ??emberIncomingBootloadMessageHandler_13
    628                  // Extract the challenge.
    629                  emberCopyFromLinkedBuffers(message,
    630                                             OFFSET_AUTH_CHALLENGE,
    631                                             authBlock,
    632                                             BOOTLOAD_AUTH_CHALLENGE_SIZE);
   \   00000108   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_9:
   \   0000010C   0xF105 0x001C      ADD      R0,R5,#+28
   \   00000110   0x.... 0x....      BL       emReallyCopyToLinkedBuffers
    633          
    634                  // If dealing with non-sleepy node (ex. router), then the library
    635                  // will send authentication response message directly.
    636                  if(!isSleepy(longId)) {
   \   00000114   0x2600             MOVS     R6,#+0
   \                     ??emberIncomingBootloadMessageHandler_14:
   \   00000116   0xAA00             ADD      R2,SP,#+0
   \   00000118   0xA901             ADD      R1,SP,#+4
   \   0000011A   0x4630             MOV      R0,R6
   \   0000011C   0x.... 0x....      BL       emberGetChildData
   \   00000120   0xB928             CBNZ.N   R0,??emberIncomingBootloadMessageHandler_15
   \   00000122   0x2208             MOVS     R2,#+8
   \   00000124   0xA901             ADD      R1,SP,#+4
   \   00000126   0x4640             MOV      R0,R8
   \   00000128   0x.... 0x....      BL       halCommonMemCompare
   \   0000012C   0xB150             CBZ.N    R0,??emberIncomingBootloadMessageHandler_16
   \                     ??emberIncomingBootloadMessageHandler_15:
   \   0000012E   0x1C76             ADDS     R6,R6,#+1
   \   00000130   0xB2F6             UXTB     R6,R6
   \   00000132   0x2E06             CMP      R6,#+6
   \   00000134   0xD3EF             BCC.N    ??emberIncomingBootloadMessageHandler_14
    637                    // Encrypt the challenge and send the result back as the response.
    638                    if (EMBER_SUCCESS == bootloadSendAuthResponse(authBlock, longId) ) {
   \   00000136   0x4641             MOV      R1,R8
   \   00000138   0xF105 0x001C      ADD      R0,R5,#+28
   \   0000013C   0x.... 0x....      BL       bootloadSendAuthResponse
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD128             BNE.N    ??emberIncomingBootloadMessageHandler_17
    639                      // Give the target time to reboot into the bootloader,
    640                      // then start the bootload process.
    641                      blState = BOOTLOAD_STATE_DELAY_BEFORE_START;
    642                      actionTimer = TIMEOUT_START;
    643                    }
    644                    else {
    645                      bl_print("unable to send authentication response\r\n");
    646                      // Get out from bootload mode
    647                      blState = BOOTLOAD_STATE_NORMAL;
    648                      blMode = BOOTLOAD_MODE_NONE;
    649                    }
    650                  } else {
    651                    // If dealing with end device node that can go to sleep during
    652                    // the bootload security handshake process, then we want the
    653                    // application to send authentication response message as JIT
    654                    // message to guarantee that the end device target will get the 
    655                    // message.
    656          
    657                    // Give the target time to reboot into the bootloader,
    658                    // then start the bootload process.
    659                    blState = BOOTLOAD_STATE_DELAY_BEFORE_START;
   \                     ??emberIncomingBootloadMessageHandler_16:
   \   00000144   0x2004             MOVS     R0,#+4
   \   00000146   0x7028             STRB     R0,[R5, #+0]
    660                    actionTimer = TIMEOUT_START;
   \   00000148   0x2019             MOVS     R0,#+25
   \                     ??emberIncomingBootloadMessageHandler_9:
   \   0000014A   0x7168             STRB     R0,[R5, #+5]
   \                     ??emberIncomingBootloadMessageHandler_18:
   \   0000014C   0xE0A5             B.N      ??CrossCallReturnLabel_39
    661                  }
    662                }
    663                break;
    664          
    665              case XMODEM_QRESP:
    666                // only when we start bootload process
    667                debug("blState 0x%x\r\n", blState);
   \                     ??emberIncomingBootloadMessageHandler_4:
   \   0000014E   0x782A             LDRB     R2,[R5, #+0]
   \   00000150   0x.... 0x....      ADR.W    R1,`?<Constant "blState 0x%x\\r\\n">`
   \   00000154   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_36:
   \   00000158   0x.... 0x....      BL       ?Subroutine8
    668                if((blState == BOOTLOAD_STATE_START_UNICAST_BOOTLOAD) || 
    669                    (blState == BOOTLOAD_STATE_START_BROADCAST_BOOTLOAD)) {
   \                     ??CrossCallReturnLabel_40:
   \   0000015C   0x7828             LDRB     R0,[R5, #+0]
   \   0000015E   0x2805             CMP      R0,#+5
   \   00000160   0xD015             BEQ.N    ??emberIncomingBootloadMessageHandler_19
   \   00000162   0x2806             CMP      R0,#+6
   \   00000164   0xD118             BNE.N    ??emberIncomingBootloadMessageHandler_20
    670                  if(blState == BOOTLOAD_STATE_START_UNICAST_BOOTLOAD) {
    671                    // Check if it's the address of the target node that
    672                    // we intend to bootload
    673                    if(!isTheSameEui64(targetAddress, longId)) {
    674                      bl_print("bootload message from unknown node\r\n");
    675                      // Get out from bootload mode
    676                      blState = BOOTLOAD_STATE_NORMAL;
    677                      blMode = BOOTLOAD_MODE_NONE;
    678                      return; 
    679                    }
    680                  } else { 
    681                    // save the address of the node to be bootloaded
    682                    MEMCOPY(targetAddress, longId, EUI64_SIZE);
   \   00000166   0x.... 0x....      BL       ?Subroutine1
    683                  }
    684                  // Check if protocol version is valid
    685                  if ((emberGetLinkedBuffersByte(message, OFFSET_VERSION) 
    686                    != BOOTLOAD_PROTOCOL_VERSION))
   \                     ??CrossCallReturnLabel_2:
   \   0000016A   0x2100             MOVS     R1,#+0
   \   0000016C   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_19:
   \   00000170   0x2801             CMP      R0,#+1
   \   00000172   0xD1EB             BNE.N    ??emberIncomingBootloadMessageHandler_18
    687                   {
    688                    bl_print("RX bad packet, invalid protocl version\r\n");
    689                    return;
    690                  }
    691                  
    692                  // Check if the remote node is in bootload mode
    693                  if (!emberGetLinkedBuffersByte(message, QRESP_OFFSET_BL_ACTIVE)) {
   \   00000174   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_25:
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD0E7             BEQ.N    ??emberIncomingBootloadMessageHandler_18
    694                    bl_print("Error: remote node not in bootload mode\r\n");
    695                    return;
    696                  }
    697                  bl_print("RX QUERY RESP from ");
    698                  printEui(longId);
    699                  if(emberGetLastHopRssi(&rssi) == EMBER_SUCCESS) {
   \   0000017C   0xA805             ADD      R0,SP,#+20
   \   0000017E   0x.... 0x....      BL       emberGetLastHopRssi
    700                    bl_print(" with rssiValue %d\r\n", rssi);
    701                  } else {
    702                    bl_print(" with rssiValue unknown\r\n", rssi);
    703                  }
    704                  // Initiate xmodem transfer with the host PC for passthru 
    705                  if(blMode == BOOTLOAD_MODE_PASSTHRU) {
   \   00000182   0x7868             LDRB     R0,[R5, #+1]
   \   00000184   0x2801             CMP      R0,#+1
   \   00000186   0xD1E1             BNE.N    ??emberIncomingBootloadMessageHandler_18
    706                    blState = BOOTLOAD_STATE_SENDING_IMAGE;
   \   00000188   0x2008             MOVS     R0,#+8
   \   0000018A   0x7028             STRB     R0,[R5, #+0]
    707                    emberSerialPrintf(appSerial, 
    708                      "Please start .ebl upload image ...\r\n");
   \   0000018C   0xE078             B.N      ??emberIncomingBootloadMessageHandler_21
    709                    xmodemReceiveAndForward();
    710                  } 
   \                     ??emberIncomingBootloadMessageHandler_19:
   \   0000018E   0x.... 0x....      BL       ?Subroutine6
    711                } else if(blState == BOOTLOAD_STATE_QUERY) {
   \                     ??CrossCallReturnLabel_32:
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD1E9             BNE.N    ??CrossCallReturnLabel_2
   \                     ??emberIncomingBootloadMessageHandler_17:
   \   00000196   0xE062             B.N      ??emberIncomingBootloadMessageHandler_8
   \                     ??emberIncomingBootloadMessageHandler_20:
   \   00000198   0x2801             CMP      R0,#+1
   \   0000019A   0xD1D7             BNE.N    ??emberIncomingBootloadMessageHandler_18
    712                  // Extract manufacturer id and hardware tag   
    713                  mfgId = HIGH_LOW_TO_INT(
    714                            emberGetLinkedBuffersByte(message,QRESP_OFFSET_MFG_ID+1),
    715                            emberGetLinkedBuffersByte(message,QRESP_OFFSET_MFG_ID));
   \   0000019C   0x2104             MOVS     R1,#+4
   \   0000019E   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_18:
   \   000001A2   0x4605             MOV      R5,R0
   \   000001A4   0x2103             MOVS     R1,#+3
   \   000001A6   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_17:
   \   000001AA   0xEB00 0x2505      ADD      R5,R0,R5, LSL #+8
    716                  emberCopyFromLinkedBuffers(message,
    717                                             QRESP_OFFSET_HARDWARE_TAG,
    718                                             hardwareTag,
    719                                             BOOTLOAD_HARDWARE_TAG_SIZE);
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0x9000             STR      R0,[SP, #+0]
   \   000001B2   0x2310             MOVS     R3,#+16
   \   000001B4   0x2205             MOVS     R2,#+5
   \   000001B6   0x4631             MOV      R1,R6
   \   000001B8   0xA80A             ADD      R0,SP,#+40
   \   000001BA   0x.... 0x....      BL       emReallyCopyToLinkedBuffers
    720                  
    721                  length = emberMessageBufferLength(message);
    722                  if (length >= (QRESP_OFFSET_BL_VERSION + 1)) {
   \   000001BE   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \   000001C2   0x6800             LDR      R0,[R0, #+0]
   \   000001C4   0x5C30             LDRB     R0,[R6, R0]
   \   000001C6   0x281A             CMP      R0,#+26
   \   000001C8   0xD309             BCC.N    ??emberIncomingBootloadMessageHandler_22
    723                    blVersion = HIGH_LOW_TO_INT(
    724                            emberGetLinkedBuffersByte(message,QRESP_OFFSET_BL_VERSION),
    725                            emberGetLinkedBuffersByte(message,QRESP_OFFSET_BL_VERSION+1));
   \   000001CA   0x2119             MOVS     R1,#+25
   \   000001CC   0x.... 0x....      BL       ??Subroutine4_0
    726                  } else {
   \                     ??CrossCallReturnLabel_16:
   \   000001D0   0x4607             MOV      R7,R0
   \   000001D2   0x211A             MOVS     R1,#+26
   \   000001D4   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_15:
   \   000001D8   0xEB00 0x2707      ADD      R7,R0,R7, LSL #+8
   \   000001DC   0xE001             B.N      ??emberIncomingBootloadMessageHandler_23
    727                    blVersion = 0xFFFF;  // if the version is invalid, the value is 0xFFFF
   \                     ??emberIncomingBootloadMessageHandler_22:
   \   000001DE   0xF64F 0x77FF      MOVW     R7,#+65535
    728                  }
    729                  // This is a result of issuing 'query_neighbor' command.
    730                  // Notify the application of the query response received so the 
    731                  // application can make decision on whether or who to bootload.
    732                  bootloadUtilQueryResponseHandler(
    733                    emberGetLinkedBuffersByte(message,QRESP_OFFSET_BL_ACTIVE),
    734                    mfgId,         
    735                    hardwareTag,
    736                    longId, // eui of the node that sent it.
    737                    emberGetLinkedBuffersByte(message,QRESP_OFFSET_BL_CAPS),
    738                    emberGetLinkedBuffersByte(message,QRESP_OFFSET_PLATFORM),
    739                    emberGetLinkedBuffersByte(message,QRESP_OFFSET_MICRO),
    740                    emberGetLinkedBuffersByte(message,QRESP_OFFSET_PHY),
    741                    blVersion);
   \                     ??emberIncomingBootloadMessageHandler_23:
   \   000001E2   0x2118             MOVS     R1,#+24
   \   000001E4   0x.... 0x....      BL       ??Subroutine4_0
    742                }
   \                     ??CrossCallReturnLabel_14:
   \   000001E8   0x4604             MOV      R4,R0
   \   000001EA   0x2117             MOVS     R1,#+23
   \   000001EC   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_13:
   \   000001F0   0x4681             MOV      R9,R0
   \   000001F2   0x2116             MOVS     R1,#+22
   \   000001F4   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_12:
   \   000001F8   0x4682             MOV      R10,R0
   \   000001FA   0x2115             MOVS     R1,#+21
   \   000001FC   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_11:
   \   00000200   0x4683             MOV      R11,R0
   \   00000202   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_24:
   \   00000206   0xB2BF             UXTH     R7,R7
   \   00000208   0x9704             STR      R7,[SP, #+16]
   \   0000020A   0x9403             STR      R4,[SP, #+12]
   \   0000020C   0xF8CD 0x9008      STR      R9,[SP, #+8]
   \   00000210   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \   00000214   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \   00000218   0x4643             MOV      R3,R8
   \   0000021A   0xAA0A             ADD      R2,SP,#+40
   \   0000021C   0xB2A9             UXTH     R1,R5
   \   0000021E   0x.... 0x....      BL       bootloadUtilQueryResponseHandler
   \   00000222   0xE03A             B.N      ??CrossCallReturnLabel_39
    743                // else ignore the query response
    744                else
    745                  bl_print("Ignored QRESP, blState 0x%x\r\n", blState);
    746                break;
    747              case XMODEM_ACK:
    748                // Check if it's the expected block number.  If so, continue with the
    749                // image sending.  If not, ignore the duplicate.
    750                block = emberGetLinkedBuffersByte(message, OFFSET_BLOCK_NUMBER);
   \                     ??emberIncomingBootloadMessageHandler_0:
   \   00000224   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_23:
   \   00000228   0x4602             MOV      R2,R0
   \   0000022A   0x7928             LDRB     R0,[R5, #+4]
   \   0000022C   0x7829             LDRB     R1,[R5, #+0]
   \   0000022E   0x2909             CMP      R1,#+9
   \   00000230   0xD103             BNE.N    ??emberIncomingBootloadMessageHandler_24
    751                if(blState == BOOTLOAD_STATE_WAIT_FOR_IMAGE_ACK) {
    752                  if(block == currentOTABlock) {
   \   00000232   0x4282             CMP      R2,R0
   \   00000234   0xD131             BNE.N    ??CrossCallReturnLabel_39
    753                    blState = BOOTLOAD_STATE_SENDING_IMAGE;
   \   00000236   0x2008             MOVS     R0,#+8
   \   00000238   0xE004             B.N      ??emberIncomingBootloadMessageHandler_25
    754                  }
    755                } else if(blState == BOOTLOAD_STATE_WAIT_FOR_COMPLETE_ACK) {
   \                     ??emberIncomingBootloadMessageHandler_24:
   \   0000023A   0x290A             CMP      R1,#+10
   \   0000023C   0xBF08             IT       EQ 
   \   0000023E   0x4282             CMPEQ    R2,R0
    756                   if(block == currentOTABlock) {
   \   00000240   0xD12B             BNE.N    ??CrossCallReturnLabel_39
    757                     blState = BOOTLOAD_STATE_DONE;
   \   00000242   0x200B             MOVS     R0,#+11
   \                     ??emberIncomingBootloadMessageHandler_25:
   \   00000244   0x7028             STRB     R0,[R5, #+0]
   \   00000246   0xE028             B.N      ??CrossCallReturnLabel_39
    758                   }
    759                   bl_print("RX EOT ACK seq %x, expected seq %x\r\n", 
    760                              block, currentOTABlock);
    761                }
    762                break;
    763              case XMODEM_NAK:
    764                block = emberGetLinkedBuffersByte(message, OFFSET_BLOCK_NUMBER);
   \                     ??emberIncomingBootloadMessageHandler_1:
   \   00000248   0x.... 0x....      BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_22:
   \   0000024C   0x4602             MOV      R2,R0
    765                // This allows unicast recovery of node.  If the target node is in 
    766                // default recovery mode, it first needs to hear a broadcast query 
    767                // packet from the source node (ex. using "query_neighbor" cmd) in order
    768                // to extract source node's eui64 and pan id.  Then the source node
    769                // can send unicast recovery packet to recover the target node.  The
    770                // target node would actually send a nack to the (redundant) query 
    771                // packet which the source will ignore if the block number is one which
    772                // indicates that the taget node is expecting data packet with block
    773                // number one.
    774                if(blState == BOOTLOAD_STATE_START_UNICAST_BOOTLOAD &&
    775                   block == 1) {
   \   0000024E   0x7828             LDRB     R0,[R5, #+0]
   \   00000250   0x2805             CMP      R0,#+5
   \   00000252   0xBF08             IT       EQ 
   \   00000254   0x2A01             CMPEQ    R2,#+1
   \   00000256   0xD11A             BNE.N    ??emberIncomingBootloadMessageHandler_26
    776                  // Check if it's the address of the target node that
    777                  // we intend to bootload
    778                  if(!isTheSameEui64(targetAddress, longId)) {
   \   00000258   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_31:
   \   0000025C   0xB918             CBNZ.N   R0,??emberIncomingBootloadMessageHandler_27
    779                    bl_print("bootload message from unknown node\r\n");
    780                    // Get out from bootload mode
    781                    blState = BOOTLOAD_STATE_NORMAL;
   \                     ??emberIncomingBootloadMessageHandler_8:
   \   0000025E   0x2000             MOVS     R0,#+0
   \   00000260   0x7028             STRB     R0,[R5, #+0]
    782                    blMode = BOOTLOAD_MODE_NONE;
   \   00000262   0x7068             STRB     R0,[R5, #+1]
    783                    return; 
   \   00000264   0xE019             B.N      ??CrossCallReturnLabel_39
    784                  }
    785                  
    786                  // Check if protocol version is valid
    787                  if ((emberGetLinkedBuffersByte(message, OFFSET_VERSION) 
    788                    != BOOTLOAD_PROTOCOL_VERSION))
   \                     ??emberIncomingBootloadMessageHandler_27:
   \   00000266   0x2100             MOVS     R1,#+0
   \   00000268   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_10:
   \   0000026C   0x2801             CMP      R0,#+1
   \   0000026E   0xD114             BNE.N    ??CrossCallReturnLabel_39
    789                   {
    790                    bl_print("RX bad packet, invalid protocl version\r\n");
    791                    return;
    792                  }
    793                  
    794                  bl_print("RX QUERY RESP from ");
    795                  printEui(longId);
    796                  if(emberGetLastHopRssi(&rssi) == EMBER_SUCCESS) {
   \   00000270   0xA805             ADD      R0,SP,#+20
   \   00000272   0x.... 0x....      BL       emberGetLastHopRssi
    797                    bl_print(" with rssiValue %d\r\n", rssi);
    798                  } else {
    799                    bl_print(" with rssiValue unknown\r\n", rssi);
    800                  }
    801                  // Initiate xmodem transfer with the host PC for passthru 
    802                  blState = BOOTLOAD_STATE_SENDING_IMAGE;
   \   00000276   0x2008             MOVS     R0,#+8
   \   00000278   0x7028             STRB     R0,[R5, #+0]
    803                  if(blMode == BOOTLOAD_MODE_PASSTHRU) {
   \   0000027A   0x7868             LDRB     R0,[R5, #+1]
   \   0000027C   0x2801             CMP      R0,#+1
   \   0000027E   0xD10C             BNE.N    ??CrossCallReturnLabel_39
    804                    emberSerialPrintf(appSerial, 
    805                      "Please start .ebl upload image ...\r\n");
   \                     ??emberIncomingBootloadMessageHandler_21:
   \   00000280   0x4639             MOV      R1,R7
   \   00000282   0x79A8             LDRB     R0,[R5, #+6]
   \   00000284   0x.... 0x....      BL       emberSerialPrintf
    806                    xmodemReceiveAndForward();
   \   00000288   0x.... 0x....      BL       xmodemReceiveAndForward
   \   0000028C   0xE005             B.N      ??CrossCallReturnLabel_39
    807                  } 
    808                } else {
    809                  // In case of normal NAK to data packet, we stay in the same state and 
    810                  // wait for next retry
    811                  debug("RX NAK block %x\r\n", block);
   \                     ??emberIncomingBootloadMessageHandler_26:
   \   0000028E   0x.... 0x....      ADR.W    R1,`?<Constant "RX NAK block %x\\r\\n">`
   \   00000292   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_35:
   \   00000296   0x.... 0x....      BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_39:
   \   0000029A   0xB00F             ADD      SP,SP,#+60
   \   0000029C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    812                }
    813                break;
    814          #endif // SBL_LIB_TARGET    
    815          
    816              default:
    817                break;
    818            }
    819          
    820          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   0x4641             MOV      R1,R8
   \   00000002   0xF105 0x0014      ADD      R0,R5,#+20
   \   00000006   0x....             B.N      isTheSameEui64

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   0x2102             MOVS     R1,#+2
   \                     ??Subroutine4_0:
   \   00000002   0x4630             MOV      R0,R6
   \   00000004   0x.... 0x....      B.W      emberGetLinkedBuffersByte

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x9000             STR      R0,[SP, #+0]
   \   00000004   0x2310             MOVS     R3,#+16
   \   00000006   0x2202             MOVS     R2,#+2
   \   00000008   0x4631             MOV      R1,R6
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x2208             MOVS     R2,#+8
   \   00000002   0x4641             MOV      R1,R8
   \   00000004   0xF105 0x0014      ADD      R0,R5,#+20
   \   00000008   0x.... 0x....      B.W      halCommonMemCopy

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   0x79A8             LDRB     R0,[R5, #+6]
   \   00000002   0x.... 0x....      B.W      emberSerialWaitSend

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   0x79A8             LDRB     R0,[R5, #+6]
   \   00000002   0x.... 0x....      B.W      emberSerialPrintf
    821          

   \                                 In section .text, align 2, keep-with-next
    822          void emberBootloadTransmitCompleteHandler(EmberMessageBuffer message,
    823                                                     EmberStatus status)
    824          {
   \                     emberBootloadTransmitCompleteHandler:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
    825          #ifdef ENABLE_DEBUG
    826            int8u type;
    827            type = emberGetLinkedBuffersByte(message, OFFSET_MESSAGE_TYPE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x.... 0x....      BL       emberGetLinkedBuffersByte
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000000E   0x798B             LDRB     R3,[R1, #+6]
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0x4602             MOV      R2,R0
   \   00000014   0xBF0C             ITE      EQ 
   \   00000016   0x.... 0x....      ADREQ.W  R1,`?<Constant "message 0x%x is sent ...">`
   \   0000001A   0x.... 0x....      ADRNE.W  R1,`?<Constant "message 0x%x is faile...">`
    828            if(status == EMBER_SUCCESS) {
    829              emberSerialPrintf(appSerial, 
    830                "message 0x%x is sent successfully\r\n", type);
    831            } else {
    832              emberSerialPrintf(appSerial, 
    833                "message 0x%x is failed to send\r\n", type);
   \   0000001E   0x4618             MOV      R0,R3
   \   00000020   0xE8BD 0x4010      POP      {R4,LR}
   \   00000024   0x.... 0x....      B.W      emberSerialPrintf
    834            }
    835          #endif
    836          }
    837          
    838          // ****************************************************************
    839          // Utilities Functions
    840          // ****************************************************************
    841          

   \                                 In section .text, align 2, keep-with-next
    842          static int8u isTheSameEui64(EmberEUI64 source, EmberEUI64 target)
    843          {
   \                     isTheSameEui64:
   \   00000000   0xB580             PUSH     {R7,LR}
    844            return !(MEMCOMPARE(source, target, EUI64_SIZE)); 
   \   00000002   0x2208             MOVS     R2,#+8
   \   00000004   0x.... 0x....      BL       halCommonMemCompare
   \   00000008   0x1E40             SUBS     R0,R0,#+1
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x0FC0             LSRS     R0,R0,#+31
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
    845          }
    846          
    847          // This is called to create generic bootload headers for
    848          // various message types.  When finished, the function returns the
    849          // offset value after the header.
    850          static int8u bootloadMakeHeader(int8u *message, int8u type)
    851          {
    852            //common header values
    853            message[0] = BOOTLOAD_PROTOCOL_VERSION;
    854            message[1] = type;
    855          
    856            // for XMODEM_QUERY and XMODEM_EOT messages, this represents the end of the
    857            // header.  However, for XMODEM_QRESP, XMODEM_SOH, XMODEM_ACK, XMODEM_NAK
    858            // messages, there are additional values that need to be added.
    859            // Note that the application will not have to handle creation of 
    860            // over the air XMODEM_ACK and XMODEM_NAK since these are all handled by 
    861            // the bootloader on the target node.
    862          
    863            return 2;
    864          }
    865          
    866          #ifndef SBL_LIB_TARGET    
    867          // This function is used as a port of XModem communication.  It reads
    868          // bootload serial port (uart port 1) one byte at a time and then
    869          // returns appropriate status.

   \                                 In section .text, align 2, keep-with-next
    870          static int8u xmodemReadSerialByte(int8u timeout, int8u *byte)
    871          {
   \                     xmodemReadSerialByte:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    872            int16u time = halCommonGetInt16uMillisecondTick();
   \   00000006   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   0000000A   0x4606             MOV      R6,R0
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable26
   \   00000010   0xE005             B.N      ??xmodemReadSerialByte_0
    873          
    874            while (timeout > 0) {
    875              halResetWatchdog();
    876              emberSerialBufferTick();
    877              if (emberSerialReadAvailable(bootloadSerial) > 0) {
    878                if(emberSerialReadByte(bootloadSerial, byte) == EMBER_SUCCESS) {
    879                  return SERIAL_DATA_OK;
    880                }
    881              } else if ((halCommonGetInt16uMillisecondTick() - time) > 100) {
   \                     ??xmodemReadSerialByte_1:
   \   00000012   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000016   0x1B80             SUBS     R0,R0,R6
   \   00000018   0x2865             CMP      R0,#+101
   \   0000001A   0xDB02             BLT.N    ??xmodemReadSerialByte_2
    882                timeout -= 1;
   \   0000001C   0x1E64             SUBS     R4,R4,#+1
    883              }
   \                     ??xmodemReadSerialByte_0:
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0xB17C             CBZ.N    R4,??xmodemReadSerialByte_3
   \                     ??xmodemReadSerialByte_2:
   \   00000022   0x.... 0x....      BL       halInternalResetWatchDog
   \   00000026   0x.... 0x....      BL       emberSerialBufferTick
   \   0000002A   0x79F8             LDRB     R0,[R7, #+7]
   \   0000002C   0x.... 0x....      BL       emberSerialReadAvailable
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD0EE             BEQ.N    ??xmodemReadSerialByte_1
   \   00000034   0x4629             MOV      R1,R5
   \   00000036   0x79F8             LDRB     R0,[R7, #+7]
   \   00000038   0x.... 0x....      BL       emberSerialReadByte
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD1F0             BNE.N    ??xmodemReadSerialByte_2
   \   00000040   0xBDF2             POP      {R1,R4-R7,PC}
    884            }
    885          
    886            return NO_SERIAL_DATA;
   \                     ??xmodemReadSerialByte_3:
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    887          }
    888          
    889          // This function is used to read bootload serial port one block at a time.
    890          // XModem protocol specifies its data block length to be 128 bytes plus 
    891          // 2 bytes crc and appropriate header bytes.  The function validates the header
    892          // and the crc and return appropriate value.

   \                                 In section .text, align 2, keep-with-next
    893          static int8u xmodemReceiveBlock(void) {
   \                     xmodemReceiveBlock:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    894            int8u header=0, blockNumber=0, blockCheck=0, crcLow=0, crcHigh=0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
   \   00000008   0xF88D 0x0004      STRB     R0,[SP, #+4]
    895            int8u ii, temp;
    896            int16u crc = 0x0000;
   \   0000000C   0x2400             MOVS     R4,#+0
    897            int8u status = STATUS_NAK;
   \   0000000E   0x2501             MOVS     R5,#+1
    898            
    899            if ((xmodemReadSerialByte(SERIAL_TIMEOUT_3S, &header) == NO_SERIAL_DATA) 
    900                || (header == XMODEM_CANCEL)
    901                || (header == XMODEM_CC)) 
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x201E             MOVS     R0,#+30
   \   00000014   0x.... 0x....      BL       xmodemReadSerialByte
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xBF1E             ITTT     NE 
   \   0000001C   0xF89D 0x0000      LDRBNE   R0,[SP, #+0]
   \   00000020   0x2818             CMPNE    R0,#+24
   \   00000022   0x2803             CMPNE    R0,#+3
   \   00000024   0xD101             BNE.N    ??xmodemReceiveBlock_0
    902              return STATUS_RESTART;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xBDFE             POP      {R1-R7,PC}
    903              
    904            if ((header == XMODEM_EOT) && 
    905                (xmodemReadSerialByte(SERIAL_TIMEOUT_3S, &temp) == NO_SERIAL_DATA)) 
   \                     ??xmodemReceiveBlock_0:
   \   0000002A   0x2804             CMP      R0,#+4
   \   0000002C   0xD108             BNE.N    ??xmodemReceiveBlock_1
   \   0000002E   0xF10D 0x0105      ADD      R1,SP,#+5
   \   00000032   0x201E             MOVS     R0,#+30
   \   00000034   0x.... 0x....      BL       xmodemReadSerialByte
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD101             BNE.N    ??xmodemReceiveBlock_1
    906              return STATUS_DONE;
   \   0000003C   0x2005             MOVS     R0,#+5
   \   0000003E   0xBDFE             POP      {R1-R7,PC}
    907                
    908            if ((header != XMODEM_SOH)
    909              || (xmodemReadSerialByte(SERIAL_TIMEOUT_1S, &blockNumber) != SERIAL_DATA_OK)
    910              || (xmodemReadSerialByte(SERIAL_TIMEOUT_1S, &blockCheck)  != SERIAL_DATA_OK)) {
   \                     ??xmodemReceiveBlock_1:
   \   00000040   0x....             LDR.N    R6,??DataTable26
   \   00000042   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD108             BNE.N    ??xmodemReceiveBlock_2
   \   0000004A   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000004E   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_30:
   \   00000052   0xB918             CBNZ.N   R0,??xmodemReceiveBlock_2
   \   00000054   0xA901             ADD      R1,SP,#+4
   \   00000056   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_29:
   \   0000005A   0xB118             CBZ.N    R0,??xmodemReceiveBlock_3
    911              emberSerialFlushRx(bootloadSerial);
   \                     ??xmodemReceiveBlock_2:
   \   0000005C   0x79F0             LDRB     R0,[R6, #+7]
   \   0000005E   0x.... 0x....      BL       emberSerialFlushRx
   \   00000062   0xE02D             B.N      ??xmodemReceiveBlock_4
    912              return STATUS_NAK;
    913            }
    914          
    915            if (blockNumber + blockCheck == 0xFF) {
   \                     ??xmodemReceiveBlock_3:
   \   00000064   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000068   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000006C   0x1808             ADDS     R0,R1,R0
   \   0000006E   0x28FF             CMP      R0,#+255
   \   00000070   0xD105             BNE.N    ??xmodemReceiveBlock_5
    916              if (blockNumber == expectedBlockNumber) {
   \   00000072   0x78F0             LDRB     R0,[R6, #+3]
   \   00000074   0xF89D 0x1001      LDRB     R1,[SP, #+1]
   \   00000078   0x4281             CMP      R1,R0
   \   0000007A   0xD123             BNE.N    ??xmodemReceiveBlock_6
    917                status = STATUS_OK;
   \   0000007C   0x2500             MOVS     R5,#+0
    918              } else if (blockNumber == (int8u)(expectedBlockNumber - 1)) {
    919                // Sender probably missed our ack so ack again
    920                return STATUS_DUPLICATE;  
    921              }
    922            } 
    923          
    924            for (ii = 0; ii < XMODEM_BLOCK_SIZE; ii++) {
   \                     ??xmodemReceiveBlock_5:
   \   0000007E   0x2600             MOVS     R6,#+0
   \   00000080   0x....             LDR.N    R7,??DataTable26_5
    925              if (xmodemReadSerialByte(SERIAL_TIMEOUT_1S, &xmodemBlock[ii]) != SERIAL_DATA_OK) {
   \                     ??xmodemReceiveBlock_7:
   \   00000082   0x19F1             ADDS     R1,R6,R7
   \   00000084   0x200A             MOVS     R0,#+10
   \   00000086   0x.... 0x....      BL       xmodemReadSerialByte
   \   0000008A   0xB9C8             CBNZ.N   R0,??xmodemReceiveBlock_4
    926                return STATUS_NAK;
    927              }
    928              crc = halCommonCrc16(xmodemBlock[ii], crc);
   \   0000008C   0x4621             MOV      R1,R4
   \   0000008E   0x5DF0             LDRB     R0,[R6, R7]
   \   00000090   0x.... 0x....      BL       halCommonCrc16
   \   00000094   0x4604             MOV      R4,R0
    929            }
   \   00000096   0x1C76             ADDS     R6,R6,#+1
   \   00000098   0x2E80             CMP      R6,#+128
   \   0000009A   0xDBF2             BLT.N    ??xmodemReceiveBlock_7
    930          
    931            if ((xmodemReadSerialByte(SERIAL_TIMEOUT_1S, &crcHigh) != SERIAL_DATA_OK)
    932                || (xmodemReadSerialByte(SERIAL_TIMEOUT_1S, &crcLow) != SERIAL_DATA_OK) 
    933                || (crc != HIGH_LOW_TO_INT(crcHigh, crcLow))) {
   \   0000009C   0xF10D 0x0102      ADD      R1,SP,#+2
   \   000000A0   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_28:
   \   000000A4   0xB960             CBNZ.N   R0,??xmodemReceiveBlock_4
   \   000000A6   0xF10D 0x0103      ADD      R1,SP,#+3
   \   000000AA   0x.... 0x....      BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_27:
   \   000000AE   0xB938             CBNZ.N   R0,??xmodemReceiveBlock_4
   \   000000B0   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   000000B4   0xF89D 0x1003      LDRB     R1,[SP, #+3]
   \   000000B8   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   000000BC   0x4284             CMP      R4,R0
   \   000000BE   0xD007             BEQ.N    ??xmodemReceiveBlock_8
    934              return STATUS_NAK;
   \                     ??xmodemReceiveBlock_4:
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xBDFE             POP      {R1-R7,PC}
    935            }
   \                     ??xmodemReceiveBlock_6:
   \   000000C4   0x1E40             SUBS     R0,R0,#+1
   \   000000C6   0xB2C0             UXTB     R0,R0
   \   000000C8   0x4281             CMP      R1,R0
   \   000000CA   0xD1D8             BNE.N    ??xmodemReceiveBlock_5
   \   000000CC   0x2004             MOVS     R0,#+4
   \   000000CE   0xBDFE             POP      {R1-R7,PC}
    936            return status;
   \                     ??xmodemReceiveBlock_8:
   \   000000D0   0x4628             MOV      R0,R5
   \   000000D2   0xBDFE             POP      {R1-R7,PC}       ;; return
    937          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   0x200A             MOVS     R0,#+10
   \   00000002   0x....             B.N      xmodemReadSerialByte
    938          
    939          // The function sends XModem ready character 'C' as stated by XModem protocol
    940          // as a signal to the host (PC) to start transmit XModem data.
    941          static void xmodemSendReady(void)
    942          {
    943            emberSerialFlushRx(bootloadSerial);
    944            emberSerialWriteByte(bootloadSerial, XMODEM_READY);
    945          }
    946          
    947          // After the (source) node receives query response from the target node.  It
    948          // signals the PC to transmit data and it reads out the data one XModem block
    949          // at a time.  If all data bytes are read fine and the crc is checked out fine,
    950          // it then breaks up the 128-byte data into two 64-byte chunks to send 
    951          // over the air to the target node.  It repeats the process untill all data
    952          // is transfered successfully.

   \                                 In section .text, align 2, keep-with-next
    953          static void xmodemReceiveAndForward(void)
    954          {
   \                     xmodemReceiveAndForward:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    955          #ifndef SBL_LIB_SRC_NO_PASSTHRU   // used in passthru mode
    956            boolean xmodemStart = FALSE;
   \   00000004   0x2500             MOVS     R5,#+0
    957            int8u counter=0, i;
   \   00000006   0x2600             MOVS     R6,#+0
    958            expectedBlockNumber = 1;
   \   00000008   0x....             LDR.N    R4,??DataTable26
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x70E0             STRB     R0,[R4, #+3]
    959            
    960            for (;;) {
    961              int8u status;
    962          
    963              halResetWatchdog();
   \                     ??xmodemReceiveAndForward_0:
   \   0000000E   0x.... 0x....      BL       halInternalResetWatchDog
    964              xmodemSendReady();
   \   00000012   0x79E0             LDRB     R0,[R4, #+7]
   \   00000014   0x.... 0x....      BL       emberSerialFlushRx
   \   00000018   0x2143             MOVS     R1,#+67
   \   0000001A   0x.... 0x....      BL       ?Subroutine2
    965              // Determine if the PC has cancelled the session.  We wait ~ 20 s
    966              // which is a bit higher than xmodem (retry) timeout which is 10 s.
    967              ++counter;
   \                     ??CrossCallReturnLabel_7:
   \   0000001E   0x1C76             ADDS     R6,R6,#+1
    968              if(xmodemStart && counter > 200) {
   \   00000020   0xB365             CBZ.N    R5,??xmodemReceiveAndForward_1
   \   00000022   0xB2F6             UXTB     R6,R6
   \   00000024   0x2EC9             CMP      R6,#+201
   \   00000026   0xD329             BCC.N    ??xmodemReceiveAndForward_1
    969                bl_print("Error: PC stops sending us data\r\n");
    970                blState = BOOTLOAD_STATE_NORMAL;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x7020             STRB     R0,[R4, #+0]
    971                blMode = BOOTLOAD_MODE_NONE;
   \   0000002C   0x7060             STRB     R0,[R4, #+1]
    972                return;
   \                     ??xmodemReceiveAndForward_2:
   \   0000002E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    973              }
    974          
    975              do {
    976                int8u outByte;
    977          
    978                status = xmodemReceiveBlock();
    979                
    980                switch (status)
    981                {
    982                case STATUS_OK:
    983                  // When receive first good packet, that means we have 'officially'
    984                  // started XModem transfer.
    985                  xmodemStart = TRUE;
   \                     ??xmodemReceiveAndForward_3:
   \   00000032   0x2501             MOVS     R5,#+1
    986                  counter = 0;
   \   00000034   0x2600             MOVS     R6,#+0
    987                  // Forward data to the target node
    988                  if(!bootloadSendImage(XMODEM_SOH)) {
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x.... 0x....      BL       bootloadSendImage
   \   0000003C   0xB988             CBNZ.N   R0,??xmodemReceiveAndForward_4
    989                    debug("Error: cannot forward data to target node\r\n");
   \   0000003E   0x.... 0x....      ADR.W    R1,`?<Constant "Error: cannot forward...">`
   \   00000042   0x79A0             LDRB     R0,[R4, #+6]
   \   00000044   0x.... 0x....      BL       emberSerialPrintf
   \   00000048   0x79A0             LDRB     R0,[R4, #+6]
   \   0000004A   0x.... 0x....      BL       emberSerialWaitSend
    990                    // Cancel XModem session with the host (PC)
    991                    outByte = XMODEM_CANCEL;
    992                    emberSerialFlushRx(bootloadSerial);
   \   0000004E   0x79E0             LDRB     R0,[R4, #+7]
   \   00000050   0x.... 0x....      BL       emberSerialFlushRx
    993                    for(i=0; i<5; ++i) {
   \   00000054   0x2505             MOVS     R5,#+5
    994                      emberSerialWriteByte(bootloadSerial, outByte);
   \                     ??xmodemReceiveAndForward_5:
   \   00000056   0x2118             MOVS     R1,#+24
   \   00000058   0x.... 0x....      BL       ?Subroutine2
    995                    }
   \                     ??CrossCallReturnLabel_6:
   \   0000005C   0x1E6D             SUBS     R5,R5,#+1
   \   0000005E   0xD1FA             BNE.N    ??xmodemReceiveAndForward_5
   \   00000060   0xE7E5             B.N      ??xmodemReceiveAndForward_2
    996                    return;
    997                  }
    998                  expectedBlockNumber++;
   \                     ??xmodemReceiveAndForward_4:
   \   00000062   0x78E0             LDRB     R0,[R4, #+3]
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0x70E0             STRB     R0,[R4, #+3]
    999                  // Yes, fall through: a duplicate means the sender missed our ack.
   1000                  // Ack again as if everything's okay.
   1001                case STATUS_DUPLICATE:
   1002                  outByte = XMODEM_ACK;
   \                     ??xmodemReceiveAndForward_6:
   \   00000068   0x2706             MOVS     R7,#+6
   1003                  break;
   1004                case STATUS_NAK:
   1005                  outByte = XMODEM_NAK;
   1006                  break;
   1007                case STATUS_DONE:
   1008                  if(!bootloadSendImage(XMODEM_EOT)) {
   1009                    debug("Error: cannot forward complete signal to target node\r\n");
   1010                    return;
   1011                  }
   1012                  emberSerialWriteByte(bootloadSerial, XMODEM_ACK);
   1013                  blState = BOOTLOAD_STATE_NORMAL;
   1014                  blMode  = BOOTLOAD_MODE_NONE;
   1015                  emberSerialPrintf(appSerial, "Bootload Complete!\r\n");
   1016                  return;
   1017                default:
   1018                  continue;
   1019                }
   1020                emberSerialFlushRx(bootloadSerial);
   \                     ??xmodemReceiveAndForward_7:
   \   0000006A   0x79E0             LDRB     R0,[R4, #+7]
   \   0000006C   0x.... 0x....      BL       emberSerialFlushRx
   1021                emberSerialWriteByte(bootloadSerial, outByte);
   \   00000070   0x4639             MOV      R1,R7
   \   00000072   0x.... 0x....      BL       ?Subroutine2
   1022              } while (status != STATUS_RESTART);
   \                     ??CrossCallReturnLabel_5:
   \   00000076   0xF1B8 0x0F03      CMP      R8,#+3
   \   0000007A   0xD0C8             BEQ.N    ??xmodemReceiveAndForward_0
   \                     ??xmodemReceiveAndForward_1:
   \   0000007C   0x.... 0x....      BL       xmodemReceiveBlock
   \   00000080   0x4680             MOV      R8,R0
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD0D5             BEQ.N    ??xmodemReceiveAndForward_3
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD004             BEQ.N    ??xmodemReceiveAndForward_8
   \   0000008A   0x2804             CMP      R0,#+4
   \   0000008C   0xD0EC             BEQ.N    ??xmodemReceiveAndForward_6
   \   0000008E   0x2805             CMP      R0,#+5
   \   00000090   0xD1F1             BNE.N    ??CrossCallReturnLabel_5
   \   00000092   0xE001             B.N      ??xmodemReceiveAndForward_9
   \                     ??xmodemReceiveAndForward_8:
   \   00000094   0x2715             MOVS     R7,#+21
   \   00000096   0xE7E8             B.N      ??xmodemReceiveAndForward_7
   \                     ??xmodemReceiveAndForward_9:
   \   00000098   0x2004             MOVS     R0,#+4
   \   0000009A   0x.... 0x....      BL       bootloadSendImage
   \   0000009E   0xB948             CBNZ.N   R0,??xmodemReceiveAndForward_10
   \   000000A0   0x.... 0x....      ADR.W    R1,`?<Constant "Error: cannot forward...">_1`
   \   000000A4   0x79A0             LDRB     R0,[R4, #+6]
   \   000000A6   0x.... 0x....      BL       emberSerialPrintf
   \   000000AA   0x79A0             LDRB     R0,[R4, #+6]
   \   000000AC   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000B0   0x.... 0x....      B.W      emberSerialWaitSend
   \                     ??xmodemReceiveAndForward_10:
   \   000000B4   0x2106             MOVS     R1,#+6
   \   000000B6   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_4:
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x7020             STRB     R0,[R4, #+0]
   \   000000BE   0x7060             STRB     R0,[R4, #+1]
   \   000000C0   0x.... 0x....      ADR.W    R1,`?<Constant "Bootload Complete!\\r\\n">`
   \   000000C4   0x79A0             LDRB     R0,[R4, #+6]
   \   000000C6   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000CA   0x.... 0x....      B.W      emberSerialPrintf
   1023            }
   1024          #else
   1025            bl_print("ERR: passthru is not supported\r\n");
   1026          #endif // SBL_LIB_SRC_NO_PASSTHRU
   1027          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x79E0             LDRB     R0,[R4, #+7]
   \   00000002   0x.... 0x....      B.W      emberSerialWriteByte
   1028          
   1029          // The function is called to send (new application) data to the target node
   1030          // over the air.  Note that the source and the target nodes need to be one
   1031          // hop away from each other and have good link to each other to ensure
   1032          // quick and successful bootloading.

   \                                 In section .text, align 2, keep-with-next
   1033          static boolean bootloadSendImage(int8u type)
   1034          {
   \                     bootloadSendImage:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   1035            int8u block[2];
   1036            int8u i;
   1037            // Send 128 bytes of XModem data in two
   1038            // 64-byte radio packets
   1039            block[0] = ((2 * expectedBlockNumber) - 1);
   \   00000006   0x....             LDR.N    R5,??DataTable26
   \   00000008   0x78E8             LDRB     R0,[R5, #+3]
   \   0000000A   0x0041             LSLS     R1,R0,#+1
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
   \   0000000E   0xF88D 0x1000      STRB     R1,[SP, #+0]
   1040            block[1] = (2 * expectedBlockNumber);
   \   00000012   0xAE00             ADD      R6,SP,#+0
   \   00000014   0x0040             LSLS     R0,R0,#+1
   \   00000016   0x7070             STRB     R0,[R6, #+1]
   1041          
   1042            for(i=0; i<2; ++i) {
   \   00000018   0x2700             MOVS     R7,#+0
   \   0000001A   0x.... 0x....      ADR.W    R8,`?<Constant "free buffer: %x\\r\\n">`
   \   0000001E   0x.... 0x....      LDR.W    R9,??DataTable26_6
   \   00000022   0x.... 0x....      ADR.W    R10,`?<Constant "sending OTA block %x\\r\\n">`
   1043              debug("sending OTA block %x\r\n", block[i]);
   \                     ??bootloadSendImage_0:
   \   00000026   0xF817 0xB006      LDRB     R11,[R7, R6]
   \   0000002A   0x465A             MOV      R2,R11
   \   0000002C   0x4651             MOV      R1,R10
   \   0000002E   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_34:
   \   00000032   0x.... 0x....      BL       ?Subroutine8
   1044              debug("free buffer: %x\r\n", emPacketBufferFreeCount);
   \                     ??CrossCallReturnLabel_38:
   \   00000036   0xF899 0x2000      LDRB     R2,[R9, #+0]
   \   0000003A   0x4641             MOV      R1,R8
   \   0000003C   0x.... 0x....      BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_33:
   \   00000040   0x.... 0x....      BL       ?Subroutine8
   1045              currentRetriesRemaining = NUM_PKT_RETRIES;
   \                     ??CrossCallReturnLabel_37:
   \   00000044   0x200A             MOVS     R0,#+10
   \   00000046   0x70A8             STRB     R0,[R5, #+2]
   1046              currentOTABlock = block[i];
   \   00000048   0xF885 0xB004      STRB     R11,[R5, #+4]
   1047              actionTimer = TIMEOUT_IMAGE_SEND;
   \   0000004C   0x200F             MOVS     R0,#+15
   \   0000004E   0x7168             STRB     R0,[R5, #+5]
   1048              if(type == XMODEM_SOH) {
   \   00000050   0x2C01             CMP      R4,#+1
   \   00000052   0xD104             BNE.N    ??bootloadSendImage_1
   1049                blState = BOOTLOAD_STATE_WAIT_FOR_IMAGE_ACK;      
   \   00000054   0x2009             MOVS     R0,#+9
   \   00000056   0x7028             STRB     R0,[R5, #+0]
   1050                sendMACImageSegment();
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xE005             B.N      ??bootloadSendImage_2
   1051              } else if(type == XMODEM_EOT) {
   \                     ??bootloadSendImage_1:
   \   0000005E   0x2C04             CMP      R4,#+4
   \   00000060   0xD10E             BNE.N    ??bootloadSendImage_3
   1052                blState = BOOTLOAD_STATE_WAIT_FOR_COMPLETE_ACK;      
   \   00000062   0x200A             MOVS     R0,#+10
   \   00000064   0x7028             STRB     R0,[R5, #+0]
   1053                sendMACCompleteSegment();
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x2004             MOVS     R0,#+4
   \                     ??bootloadSendImage_2:
   \   0000006A   0x.... 0x....      BL       sendRadioMessage
   \   0000006E   0xE007             B.N      ??bootloadSendImage_3
   1054              } 
   1055              while((blState == BOOTLOAD_STATE_WAIT_FOR_IMAGE_ACK) ||
   1056                    (blState == BOOTLOAD_STATE_WAIT_FOR_COMPLETE_ACK)) {
   1057                halResetWatchdog();
   \                     ??bootloadSendImage_4:
   \   00000070   0x.... 0x....      BL       halInternalResetWatchDog
   1058                emberTick();
   \   00000074   0x.... 0x....      BL       emberTick
   1059                bootloadUtilTick();
   \   00000078   0x.... 0x....      BL       bootloadUtilTick
   1060                emberSerialBufferTick();
   \   0000007C   0x.... 0x....      BL       emberSerialBufferTick
   1061              }
   \                     ??bootloadSendImage_3:
   \   00000080   0x7828             LDRB     R0,[R5, #+0]
   \   00000082   0x2809             CMP      R0,#+9
   \   00000084   0xBF18             IT       NE 
   \   00000086   0x280A             CMPNE    R0,#+10
   \   00000088   0xD0F2             BEQ.N    ??bootloadSendImage_4
   1062              
   1063              if(blState == BOOTLOAD_STATE_NORMAL) {
   \   0000008A   0xB930             CBNZ.N   R0,??bootloadSendImage_5
   1064                emberSerialPrintf(appSerial, "ERROR: Image send OTA failed\r\n");
   \   0000008C   0x.... 0x....      ADR.W    R1,`?<Constant "ERROR: Image send OTA...">`
   \   00000090   0x79A8             LDRB     R0,[R5, #+6]
   \   00000092   0x.... 0x....      BL       emberSerialPrintf
   1065                return FALSE;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE005             B.N      ??bootloadSendImage_6
   1066              }
   1067              // If the target node sends ACK in respond to our EOT packet, then
   1068              // we're done.
   1069              if(blState == BOOTLOAD_STATE_DONE) {
   \                     ??bootloadSendImage_5:
   \   0000009A   0x280B             CMP      R0,#+11
   \   0000009C   0xD002             BEQ.N    ??bootloadSendImage_7
   1070                return TRUE;
   1071              }
   1072            }
   \   0000009E   0x1C7F             ADDS     R7,R7,#+1
   \   000000A0   0x2F02             CMP      R7,#+2
   \   000000A2   0xDBC0             BLT.N    ??bootloadSendImage_0
   1073              
   1074            return TRUE;
   \                     ??bootloadSendImage_7:
   \   000000A4   0x2001             MOVS     R0,#+1
   \                     ??bootloadSendImage_6:
   \   000000A6   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1075          
   1076          }
   1077          #endif // SBL_LIB_TARGET
   1078          
   1079          // This function actually crafts and sends out the radio packets.  XMODEM_SOH
   1080          // is the data packet and XMODEM_EOT is the end of transmission packet.

   \                                 In section .text, align 2, keep-with-next
   1081          static void sendRadioMessage(int8u messageType, boolean isBroadcast)
   1082          {  
   \                     sendRadioMessage:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4602             MOV      R2,R0
   \   00000006   0x4688             MOV      R8,R1
   1083            // allow space for the longest possible message
   1084            int8u length, index, i, startByte, data;
   1085            EmberMessageBuffer buffer;
   1086            int16u crc = 0x0000;
   \   00000008   0x2000             MOVS     R0,#+0
   1087            int16u blVersion; // if the version is invalid, the value is 0xFFFF
   1088            
   1089            // for convenience, we form the message in a byte array first.
   1090            index = bootloadMakeHeader(bootloadBuffer, messageType);
   \   0000000A   0x....             LDR.N    R5,??DataTable26_1
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7029             STRB     R1,[R5, #+0]
   \   00000010   0x706A             STRB     R2,[R5, #+1]
   1091            
   1092            switch (messageType)
   \   00000012   0x....             LDR.N    R6,??DataTable26
   \   00000014   0x2A01             CMP      R2,#+1
   \   00000016   0xD022             BEQ.N    ??sendRadioMessage_0
   \   00000018   0x2A04             CMP      R2,#+4
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2A51             CMPNE    R2,#+81
   \   0000001E   0xD03D             BEQ.N    ??sendRadioMessage_1
   \   00000020   0x2A52             CMP      R2,#+82
   \   00000022   0xD151             BNE.N    ??sendRadioMessage_2
   1093            {
   1094            case XMODEM_QRESP:
   1095              {
   1096                // {1:blActive(0)}
   1097                bootloadBuffer[index++] = FALSE;
   \   00000024   0x70A8             STRB     R0,[R5, #+2]
   1098                // {2:mfgId}
   1099                halCommonGetToken(&bootloadBuffer[index], TOKEN_MFG_MANUF_ID);
   \   00000026   0x2302             MOVS     R3,#+2
   \   00000028   0x227F             MOVS     R2,#+127
   \   0000002A   0x....             LDR.N    R0,??DataTable26_7
   \   0000002C   0x8801             LDRH     R1,[R0, #+0]
   \   0000002E   0x1CE8             ADDS     R0,R5,#+3
   \   00000030   0x.... 0x....      BL       halInternalGetTokenData
   1100                index += sizeof(tokTypeMfgManufId);
   1101                // {16:hwTag}
   1102                halCommonGetToken(&bootloadBuffer[index], TOKEN_MFG_BOARD_NAME);
   \   00000034   0x2310             MOVS     R3,#+16
   \   00000036   0x227F             MOVS     R2,#+127
   \   00000038   0x....             LDR.N    R0,??DataTable26_8
   \   0000003A   0x8801             LDRH     R1,[R0, #+0]
   \   0000003C   0x1D68             ADDS     R0,R5,#+5
   \   0000003E   0x.... 0x....      BL       halInternalGetTokenData
   1103                index += sizeof(tokTypeMfgBoardName);
   1104                // {1:blCapabilities}
   1105                // In the future, we should read the capabilities mask from fixed 
   1106                // location in bootloader.  However, currently we do not have any
   1107                // bootload capabilities implemented.  This filed is included for
   1108                // future use.
   1109                bootloadBuffer[index++] = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x7568             STRB     R0,[R5, #+21]
   1110                bootloadBuffer[index++] = PLAT;
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0x75A8             STRB     R0,[R5, #+22]
   1111                bootloadBuffer[index++] = MICRO;
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0x75E8             STRB     R0,[R5, #+23]
   1112                bootloadBuffer[index++] = PHY;
   \   0000004E   0x7628             STRB     R0,[R5, #+24]
   1113                // {2:blVersion}
   1114                blVersion = halGetStandaloneBootloaderVersion();
   \   00000050   0x.... 0x....      BL       halGetStandaloneBootloaderVersion
   1115                bootloadBuffer[index++] = HIGH_BYTE(blVersion); // bootloader version
   \   00000054   0x1201             ASRS     R1,R0,#+8
   \   00000056   0x7669             STRB     R1,[R5, #+25]
   1116                bootloadBuffer[index++] = LOW_BYTE(blVersion); // bootloader build
   \   00000058   0x76A8             STRB     R0,[R5, #+26]
   1117                length = index;
   \   0000005A   0x211B             MOVS     R1,#+27
   1118              }
   1119              break; 
   \   0000005C   0xE01F             B.N      ??sendRadioMessage_3
   1120            case XMODEM_SOH: 
   1121              bootloadBuffer[index++] = currentOTABlock;
   \                     ??sendRadioMessage_0:
   \   0000005E   0x7931             LDRB     R1,[R6, #+4]
   \   00000060   0x70A9             STRB     R1,[R5, #+2]
   1122              bootloadBuffer[index++] = 0xFF - currentOTABlock;
   \   00000062   0xF1C1 0x02FF      RSB      R2,R1,#+255
   \   00000066   0x70EA             STRB     R2,[R5, #+3]
   1123              if(currentOTABlock & 0x01) {
   \   00000068   0x07C9             LSLS     R1,R1,#+31
   \   0000006A   0xBF4C             ITE      MI 
   \   0000006C   0x2700             MOVMI    R7,#+0
   \   0000006E   0x2740             MOVPL    R7,#+64
   1124                startByte = 0;
   1125              } else {
   1126                startByte = 64;
   1127              }
   1128              for(i = index; i<(BOOTLOAD_OTA_SIZE + index); ++i) {
   \   00000070   0x2404             MOVS     R4,#+4
   \   00000072   0x.... 0x....      LDR.W    R9,??DataTable26_5
   1129                data = xmodemBlock[startByte++];
   \                     ??sendRadioMessage_4:
   \   00000076   0xB2FF             UXTB     R7,R7
   \   00000078   0xF817 0x2009      LDRB     R2,[R7, R9]
   \   0000007C   0x1C7F             ADDS     R7,R7,#+1
   1130                bootloadBuffer[i] = data;
   \   0000007E   0x5562             STRB     R2,[R4, R5]
   1131                crc = halCommonCrc16(data, crc);
   \   00000080   0x4601             MOV      R1,R0
   \   00000082   0x4610             MOV      R0,R2
   \   00000084   0x.... 0x....      BL       halCommonCrc16
   1132              }
   \   00000088   0x1C64             ADDS     R4,R4,#+1
   \   0000008A   0x2C44             CMP      R4,#+68
   \   0000008C   0xD3F3             BCC.N    ??sendRadioMessage_4
   1133              // Include crc in the packet
   1134              bootloadBuffer[i] = HIGH_BYTE(crc);
   \   0000008E   0x0A01             LSRS     R1,R0,#+8
   \   00000090   0x5561             STRB     R1,[R4, R5]
   1135              bootloadBuffer[++i] = LOW_BYTE(crc);
   \   00000092   0x1C61             ADDS     R1,R4,#+1
   \   00000094   0xB2C9             UXTB     R1,R1
   \   00000096   0x5548             STRB     R0,[R1, R5]
   1136              length = MAX_BOOTLOAD_MESSAGE_SIZE;
   \   00000098   0x2146             MOVS     R1,#+70
   1137              break;
   \   0000009A   0xE000             B.N      ??sendRadioMessage_3
   1138            case XMODEM_EOT: 
   1139              bl_print("TX EOT\r\n");
   1140            case XMODEM_QUERY:
   1141              length = index;
   \                     ??sendRadioMessage_1:
   \   0000009C   0x2102             MOVS     R1,#+2
   1142              break; 
   1143            default:
   1144              return;
   1145            }
   1146          
   1147            buffer = emberFillLinkedBuffers(bootloadBuffer, length);
   \                     ??sendRadioMessage_3:
   \   0000009E   0x4628             MOV      R0,R5
   \   000000A0   0x.... 0x....      BL       emberFillLinkedBuffers
   \   000000A4   0x4605             MOV      R5,R0
   1148            // check to make sure a buffer is available
   1149            if (buffer == EMBER_NULL_MESSAGE_BUFFER) {
   \   000000A6   0x2DFF             CMP      R5,#+255
   \   000000A8   0xD00E             BEQ.N    ??sendRadioMessage_2
   1150              bl_print("TX error: Out Of Buffers\r\n");
   1151              return;
   1152            }
   1153          
   1154            if ( emberSendBootloadMessage(isBroadcast, targetAddress, buffer)
   1155               !=EMBER_SUCCESS ) {
   \   000000AA   0x462A             MOV      R2,R5
   \   000000AC   0xF106 0x0114      ADD      R1,R6,#+20
   \   000000B0   0x4640             MOV      R0,R8
   \   000000B2   0x.... 0x....      BL       emberSendBootloadMessage
   \   000000B6   0xB110             CBZ.N    R0,??sendRadioMessage_5
   1156              bl_print("send bootload msg failed\r\n");
   1157              blState = BOOTLOAD_STATE_NORMAL;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x7030             STRB     R0,[R6, #+0]
   1158              blMode = BOOTLOAD_MODE_NONE;
   \   000000BC   0x7070             STRB     R0,[R6, #+1]
   1159            } 
   1160          
   1161            // done with the packet buffer
   1162            emberReleaseMessageBuffer(buffer);
   \                     ??sendRadioMessage_5:
   \   000000BE   0x4628             MOV      R0,R5
   \   000000C0   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   000000C4   0x.... 0x....      B.W      emReleaseMessageBuffer
   \                     ??sendRadioMessage_2:
   \   000000C8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1163            
   1164          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     blState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     bootloadBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x........         DC32     emLocalEui64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x........         DC32     TOKEN_MFG_BOOTLOAD_AES_KEY

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x........         DC32     emMessageBufferLengths

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x........         DC32     xmodemBlock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \   00000000   0x........         DC32     emPacketBufferFreeCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_7:
   \   00000000   0x........         DC32     TOKEN_MFG_MANUF_ID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_8:
   \   00000000   0x........         DC32     TOKEN_MFG_BOARD_NAME

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "bootload-utils.c">`:
   \   00000000   0x62 0x6F          DC8 "bootload-utils.c"
   \              0x6F 0x74    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x2D 0x75    
   \              0x74 0x69    
   \              0x6C 0x73    
   \              0x2E 0x63    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "blState 0x%x\\r\\n">`:
   \   00000000   0x62 0x6C          DC8 "blState 0x%x\015\012"
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x0D 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Please start .ebl upl...">`:
   \   00000000   0x50 0x6C          DC8 "Please start .ebl upload image ...\015\012"
   \              0x65 0x61    
   \              0x73 0x65    
   \              0x20 0x73    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x20 0x2E    
   \              0x65 0x62    
   \              0x6C 0x20    
   \              0x75 0x70    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x20 0x69    
   \              0x6D 0x61    
   \              0x67 0x65    
   \              0x20 0x2E    
   \              0x2E 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "RX NAK block %x\\r\\n">`:
   \   00000000   0x52 0x58          DC8 "RX NAK block %x\015\012"
   \              0x20 0x4E    
   \              0x41 0x4B    
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x25    
   \              0x78 0x0D    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "message 0x%x is sent ...">`:
   \   00000000   0x6D 0x65          DC8 "message 0x%x is sent successfully\015\012"
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x73 0x65    
   \              0x6E 0x74    
   \              0x20 0x73    
   \              0x75 0x63    
   \              0x63 0x65    
   \              0x73 0x73    
   \              0x66 0x75    
   \              0x6C 0x6C    
   \              0x79 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "message 0x%x is faile...">`:
   \   00000000   0x6D 0x65          DC8 "message 0x%x is failed to send\015\012"
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x25 0x78    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x73 0x65    
   \              0x6E 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: cannot forward...">`:
   \   00000000   0x45 0x72          DC8 "Error: cannot forward data to target node\015\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x63    
   \              0x61 0x6E    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x66 0x6F    
   \              0x72 0x77    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x74 0x61    
   \              0x72 0x67    
   \              0x65 0x74    
   \              0x20 0x6E    
   \              0x6F 0x64    
   \              0x65 0x0D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: cannot forward...">_1`:
   \   00000000   0x45 0x72          DC8 45H, 72H, 72H, 6FH, 72H, 3AH, 20H, 63H
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x63    
   \   00000008   0x61 0x6E          DC8 61H, 6EH, 6EH, 6FH, 74H, 20H, 66H, 6FH
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x66 0x6F    
   \   00000010   0x72 0x77          DC8 72H, 77H, 61H, 72H, 64H, 20H, 63H, 6FH
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x63 0x6F    
   \   00000018   0x6D 0x70          DC8 6DH, 70H, 6CH, 65H, 74H, 65H, 20H, 73H
   \              0x6C 0x65    
   \              0x74 0x65    
   \              0x20 0x73    
   \   00000020   0x69 0x67          DC8 69H, 67H, 6EH, 61H, 6CH, 20H, 74H, 6FH
   \              0x6E 0x61    
   \              0x6C 0x20    
   \              0x74 0x6F    
   \   00000028   0x20 0x74          DC8 20H, 74H, 61H, 72H, 67H, 65H, 74H, 20H
   \              0x61 0x72    
   \              0x67 0x65    
   \              0x74 0x20    
   \   00000030   0x6E 0x6F          DC8 6EH, 6FH, 64H, 65H, 0DH, 0AH, 0
   \              0x64 0x65    
   \              0x0D 0x0A    
   \              0x00         
   \   00000037   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Bootload Complete!\\r\\n">`:
   \   00000000   0x42 0x6F          DC8 "Bootload Complete!\015\012"
   \              0x6F 0x74    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x20 0x43    
   \              0x6F 0x6D    
   \              0x70 0x6C    
   \              0x65 0x74    
   \              0x65 0x21    
   \              0x0D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "sending OTA block %x\\r\\n">`:
   \   00000000   0x73 0x65          DC8 "sending OTA block %x\015\012"
   \              0x6E 0x64    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x4F 0x54    
   \              0x41 0x20    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x25 0x78    
   \              0x0D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "free buffer: %x\\r\\n">`:
   \   00000000   0x66 0x72          DC8 "free buffer: %x\015\012"
   \              0x65 0x65    
   \              0x20 0x62    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x78 0x0D    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ERROR: Image send OTA...">`:
   \   00000000   0x45 0x52          DC8 "ERROR: Image send OTA failed\015\012"
   \              0x52 0x4F    
   \              0x52 0x3A    
   \              0x20 0x49    
   \              0x6D 0x61    
   \              0x67 0x65    
   \              0x20 0x73    
   \              0x65 0x6E    
   \              0x64 0x20    
   \              0x4F 0x54    
   \              0x41 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0
   1165          #ifndef SBL_LIB_TARGET 
   1166          static void printEui(EmberEUI64 eui)
   1167          {
   1168            bl_print("%x%x%x%x%x%x%x%x",
   1169                     eui[0], eui[1], eui[2], eui[3],
   1170                     eui[4], eui[5], eui[6], eui[7]);
   1171          }
   1172          
   1173          // This function determines if a node is sleepy (or mobile) by checking to see
   1174          // if it's eui is found in the child table.
   1175          static boolean isSleepy(EmberEUI64 eui)
   1176          {
   1177            int8u i;
   1178            for (i = 0; i < EMBER_CHILD_TABLE_SIZE; i++) {
   1179              EmberEUI64 childEui64;
   1180              EmberNodeType childType;
   1181              if ( (EMBER_SUCCESS == emberGetChildData(i, childEui64, &childType) )
   1182                 &&(0 == MEMCOMPARE(eui, childEui64, EUI64_SIZE) ) ) {
   1183                return TRUE;
   1184              }
   1185            }
   1186            return FALSE;
   1187          }
   1188          #endif
   1189          #else //USE_BOOTLOADER_LIB
   1190            // stub functions if USE_BOOTLOADER_LIB is not defined
   1191            void bootloadUtilTick(void){}
   1192            void bootloadUtilStartBootload(EmberEUI64 target, bootloadMode mode){}
   1193            EmberStatus bootloadUtilSendRequest(EmberEUI64 targetEui,
   1194                                              int16u mfgId,
   1195                                              int8u hardwareTag[BOOTLOAD_HARDWARE_TAG_SIZE],
   1196                                              int8u encryptKey[BOOTLOAD_AUTH_COMMON_SIZE],
   1197                                              bootloadMode mode) { return EMBER_LIBRARY_NOT_PRESENT; }
   1198            void bootloadUtilSendQuery(EmberEUI64 target) {}
   1199            void bootloadUtilInit(int8u appPort, int8u bootloadPort) {}
   1200          #endif//USE_BOOTLOADER_LIB

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  bootloadSendAuthChallenge
             24 -> emReleaseMessageBuffer
             24 -> emberFillLinkedBuffers
             24 -> emberSendBootloadMessage
             24 -> halCommonGetRandom
             24 -> halCommonMemCopy
             24 -> halGetStandaloneBootloaderVersion
             24 -> halStackGetInt32uSymbolTick
       24  bootloadSendAuthResponse
             24 -> emAesEncrypt
             24 -> emReleaseMessageBuffer
             24 -> emberFillLinkedBuffers
             24 -> emberMessageBufferContents
             24 -> emberSendBootloadMessage
             24 -> halCommonMemCopy
             24 -> halInternalAssertFailed
       40  bootloadSendImage
             40 -> bootloadUtilTick
             40 -> emberSerialBufferTick
             40 -> emberSerialPrintf
             40 -> emberSerialWaitSend
             40 -> emberTick
             40 -> halInternalResetWatchDog
             40 -> sendRadioMessage
        8  bootloadUtilInit
              0 -> emberSerialInit
        8  bootloadUtilSendAuthResponse
              8 -> bootloadSendAuthResponse
       16  bootloadUtilSendQuery
             16 -> halCommonMemCopy
             16 -> isTheSameEui64
             16 -> sendRadioMessage
       24  bootloadUtilSendRequest
             24 -> emReleaseMessageBuffer
             24 -> emberFillLinkedBuffers
             24 -> emberSendBootloadMessage
             24 -> halCommonMemCopy
       16  bootloadUtilStartBootload
             16 -> halCommonMemCopy
             16 -> isTheSameEui64
              0 -> sendRadioMessage
       24  bootloadUtilTick
              0 -> bootloadUtilStartBootload
             24 -> emReleaseMessageBuffer
             24 -> halCommonGetInt16uMillisecondTick
             24 -> halInternalAssertFailed
              0 -> sendRadioMessage
             24 -> sendRadioMessage
        8  emberBootloadTransmitCompleteHandler
              8 -> emberGetLinkedBuffersByte
              0 -> emberSerialPrintf
       96  emberIncomingBootloadMessageHandler
             96 -> bootloadSendAuthChallenge
             96 -> bootloadSendAuthResponse
             96 -> bootloadUtilLaunchRequestHandler
             96 -> bootloadUtilQueryResponseHandler
             96 -> emAesEncrypt
             96 -> emReallyCopyToLinkedBuffers
             96 -> emReleaseMessageBuffer
             96 -> emberGetChildData
             96 -> emberGetLastHopRssi
             96 -> emberGetLinkedBuffersByte
             96 -> emberMessageBufferContents
             96 -> emberSerialPrintf
             96 -> emberSerialWaitSend
             96 -> halCommonMemCompare
             96 -> halCommonMemCopy
             96 -> halInternalAssertFailed
             96 -> halInternalGetTokenData
             96 -> halLaunchStandaloneBootloader
             96 -> isTheSameEui64
             96 -> sendRadioMessage
             96 -> xmodemReceiveAndForward
        8  isTheSameEui64
              8 -> halCommonMemCompare
       32  sendRadioMessage
              0 -> emReleaseMessageBuffer
             32 -> emberFillLinkedBuffers
             32 -> emberSendBootloadMessage
             32 -> halCommonCrc16
             32 -> halGetStandaloneBootloaderVersion
             32 -> halInternalGetTokenData
       24  xmodemReadSerialByte
             24 -> emberSerialBufferTick
             24 -> emberSerialReadAvailable
             24 -> emberSerialReadByte
             24 -> halCommonGetInt16uMillisecondTick
             24 -> halInternalResetWatchDog
       24  xmodemReceiveAndForward
             24 -> bootloadSendImage
             24 -> emberSerialFlushRx
              0 -> emberSerialPrintf
             24 -> emberSerialPrintf
              0 -> emberSerialWaitSend
             24 -> emberSerialWaitSend
             24 -> emberSerialWriteByte
             24 -> halInternalResetWatchDog
             24 -> xmodemReceiveBlock
       32  xmodemReceiveBlock
             32 -> emberSerialFlushRx
             32 -> halCommonCrc16
             32 -> xmodemReadSerialByte


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      24  ?<Constant "Bootload Complete!\r\n">
      32  ?<Constant "ERROR: Image send OTA...">
      44  ?<Constant "Error: cannot forward...">
      56  ?<Constant "Error: cannot forward...">_1
      40  ?<Constant "Please start .ebl upl...">
      20  ?<Constant "RX NAK block %x\r\n">
      16  ?<Constant "blState 0x%x\r\n">
      20  ?<Constant "bootload-utils.c">
      20  ?<Constant "free buffer: %x\r\n">
      36  ?<Constant "message 0x%x is faile...">
      36  ?<Constant "message 0x%x is sent ...">
      24  ?<Constant "sending OTA block %x\r\n">
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
      12  ?Subroutine0
      12  ?Subroutine1
       6  ?Subroutine2
      12  ?Subroutine3
       8  ?Subroutine4
       4  ?Subroutine5
       8  ?Subroutine6
       6  ?Subroutine7
       6  ?Subroutine8
      44  blState
          blMode
          currentRetriesRemaining
          expectedBlockNumber
          currentOTABlock
          actionTimer
          appSerial
          bootloadSerial
          signingKey
          challenge
          lastBlinkTime
          broadcastEui64
          targetAddress
          authBlock
       1  booleanStatus
      72  bootloadBuffer
     176  bootloadSendAuthChallenge
     120  bootloadSendAuthResponse
     170  bootloadSendImage
      26  bootloadUtilInit
      34  bootloadUtilSendAuthResponse
      46  bootloadUtilSendQuery
     170  bootloadUtilSendRequest
      56  bootloadUtilStartBootload
     210  bootloadUtilTick
       1  currentIndex
      40  emberBootloadTransmitCompleteHandler
     672  emberIncomingBootloadMessageHandler
       1  emberStatus
       4  flashStreamCrc
      16  isTheSameEui64
     204  sendRadioMessage
     128  xmodemBlock
      70  xmodemReadSerialByte
     206  xmodemReceiveAndForward
     212  xmodemReceiveBlock

 
   203 bytes in section .bss
    48 bytes in section .data
 2 906 bytes in section .text
 
 2 906 bytes of CODE memory
   251 bytes of DATA memory

Errors: none
Warnings: none
