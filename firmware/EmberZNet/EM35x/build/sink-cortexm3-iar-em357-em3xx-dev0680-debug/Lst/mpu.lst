###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     02/Jul/2013  21:36:42 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\em35x\em357\mpu.c                              #
#    Command line =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\em35x\em357\mpu.c -D DEBUG -D                  #
#                    "BOARD_HEADER=\"hal/micro/cortexm3/em35x/board/dev0680.h #
#                    \"" -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/ia #
#                    r.h\"" -D HAL_MICRO -D CORTEXM3 -D CORTEXM3_EM357 -D     #
#                    PHY_EM3XX -D BOARD_DEV0680 -D                            #
#                    "CONFIGURATION_HEADER=\"app/sensor/sensor-configuration. #
#                    h\"" -D SINK_APP -D EMBER_SERIAL1_MODE=EMBER_SERIAL_FIFO #
#                     -D EMBER_SERIAL1_TX_QUEUE_SIZE=128 -D                   #
#                    EMBER_SERIAL1_RX_QUEUE_SIZE=16 -D EMBER_SERIAL0_DEBUG    #
#                    -D EMBER_SERIAL0_MODE=EMBER_SERIAL_FIFO -D               #
#                    EMBER_SERIAL0_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL0_RX_QUEUE_SIZE=64 -D                        #
#                    SCAN_DEBUG_PRINT_ENABLE -D USE_BOOTLOADER_LIB -D         #
#                    "__SOURCEFILE__=\"mpu.c\"" -lC                           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\            #
#                    --diag_suppress Pa050 -o F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\build\sink-cortexm3-iar-em357-em3xx-dev0 #
#                    680-debug\Obj\ --debug --endian=little --cpu=Cortex-M3   #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I F:\Firmware\emberZNet\firmware\EmberZNet\EM35x #
#                    \hal\micro\cortexm3\em35x\em357\ -I                      #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -I F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\app\sensor\ewb-em357\..\..\..\STACK\ -I  #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\HAL\ -I                             #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -Ohz --use_c++_inline              #
#    List file    =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\mpu.lst     #
#    Object file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Obj\mpu.o       #
#                                                                             #
#                                                                             #
###############################################################################

F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro\cortexm3\em35x\em357\mpu.c
      1          //=============================================================================
      2          // FILE
      3          //   mpu.c - Functions to setup and control the Cortex-M3 MPU
      4          //
      5          // DESCRIPTION
      6          //   This file contains the definitions, data table and software used to
      7          //   setup the MPU.
      8          //
      9          //   Author:
     10          //   Copyright 2008 by Ember Corporation. All rights reserved.             *80*
     11          //=============================================================================
     12          
     13          #include PLATFORM_HEADER
     14          #include "hal/micro/cortexm3/mpu.h"
     15          #include "hal/micro/micro.h"
     16          
     17          #define FLASH_REGION    (0x08000000 + 0x10)
     18          #define PERIPH_REGION   (0x40000000 + 0x11)
     19          #define USERPER_REGION  (0x40008000 + 0x12)
     20          #define SRAM_REGION     (0x20000000 + 0x13)
     21          #define GUARD_REGION    (0x20000000 + 0x14)
     22          #define SPARE0_REGION   (0x20000000 + 0x15)
     23          #define SPARE1_REGION   (0x20000000 + 0x16)
     24          #define SPARE2_REGION   (0x20000000 + 0x17)
     25          
     26          //=============================================================================
     27          // Define the data used to initialize the MPU. Each of the 8 MPU regions
     28          // has a programmable size and various attributes. A region must be a power of
     29          // two in size, and its base address must be a multiple of that size. Regions
     30          // are divided into 8 equal-sized sub-regions that can be individually disabled.
     31          // A region is defined by what is written to MPU_BASE and MPU_ATTR.
     32          // MPU_BASE holds the region base address, with some low order bits ignored
     33          // depending on the region size. If B4 is set, then B3:0 set the region number.
     34          // The MPU_ATTR fields are:
     35          // XN (1 bit) - set to disable instruction execution
     36          // AP (2 bits) - selects Privilege & User access- None, Read-only or Read-Write
     37          // TEX,S,C,B (6 bits) - configures memory type, write ordering, shareable, ...
     38          // SRD (8 bits) - a set bit disables the corresponding sub-region
     39          // SIZE (5 bits) - specifies the region size as a power of two
     40          // ENABLE (1 bit) - set to enable the region, except any disabled sub-regions
     41          //=============================================================================
     42          
     43          // Define MPU regions - note that the default vector table at address 0 and
     44          // the ARM PPB peripherals are always accessible in privileged mode.

   \                                 In section .data, align 4
     45          static mpu_t mpuConfig[NUM_MPU_REGIONS] =
   \                     mpuConfig:
   \   00000000   0x08000010         DC32 134217744, 101443621, 1073741841, 303042591, 1073774610, 319816477
   \              0x060BE825   
   \              0x40000011   
   \              0x1210101F   
   \              0x40008012   
   \              0x1310031D   
   \   00000018   0x20000013         DC32 536870931, 319537179, 536870932, 269156360, 536870933, 319488018
   \              0x130BC01B   
   \              0x20000014   
   \              0x100B0008   
   \              0x20000015   
   \              0x130B0012   
   \   00000030   0x20000016         DC32 536870934, 319488018, 536870935, 319488018
   \              0x130B0012   
   \              0x20000017   
   \              0x130B0012   
     46          {
     47            // Region 0 - Flash, including main, fixed and customer info blocks: 
     48            //            execute, normal, not shareable
     49            // Enabled sub-regions: 08000000 - 0802FFFF, 08040000 - 0804FFFF
     50            { FLASH_REGION,   MATTR(0, PRO_URO, MEM_NORMAL, 0xE8, SIZE_512K, 1) },
     51          
     52            // Region 1 - System peripherals: no execute, non-shared device
     53          //[[
     54          #ifdef EMBER_EMU_TEST
     55            // Enabled sub-regions: 40000000 - 4000FFFF
     56            { PERIPH_REGION,  MATTR(1, PRW_URO, MEM_DEVICE, 0x00, SIZE_64K,  1) },
     57          #else
     58          //]]
     59            // Enabled sub-regions: 40000000 - 40008000, 4000A000 - 4000FFFF
     60            { PERIPH_REGION,  MATTR(1, PRW_URO, MEM_DEVICE, 0x10, SIZE_64K,  1) },
     61          //[[
     62          #endif
     63          //]]
     64          
     65            // Region 2 - User peripherals: no execute, non-shared device
     66            // Enabled sub-regions: 4000A000 - 4000FFFF
     67            { USERPER_REGION, MATTR(1, PRW_URW, MEM_DEVICE, 0x03, SIZE_32K,  1) },
     68          
     69            // Region 3 - SRAM: no execute, normal, not shareable
     70            // Enabled sub-regions: 20000000 - 20002FFF
     71            { SRAM_REGION,    MATTR(1, PRW_URW, MEM_NORMAL, 0xC0, SIZE_16K,  1) },
     72          
     73            // Region 4 - Guard region between the heap and stack
     74            { GUARD_REGION,   MATTR(1, PNA_UNA, MEM_NORMAL, 0x00, HEAP_GUARD_REGION_SIZE, 0) },
     75          
     76            // Regions 5-7 - unused: disabled (otherwise set up for SRAM)
     77            { SPARE0_REGION,  MATTR(1, PRW_URW, MEM_NORMAL, 0x00, SIZE_1K,   0) },
     78            { SPARE1_REGION,  MATTR(1, PRW_URW, MEM_NORMAL, 0x00, SIZE_1K,   0) },
     79            { SPARE2_REGION,  MATTR(1, PRW_URW, MEM_NORMAL, 0x00, SIZE_1K,   0) }
     80          };
     81          
     82          // Load the base address and attributes of all 8 MPU regions, then enable
     83          // the MPU. Even though interrupts should be disabled when this function is
     84          // called, the region loading is performed in an atomic block in case they
     85          // are not disabled. After the regions have been defined, the MPU is enabled.
     86          // To be safe, memory barrier instructions are included to make sure that
     87          // the new MPU setup is in effect before returning to the caller.
     88          //
     89          // Note that the PRIVDEFENA bit is not set in the MPU_CTRL register so the 
     90          // default privileged memory map is not enabled. Disabling the default
     91          // memory map enables faults on core accesses (other than vector reads) to 
     92          // the address ranges shown below.
     93          //
     94          //  Address range
     95          //  Flash (ICODE and DCODE)   no access allowed (read, write or execute)
     96          //    00000000 to 0001FFFF    no access allowed (read, write or execute)
     97          //    00200000 to 00029FFF    write and execute not allowed
     98          //    0002A000 to 07FFFFFF    no access allowed (read, write or execute)
     99          //    08000000 to 081FFFFF    write not allowed
    100          //    08020000 to 1FFFFFFF    no access allowed (read, write or execute)
    101          //  SRAM
    102          //    20000000 to 20001FFF    execute not allowed
    103          //    20002000 to 3FFFFFFF    no access allowed (read, write or execute)
    104          //  Peripheral
    105          //    40010000 to 5FFFFFFF    no access allowed (read, write or execute)
    106          //  External Device / External RAM
    107          //    60000000 to DFFFFFFF    no access allowed (read, write or execute)
    108          

   \                                 In section .text, align 2, keep-with-next
    109          void halInternalEnableMPU(void)
    110          {
    111            halInternalLoadMPU(mpuConfig);
   \                     halInternalEnableMPU:
   \   00000000   0x....             LDR.N    R0,??DataTable3
   \   00000002                      REQUIRE halInternalLoadMPU
   \   00000002                      ;; // Fall through to label halInternalLoadMPU
    112          }
    113          

   \                                 In section .text, align 2, keep-with-next
    114          void halInternalLoadMPU(mpu_t *mp)
    115          {
   \                     halInternalLoadMPU:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    116            int8u i;
    117          
    118            ATOMIC (
    119              MPU_CTRL = 0;       // enable default map while MPU is updated
    120              for (i = 0; i < NUM_MPU_REGIONS; i++) {
    121                MPU_BASE = mp->base;
    122                MPU_ATTR = mp->attr;
    123                mp++;
    124              }
    125              MPU_CTRL = MPU_CTRL_ENABLE;
    126              _executeBarrierInstructions();
    127            )
   \   00000004   0x.... 0x....      BL       _disableBasePri
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x....             LDR.N    R0,??DataTable3_1  ;; 0xe000ed94
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6001             STR      R1,[R0, #+0]
   \   00000010   0x2108             MOVS     R1,#+8
   \                     ??halInternalLoadMPU_0:
   \   00000012   0xF854 0x2B04      LDR      R2,[R4], #+4
   \   00000016   0x6082             STR      R2,[R0, #+8]
   \   00000018   0xF854 0x2B04      LDR      R2,[R4], #+4
   \   0000001C   0x60C2             STR      R2,[R0, #+12]
   \   0000001E   0x1E49             SUBS     R1,R1,#+1
   \   00000020   0xD1F7             BNE.N    ??halInternalLoadMPU_0
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0x.... 0x....      BL       _executeBarrierInstructions
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000030   0x.... 0x....      B.W      _writeBasePri
    128          
    129          }
    130          

   \                                 In section .text, align 2, keep-with-next
    131          void halInternalDisableMPU(void)
    132          {
    133            MPU_CTRL = 0;
   \                     halInternalDisableMPU:
   \   00000000   0x....             LDR.N    R0,??DataTable3_1  ;; 0xe000ed94
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
    134            _executeBarrierInstructions();
   \   00000006   0x.... 0x....      B.W      _executeBarrierInstructions
    135          }
    136          

   \                                 In section .text, align 2, keep-with-next
    137          void halInternalSetMPUGuardRegionStart(int32u baseAddress)
    138          {
   \                     halInternalSetMPUGuardRegionStart:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    139            // Add the region number to the base address so that we can load using the
    140            // quicker method. This will also get rid of any low order bits which are
    141            // invalid in the base address anyways.
    142            baseAddress &= 0xFFFFFFE0;                // Clear the lower 5 bits for region num
    143            baseAddress |= GUARD_REGION & 0x0000001F; // Use the guard region's number
    144          
    145            // Set the base address for the MPU guard region
    146            ATOMIC(
    147              mpuConfig[GUARD_REGION & 0xF].base = baseAddress;
    148              mpuConfig[GUARD_REGION & 0xF].attr = MATTR(1, PNA_UNA, MEM_NORMAL, 0x00, HEAP_GUARD_REGION_SIZE, 1);
    149              );
   \   00000004   0x.... 0x....      BL       _disableBasePri
   \   00000008   0x....             LDR.N    R1,??DataTable3
   \   0000000A   0x0962             LSRS     R2,R4,#+5
   \   0000000C   0x0152             LSLS     R2,R2,#+5
   \   0000000E   0xF042 0x0214      ORR      R2,R2,#0x14
   \   00000012   0x620A             STR      R2,[R1, #+32]
   \   00000014   0x....             LDR.N    R2,??DataTable3_2  ;; 0x100b0009
   \   00000016   0x624A             STR      R2,[R1, #+36]
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x.... 0x....      B.W      _writeBasePri
    150          }
    151          

   \                                 In section .text, align 2, keep-with-next
    152          boolean halInternalIAmAnEmulator(void)
    153          {
   \                     halInternalIAmAnEmulator:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    154            boolean retval;
    155          
    156            ATOMIC(
    157              MPU_CTRL = 0;
    158              _executeBarrierInstructions();
    159              retval =  ((I_AM_AN_EMULATOR & 1) == 1);
    160              MPU_CTRL = MPU_CTRL_ENABLE;
    161              _executeBarrierInstructions();
    162            )
   \   00000002   0x.... 0x....      BL       _disableBasePri
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x....             LDR.N    R5,??DataTable3_1  ;; 0xe000ed94
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6028             STR      R0,[R5, #+0]
   \   0000000E   0x.... 0x....      BL       _executeBarrierInstructions
   \   00000012   0x....             LDR.N    R0,??DataTable3_3  ;; 0x40009000
   \   00000014   0x6806             LDR      R6,[R0, #+0]
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x6028             STR      R0,[R5, #+0]
   \   0000001A   0x.... 0x....      BL       _executeBarrierInstructions
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _writeBasePri
    163            return retval;
   \   00000024   0xF006 0x0001      AND      R0,R6,#0x1
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    164          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     mpuConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xE000ED94         DC32     0xe000ed94

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x100B0009         DC32     0x100b0009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x40009000         DC32     0x40009000

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  halInternalDisableMPU
              0 -> _executeBarrierInstructions
        0  halInternalEnableMPU
              0 -> halInternalLoadMPU
       16  halInternalIAmAnEmulator
             16 -> _disableBasePri
             16 -> _executeBarrierInstructions
             16 -> _writeBasePri
       16  halInternalLoadMPU
             16 -> _disableBasePri
             16 -> _executeBarrierInstructions
              0 -> _writeBasePri
        8  halInternalSetMPUGuardRegionStart
              8 -> _disableBasePri
              0 -> _writeBasePri


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
      10  halInternalDisableMPU
       2  halInternalEnableMPU
      42  halInternalIAmAnEmulator
      52  halInternalLoadMPU
      32  halInternalSetMPUGuardRegionStart
      64  mpuConfig

 
  64 bytes in section .data
 154 bytes in section .text
 
 154 bytes of CODE memory
  64 bytes of DATA memory

Errors: none
Warnings: none
