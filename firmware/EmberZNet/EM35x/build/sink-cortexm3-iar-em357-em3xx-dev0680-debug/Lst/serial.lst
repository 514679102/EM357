###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     02/Jul/2013  21:36:46 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\util\ #
#                    serial\serial.c                                          #
#    Command line =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\util\ #
#                    serial\serial.c -D DEBUG -D                              #
#                    "BOARD_HEADER=\"hal/micro/cortexm3/em35x/board/dev0680.h #
#                    \"" -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/ia #
#                    r.h\"" -D HAL_MICRO -D CORTEXM3 -D CORTEXM3_EM357 -D     #
#                    PHY_EM3XX -D BOARD_DEV0680 -D                            #
#                    "CONFIGURATION_HEADER=\"app/sensor/sensor-configuration. #
#                    h\"" -D SINK_APP -D EMBER_SERIAL1_MODE=EMBER_SERIAL_FIFO #
#                     -D EMBER_SERIAL1_TX_QUEUE_SIZE=128 -D                   #
#                    EMBER_SERIAL1_RX_QUEUE_SIZE=16 -D EMBER_SERIAL0_DEBUG    #
#                    -D EMBER_SERIAL0_MODE=EMBER_SERIAL_FIFO -D               #
#                    EMBER_SERIAL0_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL0_RX_QUEUE_SIZE=64 -D                        #
#                    SCAN_DEBUG_PRINT_ENABLE -D USE_BOOTLOADER_LIB -D         #
#                    "__SOURCEFILE__=\"serial.c\"" -lC                        #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\            #
#                    --diag_suppress Pa050 -o F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\build\sink-cortexm3-iar-em357-em3xx-dev0 #
#                    680-debug\Obj\ --debug --endian=little --cpu=Cortex-M3   #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I F:\Firmware\emberZNet\firmware\EmberZNet\EM35x #
#                    \app\util\serial\ -I F:\Firmware\emberZNet\firmware\Embe #
#                    rZNet\EM35x\app\sensor\ewb-em357\..\..\..\ -I            #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\STACK\ -I                           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\HAL\ -I                             #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -Ohz --use_c++_inline              #
#    List file    =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\serial.lst  #
#    Object file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Obj\serial.o    #
#                                                                             #
#                                                                             #
###############################################################################

F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\util\serial\serial.c
      1          /**
      2           * File: serial.c
      3           * Description: High Level Serial Communications
      4           *
      5           * Culprit(s):  Lee Taylor (lee@ember.com)
      6           *              Richard Kelsey (kelsey@ember.com)
      7           *              Jeff Mathews (jeff@ember.com)
      8           *
      9           * Copyright 2004 by Ember Corporation.  All rights reserved.               *80*
     10           */
     11          
     12          #include PLATFORM_HEADER
     13          #include "stack/include/ember-types.h"
     14          #include "stack/include/error.h"
     15          
     16          //Host processors do not use Ember Message Buffers.
     17          #ifndef EZSP_HOST
     18            #include "stack/include/packet-buffer.h"
     19          #endif
     20          
     21          #include "hal/hal.h"
     22          #include "serial.h"
     23          
     24          #include <stdarg.h>
     25          
     26          #ifdef EMBER_SERIAL_USE_STDIO
     27          #include <stdio.h>
     28          #endif //EMBER_SERIAL_USE_STDIO
     29          
     30          // AppBuilder and Afv2 will define the characteristics of the Serial ports here.
     31          #if defined(ZA_GENERATED_HEADER)
     32            #include ZA_GENERATED_HEADER
     33          #endif
     34          
     35          //Documentary comments:
     36          // To conserve precious flash, there is very little validity checking
     37          //  on the given parameters.  Be sure not to use an invalid port number
     38          //  or a port that is unused.
     39          // Blocking routines will always wait for room (but not buffers - if buffers
     40          //  cannot be allocated, no part of the message will be sent)
     41          // Non-blocking routines will never wait for room, and may cause partial
     42          //  messages to be sent.  If a contiguous message needs to be sent, available
     43          //  space should be checked _before_ calling the appropriate write API.
     44          
     45          //------------------------------------------------------
     46          // Determine if blocking code needs to be enabled
     47          #if defined(EMBER_SERIAL0_BLOCKING) || \
     48              defined(EMBER_SERIAL1_BLOCKING) || \
     49              defined(EMBER_SERIAL2_BLOCKING) || \
     50              defined(EMBER_SERIAL3_BLOCKING) || \
     51              defined(EMBER_SERIAL4_BLOCKING)
     52            #define EM_ENABLE_SERIAL_BLOCKING
     53          #endif
     54          #ifdef EMBER_SERIAL0_BLOCKING
     55            #define EM_SERIAL0_BLOCKSTATE TRUE
     56          #else
     57            #define EM_SERIAL0_BLOCKSTATE FALSE
     58          #endif
     59          #ifdef EMBER_SERIAL1_BLOCKING
     60            #define EM_SERIAL1_BLOCKSTATE TRUE
     61          #else
     62            #define EM_SERIAL1_BLOCKSTATE FALSE
     63          #endif
     64          #ifdef EMBER_SERIAL2_BLOCKING
     65            #define EM_SERIAL2_BLOCKSTATE TRUE
     66          #else
     67            #define EM_SERIAL2_BLOCKSTATE FALSE
     68          #endif
     69          #ifdef EMBER_SERIAL3_BLOCKING
     70            #define EM_SERIAL3_BLOCKSTATE TRUE
     71          #else
     72            #define EM_SERIAL3_BLOCKSTATE FALSE
     73          #endif
     74          #ifdef EMBER_SERIAL4_BLOCKING
     75            #define EM_SERIAL4_BLOCKSTATE TRUE
     76          #else
     77            #define EM_SERIAL4_BLOCKSTATE FALSE
     78          #endif
     79          
     80          #ifndef EMBER_SERIAL_USE_STDIO
     81          //------------------------------------------------------
     82          // Memory allocations for Queue data structures
     83          
     84          //Macros to define fifo and buffer queues, can't use a typedef becuase the size
     85          // of the fifo array in the queues can change
     86          #define DEFINE_FIFO_QUEUE(qSize, qName)             \
     87            static struct {                                   \
     88              /*! Indexes of next byte to send*/              \
     89              int16u head;                                     \
     90              /*! Index of where to enqueue next message*/    \
     91              int16u tail;                                     \
     92              /*! Number of bytes queued*/                    \
     93              volatile int16u used;                            \
     94              /*! FIFO of queue data*/                        \
     95              int8u fifo[qSize];                              \
     96            } qName;
     97          
     98          #define DEFINE_BUFFER_QUEUE(qSize, qName)           \
     99            static struct {                                   \
    100              /*! Indexes of next message to send*/           \
    101              int8u head;                                     \
    102              /*! Index of where to enqueue next message*/    \
    103              int8u tail;                                     \
    104              /*! Number of messages queued*/                 \
    105              volatile int8u used;                            \
    106              int8u dead;                                     \
    107              EmberMessageBuffer currentBuffer;               \
    108              int8u *nextByte, *lastByte;                     \
    109              /*! FIFO of messages*/                          \
    110              EmSerialBufferQueueEntry fifo[qSize];           \
    111            } qName;
    112          
    113          
    114          // Allocate Appropriate TX Queue for port 0
    115          #if EMBER_SERIAL0_MODE == EMBER_SERIAL_FIFO

   \                                 In section .bss, align 4
    116            DEFINE_FIFO_QUEUE(EMBER_SERIAL0_TX_QUEUE_SIZE,emSerial0TxQueue)
   \                     emSerial0TxQueue:
   \   00000000                      DS8 136
    117            #define EM_SERIAL0_TX_QUEUE_ADDR (&emSerial0TxQueue)
    118          #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_BUFFER
    119            DEFINE_BUFFER_QUEUE(EMBER_SERIAL0_TX_QUEUE_SIZE,emSerial0TxQueue)
    120            #define EM_SERIAL0_TX_QUEUE_ADDR (&emSerial0TxQueue)
    121          #elif EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED || \
    122                EMBER_SERIAL0_MODE == EMBER_SERIAL_LOWLEVEL
    123            #define EM_SERIAL0_TX_QUEUE_ADDR (NULL)
    124            #define EMBER_SERIAL0_TX_QUEUE_SIZE 0
    125            #define EMBER_SERIAL0_RX_QUEUE_SIZE 0
    126          #endif
    127          
    128          // Allocate Appropriate TX Queue for port 1
    129          #if EMBER_SERIAL1_MODE == EMBER_SERIAL_FIFO

   \                                 In section .bss, align 4
    130            DEFINE_FIFO_QUEUE(EMBER_SERIAL1_TX_QUEUE_SIZE,emSerial1TxQueue)
   \                     emSerial1TxQueue:
   \   00000000                      DS8 136
    131            #define EM_SERIAL1_TX_QUEUE_ADDR (&emSerial1TxQueue)
    132          #elif EMBER_SERIAL1_MODE == EMBER_SERIAL_BUFFER
    133            DEFINE_BUFFER_QUEUE(EMBER_SERIAL1_TX_QUEUE_SIZE,emSerial1TxQueue)
    134            #define EM_SERIAL1_TX_QUEUE_ADDR (&emSerial1TxQueue)
    135          #elif EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED || \
    136                EMBER_SERIAL1_MODE == EMBER_SERIAL_LOWLEVEL 
    137            #define EM_SERIAL1_TX_QUEUE_ADDR (NULL)
    138            #define EMBER_SERIAL1_TX_QUEUE_SIZE 0
    139            #define EMBER_SERIAL1_RX_QUEUE_SIZE 0
    140          #endif
    141          
    142          // Allocate Appropriate TX Queue for port 2
    143          #if EMBER_SERIAL2_MODE == EMBER_SERIAL_FIFO
    144            DEFINE_FIFO_QUEUE(EMBER_SERIAL2_TX_QUEUE_SIZE,emSerial2TxQueue)
    145            #define EM_SERIAL2_TX_QUEUE_ADDR (&emSerial2TxQueue)
    146          #elif EMBER_SERIAL2_MODE == EMBER_SERIAL_BUFFER
    147            DEFINE_BUFFER_QUEUE(EMBER_SERIAL2_TX_QUEUE_SIZE,emSerial2TxQueue)
    148            #define EM_SERIAL2_TX_QUEUE_ADDR (&emSerial2TxQueue)
    149          #elif EMBER_SERIAL2_MODE == EMBER_SERIAL_UNUSED || \
    150                EMBER_SERIAL2_MODE == EMBER_SERIAL_LOWLEVEL 
    151            #define EM_SERIAL2_TX_QUEUE_ADDR (NULL)
    152            #define EMBER_SERIAL2_TX_QUEUE_SIZE 0
    153            #define EMBER_SERIAL2_RX_QUEUE_SIZE 0
    154          #endif
    155          
    156          // Allocate Appropriate TX Queue for port 3
    157          #if EMBER_SERIAL3_MODE == EMBER_SERIAL_FIFO
    158            DEFINE_FIFO_QUEUE(EMBER_SERIAL3_TX_QUEUE_SIZE,emSerial3TxQueue)
    159            #define EM_SERIAL3_TX_QUEUE_ADDR (&emSerial3TxQueue)
    160          #elif EMBER_SERIAL3_MODE == EMBER_SERIAL_BUFFER
    161            DEFINE_BUFFER_QUEUE(EMBER_SERIAL3_TX_QUEUE_SIZE,emSerial3TxQueue)
    162            #define EM_SERIAL3_TX_QUEUE_ADDR (&emSerial3TxQueue)
    163          #elif EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED || \
    164                EMBER_SERIAL3_MODE == EMBER_SERIAL_LOWLEVEL 
    165            #define EM_SERIAL3_TX_QUEUE_ADDR (NULL)
    166            #define EMBER_SERIAL3_TX_QUEUE_SIZE 0
    167            #define EMBER_SERIAL3_RX_QUEUE_SIZE 0
    168          #endif
    169          
    170          // Allocate Appropriate TX Queue for port 4
    171          #if EMBER_SERIAL4_MODE == EMBER_SERIAL_FIFO
    172            DEFINE_FIFO_QUEUE(EMBER_SERIAL4_TX_QUEUE_SIZE,emSerial4TxQueue)
    173            #define EM_SERIAL4_TX_QUEUE_ADDR (&emSerial4TxQueue)
    174          #elif EMBER_SERIAL4_MODE == EMBER_SERIAL_BUFFER
    175            DEFINE_BUFFER_QUEUE(EMBER_SERIAL4_TX_QUEUE_SIZE,emSerial4TxQueue)
    176            #define EM_SERIAL4_TX_QUEUE_ADDR (&emSerial4TxQueue)
    177          #elif EMBER_SERIAL4_MODE == EMBER_SERIAL_UNUSED || \
    178                EMBER_SERIAL4_MODE == EMBER_SERIAL_LOWLEVEL 
    179            #define EM_SERIAL4_TX_QUEUE_ADDR (NULL)
    180            #define EMBER_SERIAL4_TX_QUEUE_SIZE 0
    181            #define EMBER_SERIAL4_RX_QUEUE_SIZE 0
    182          #endif
    183          
    184          // Allocate RX Queues (Always FIFOs)
    185          #if EMBER_SERIAL0_MODE != EMBER_SERIAL_UNUSED

   \                                 In section .bss, align 4
    186            DEFINE_FIFO_QUEUE(EMBER_SERIAL0_RX_QUEUE_SIZE,emSerial0RxQueue)
   \                     emSerial0RxQueue:
   \   00000000                      DS8 72
    187            #define EM_SERIAL0_RX_QUEUE_ADDR (&emSerial0RxQueue)
    188          #else
    189            #define EM_SERIAL0_RX_QUEUE_ADDR (NULL)
    190          #endif
    191          
    192          #if EMBER_SERIAL1_MODE != EMBER_SERIAL_UNUSED

   \                                 In section .bss, align 4
    193            DEFINE_FIFO_QUEUE(EMBER_SERIAL1_RX_QUEUE_SIZE,emSerial1RxQueue)
   \                     emSerial1RxQueue:
   \   00000000                      DS8 24
    194            #define EM_SERIAL1_RX_QUEUE_ADDR (&emSerial1RxQueue)
    195          #else
    196            #define EM_SERIAL1_RX_QUEUE_ADDR (NULL)
    197            #define emSerial1RxQueue (NULL)
    198          #endif
    199          
    200          #if EMBER_SERIAL2_MODE != EMBER_SERIAL_UNUSED
    201            DEFINE_FIFO_QUEUE(EMBER_SERIAL2_RX_QUEUE_SIZE,emSerial2RxQueue)
    202            #define EM_SERIAL2_RX_QUEUE_ADDR (&emSerial2RxQueue)
    203          #else
    204            #define EM_SERIAL2_RX_QUEUE_ADDR (NULL)
    205            #define emSerial2RxQueue (NULL)
    206          #endif
    207          
    208          #if EMBER_SERIAL3_MODE != EMBER_SERIAL_UNUSED
    209            DEFINE_FIFO_QUEUE(EMBER_SERIAL3_RX_QUEUE_SIZE,emSerial3RxQueue)
    210            #define EM_SERIAL3_RX_QUEUE_ADDR (&emSerial3RxQueue)
    211          #else
    212            #define EM_SERIAL3_RX_QUEUE_ADDR (NULL)
    213            #define emSerial3RxQueue (NULL)
    214          #endif
    215          
    216          #if EMBER_SERIAL4_MODE != EMBER_SERIAL_UNUSED
    217            DEFINE_FIFO_QUEUE(EMBER_SERIAL4_RX_QUEUE_SIZE,emSerial4RxQueue)
    218            #define EM_SERIAL4_RX_QUEUE_ADDR (&emSerial4RxQueue)
    219          #else
    220            #define EM_SERIAL4_RX_QUEUE_ADDR (NULL)
    221            #define emSerial4RxQueue (NULL)
    222          #endif
    223          
    224          //------------------------------------------------------
    225          // Easy access to data structures for a particular port
    226          
    227          // The FOR_EACH_PORT(CAST,PREFIX_,_SUFFIX) macro will expand in to something like:
    228          //    CAST(PREFIX_0_SUFFIX),
    229          //    CAST(PREFIX_1_SUFFIX)
    230          // with a line & number for each port of EM_NUM_SERIAL_PORTS
    231          
    232          // Data structure for referencing TX Queues
    233          //  (allows for different modes and queue sizes)
    234          void *emSerialTxQueues[EM_NUM_SERIAL_PORTS] = 
    235            { FOR_EACH_PORT( (void *),EM_SERIAL,_TX_QUEUE_ADDR ) };
    236          

   \                                 In section .text, align 4, keep-with-next
    237          int16u PGM emSerialTxQueueSizes[EM_NUM_SERIAL_PORTS] =
   \                     emSerialTxQueueSizes:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 0
   \              0x0000 0x0000
    238            { FOR_EACH_PORT( (int16u),EMBER_SERIAL,_TX_QUEUE_SIZE ) };
    239          

   \                                 In section .rodata, align 4, keep-with-next
    240          int16u PGM emSerialTxQueueMasks[EM_NUM_SERIAL_PORTS] =
   \                     emSerialTxQueueMasks:
   \   00000000   0x007F 0x007F      DC16 127, 127, 65535, 65535
   \              0xFFFF 0xFFFF
    241            { FOR_EACH_PORT( (int16u),EMBER_SERIAL,_TX_QUEUE_SIZE-1 ) };
    242          
    243          // Data structure for referencing RX Queues
    244          //  (allows for different queue sizes)
    245          EmSerialFifoQueue *emSerialRxQueues[EM_NUM_SERIAL_PORTS] = 
    246            { FOR_EACH_PORT( (EmSerialFifoQueue *),EM_SERIAL,_RX_QUEUE_ADDR ) };
    247          

   \                                 In section .rodata, align 4, keep-with-next
    248          int16u PGM emSerialRxQueueSizes[EM_NUM_SERIAL_PORTS] =
   \                     emSerialRxQueueSizes:
   \   00000000   0x0040 0x0010      DC16 64, 16, 0, 0
   \              0x0000 0x0000
    249            { FOR_EACH_PORT( (int16u),EMBER_SERIAL,_RX_QUEUE_SIZE ) };
    250          
    251          // In-flash data structure for determined port mode

   \                                 In section .text, align 4, keep-with-next
    252          int8u PGM emSerialPortModes[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialPortModes:
   \   00000000   0x01 0x01          DC8 1, 1, 0, 0
   \              0x00 0x00    
    253            { FOR_EACH_PORT( (int8u),EMBER_SERIAL,_MODE ) };
    254          
    255          //Compatibility code for the AVR Atmega
    256          //If an AVR Atmega is used, then emSerialTx(/Rx)QueueWraps map to
    257          //emSerialTx(/Rx)QueueMasks, otherwise they map to emSerialTx(/Rx)QueueSizes
    258          #ifdef AVR_ATMEGA
    259          int8u PGM emSerialTxQueueWraps[EM_NUM_SERIAL_PORTS] = 
    260            { FOR_EACH_PORT( (int8u), EMBER_SERIAL,_TX_QUEUE_SIZE-1 ) };
    261          int8u PGM emSerialRxQueueWraps[EM_NUM_SERIAL_PORTS] = 
    262            { FOR_EACH_PORT( (int8u), EMBER_SERIAL,_RX_QUEUE_SIZE-1 ) };
    263          #else

   \                                 In section .text, align 4, keep-with-next
    264          int16u PGM emSerialTxQueueWraps[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialTxQueueWraps:
   \   00000000   0x0080 0x0080      DC16 128, 128, 0, 0
   \              0x0000 0x0000
    265            { FOR_EACH_PORT( (int16u), EMBER_SERIAL,_TX_QUEUE_SIZE ) };

   \                                 In section .text, align 4, keep-with-next
    266          int16u PGM emSerialRxQueueWraps[EM_NUM_SERIAL_PORTS] = 
   \                     emSerialRxQueueWraps:
   \   00000000   0x0040 0x0010      DC16 64, 16, 0, 0
   \              0x0000 0x0000

   \                                 In section .data, align 4
    267            { FOR_EACH_PORT( (int16u), EMBER_SERIAL,_RX_QUEUE_SIZE ) };
    268          #endif
    269          
    270          #ifdef EM_ENABLE_SERIAL_BLOCKING
    271          // In-flash data structure for blocking mode
    272          boolean PGM emSerialBlocking[EM_NUM_SERIAL_PORTS] =
    273            { FOR_EACH_PORT( (boolean),EM_SERIAL,_BLOCKSTATE ) };
    274          #endif
    275          
    276          int8u emSerialRxError[EM_NUM_SERIAL_PORTS] = {EMBER_SUCCESS,};
   \                     emSerialRxError:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    277          int16u emSerialRxErrorIndex[EM_NUM_SERIAL_PORTS] = {0,};
   \                     emSerialRxErrorIndex:
   \   00000004   0x0000 0x0000      DC16 0, 0, 0, 0
   \              0x0000 0x0000
   \                     emSerialTxQueues:
   \   0000000C   0x........         DC32 emSerial0TxQueue, emSerial1TxQueue, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \                     emSerialRxQueues:
   \   0000001C   0x........         DC32 emSerial0RxQueue, emSerial1RxQueue, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
    278          #endif //EMBER_SERIAL_USE_STDIO
    279          

   \                                 In section .text, align 4, keep-with-next
    280          static PGM int32u powers10[9] = {
   \                     powers10:
   \   00000000   0x3B9ACA00         DC32 1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100
   \              0x05F5E100   
   \              0x00989680   
   \              0x000F4240   
   \              0x000186A0   
   \              0x00002710   
   \              0x000003E8   
   \              0x00000064   
   \   00000020   0x0000000A         DC32 10
    281            1000000000,
    282            100000000,
    283            10000000,
    284            1000000,
    285            100000,
    286            10000,
    287            1000,
    288            100,
    289            10
    290          };
    291          
    292          
    293          
    294          //------------------------------------------------------
    295          // Private functions
    296          
    297          // --------------------------------
    298          // A simple printf() implementation
    299          // Supported format specifiers are:
    300          //  %% - percent sign
    301          //  %c - single byte character
    302          //  %s - ram string
    303          //  %p - flash string  (non-standard)
    304          //  %u - 2-byte unsigned decimal
    305          //  %d - 2-byte signed decimal
    306          //  %x %2x %4x - 1, 2, 4 BYTE hex value (always 0 padded) (non-standard)
    307          //    Non-standard behavior: Normally a number after a % is interpreted to be
    308          //    a minimum character width, and the value is not zero padded unless
    309          //    there is a zero before the minimum width value.
    310          //    i.e. '%2x' for the int16u value 0xb prints " b", while '%02x' would print
    311          //    "0b".
    312          //    Ember assumes the number after the % and before the 'x' to be the number
    313          //    of BYTES, and all hex values are left-justified zero padded.
    314          // 
    315          // A few macros and a function help make this readable:
    316          //   - flush the local buffer to the output
    317          //   - ensure that there is some room in the local buffer
    318          //   - add a single byte to the local buffer
    319          //   - convert a nibble to its ascii hex character
    320          //   - convert an int16u to a decimal string
    321          // Most of these only work within the emPrintfInternal() function.
    322          
    323          // Current champion is %4x which writes 8 bytes.  (%s and %p can write
    324          // more, but they do their own overflow checks).
    325          #define LOCAL_BUFFER_SIZE 16
    326          #define MAX_SINGLE_COMMAND_BYTES 8
    327          
    328          #define flushBuffer() \
    329          do { count = localBufferPointer - localBuffer;     \
    330               if (flushHandler(port, localBuffer, count) != EMBER_SUCCESS) \
    331                 goto fail;                                  \
    332               total += count;                               \
    333               localBufferPointer = localBuffer;             \
    334               (void)localBufferPointer;                     \
    335          } while (FALSE)                                           
    336          
    337          #define addByte(byte) \
    338          do { *(localBufferPointer++) = (byte); } while (FALSE)
    339          

   \                                 In section .text, align 2, keep-with-next
    340          int8u *emWriteHexInternal(int8u *charBuffer, int16u value, int8u charCount)
    341          {
   \                     emWriteHexInternal:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    342            int8u c = charCount;
   \   00000002   0x4613             MOV      R3,R2
    343            charBuffer += charCount;
   \   00000004   0x1810             ADDS     R0,R2,R0
   \   00000006   0xE002             B.N      ??emWriteHexInternal_0
    344            for (; c; c--) {
    345              int8u n = value & 0x0F;
    346              value = value >> 4;
    347              *(--charBuffer) = n + (n < 10
    348                                     ? '0'
    349                                     : 'A' - 10);
   \                     ??emWriteHexInternal_1:
   \   00000008   0x19A4             ADDS     R4,R4,R6
   \   0000000A   0x702C             STRB     R4,[R5, #+0]
   \   0000000C   0x1E5B             SUBS     R3,R3,#+1
   \                     ??emWriteHexInternal_0:
   \   0000000E   0xB2DB             UXTB     R3,R3
   \   00000010   0xB14B             CBZ.N    R3,??emWriteHexInternal_2
   \   00000012   0xF001 0x060F      AND      R6,R1,#0xF
   \   00000016   0x0909             LSRS     R1,R1,#+4
   \   00000018   0x1E45             SUBS     R5,R0,#+1
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x2E0A             CMP      R6,#+10
   \   0000001E   0xBF34             ITE      CC 
   \   00000020   0x2430             MOVCC    R4,#+48
   \   00000022   0x2437             MOVCS    R4,#+55
   \   00000024   0xE7F0             B.N      ??emWriteHexInternal_1
    350            }
    351            return charBuffer + charCount;
   \                     ??emWriteHexInternal_2:
   \   00000026   0x1810             ADDS     R0,R2,R0
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    352          }
    353          
    354          // This function will write a decimal ASCII string to buffer 
    355          // containing the passed 'value'.  Includes negative sign, if applicable.
    356          // Returns the number of bytes written.
    357          
    358          static int8u decimalStringWrite(int32s value, int8u* buffer)
    359          {
    360            int8u length = 0;
    361          
    362            // We introduce this variable to accomodate the actual value to be printed.
    363            // This is necessary for handling the case in which we print -2147483648,
    364            // since we need to flip the sign and an int32s can represent up to 2147483647
    365            // while an int32s can represent an integer as big as 4294967295.
    366            int32u printValue = (int32u)value;
    367          
    368            // If the most significant bit is set to 1, i.e., if value is negative.
    369            if (value & 0x80000000L)
    370            {
    371              buffer[length++] = '-';
    372          
    373              // Since we are assigning to an int32u we can safetly flip the sign and get
    374              // the absolute value.
    375              printValue = -value;
    376            }
    377          
    378            {
    379              int8u i;
    380              boolean printedLeadingNonZeroValue = FALSE;
    381              // To prevent using 32-bit divide or modulus,
    382              // since those operations are expensive on a 16-bit processor,
    383              // we use subtraction and a constant array with powers of 10.
    384              for (i = 0; i < 9; i++) {
    385                int8u digit = 0;
    386                while (printValue >= powers10[i]) {
    387                  printValue -= powers10[i];
    388                  digit++;
    389                }
    390                if (digit != 0 || printedLeadingNonZeroValue) {
    391                  buffer[length++] = '0' + digit;
    392                  printedLeadingNonZeroValue = TRUE;
    393                }
    394              }
    395              buffer[length++] = '0' + printValue;
    396          
    397              return length;
    398            }
    399          }
    400          
    401          // Returns number of characters written

   \                                 In section .text, align 2, keep-with-next
    402          int8u emPrintfInternal(emPrintfFlushHandler flushHandler, 
    403                                 int8u port,
    404                                 PGM_P string, 
    405                                 va_list args)
    406          {
   \                     emPrintfInternal:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4614             MOV      R4,R2
   \   0000000C   0x469B             MOV      R11,R3
    407            int8u localBuffer[LOCAL_BUFFER_SIZE + MAX_SINGLE_COMMAND_BYTES];
    408            int8u *localBufferPointer = localBuffer;
   \   0000000E   0xAD01             ADD      R5,SP,#+4
    409            int8u *localBufferLimit = localBuffer + LOCAL_BUFFER_SIZE;
    410            int8u count;
    411            int8u total = 0;
   \   00000010   0x2700             MOVS     R7,#+0
   \   00000012   0xA801             ADD      R0,SP,#+4
   \   00000014   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000018   0xE01B             B.N      ??emPrintfInternal_0
    412          
    413            for (; *string; string++) {
    414              int8u next = *string;
    415              if (next != '%')
    416                addByte(next);
    417              else {
    418                string += 1;
    419                switch (*string) {
    420                case '%':
    421                  // escape for printing "%"
    422                  addByte('%');
    423                  break;
    424                case 'c':
    425                  // character
    426                  addByte(va_arg(args, unsigned int) & 0xFF);
    427                  break;
    428                case 'p': 
    429                  // only avr needs to special-case the pgm handling, all other current
    430                  //  platforms fall through to standard string handling.
    431                  #ifdef AVR_ATMEGA
    432                    {
    433                    // flash string
    434                    PGM_P arg = va_arg(args, PGM_P);
    435                    while (TRUE) {
    436                      int8u ch = *arg++;
    437                      if (ch == '\0')
    438                        break;
    439                      *(localBufferPointer++) = ch;
    440                      if (localBufferLimit <= localBufferPointer)
    441                        flushBuffer();
    442                    }
    443                    break;
    444                  }
    445                  #endif
    446                case 's': {
    447                  // string
    448                  int8u len;
    449                  int8u *arg = va_arg(args, int8u *);
    450                  flushBuffer();
    451                  for (len=0; arg[len] != '\0'; len++) {};
    452                  if (flushHandler(port, arg, len) != EMBER_SUCCESS)
    453                    goto fail;
    454                  total += len;
    455                  break; }
    456          
    457                // Note: We don't support printing unsigned 32-bit values.
    458                case 'l':         // signed 4-byte
    459                case 'u':         // unsigned 2-byte
    460                case 'd': {       // signed 2-byte
    461                  int32s value;
    462                  if (*string == 'l') {
    463                    value = va_arg(args, long int);
    464                  } else if (*string == 'u') { // Need when sizeof(int) != sizeof(int16u)
    465                    value = va_arg(args, unsigned int);
    466                  } else {
    467                    value = va_arg(args, int);
    468                  }
    469                  localBufferPointer += decimalStringWrite(value, localBufferPointer);
    470                  break;
    471                }
    472                case 'x':
    473                case 'X': {
    474                  // single hex byte (always prints 2 chars, ex: 0A)
    475                  int8u data = va_arg(args, int);
    476                 
    477                  localBufferPointer = emWriteHexInternal(localBufferPointer, data, 2);
    478                  break; }
    479                case '2':
    480                  // %2x only, 2 hex bytes (always prints 4 chars)
    481                case '4':
    482                  // %4x only, 4 hex bytes (always prints 8 chars)
    483                  string += 1;
    484                  if (*string != 'x' && *string != 'X') {
    485                    string -= 1;
    486                  } else if (*(string - 1) == '2') {
    487                    int16u data = va_arg(args, int);
    488                    localBufferPointer = emWriteHexInternal(localBufferPointer, data, 4);
    489                  } else {
    490                    int32u data = va_arg(args, int32u);
   \                     ??emPrintfInternal_1:
   \   0000001A   0xF85B 0xAB04      LDR      R10,[R11], #+4
    491                    // On the AVR at least, the code size is smaller if we limit the
    492                    // emWriteHexInternal() code to 16-bit numbers and call it twice in
    493                    // this case.  Other processors may have a different tradeoff.
    494                    localBufferPointer = emWriteHexInternal(localBufferPointer, 
    495                                                        (int16u) (data >> 16), 
    496                                                        4);
   \   0000001E   0x2204             MOVS     R2,#+4
   \   00000020   0xEA4F 0x411A      LSR      R1,R10,#+16
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       emWriteHexInternal
    497                    localBufferPointer = emWriteHexInternal(localBufferPointer, 
    498                                                        (int16u) data, 
    499                                                        4);
   \   0000002A   0x2204             MOVS     R2,#+4
   \   0000002C   0xFA1F 0xF18A      UXTH     R1,R10
   \                     ??emPrintfInternal_2:
   \   00000030   0x.... 0x....      BL       emWriteHexInternal
   \   00000034   0x4605             MOV      R5,R0
    500                  }
    501                  break;
    502                case '\0':
    503                  goto done;
    504                default: {
    505                }
    506                } //close switch.
    507              }
    508              if (localBufferLimit <= localBufferPointer)
   \                     ??emPrintfInternal_3:
   \   00000036   0xA805             ADD      R0,SP,#+20
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD309             BCC.N    ??emPrintfInternal_4
    509                flushBuffer();
   \   0000003C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000040   0x1A2E             SUBS     R6,R5,R0
   \   00000042   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD131             BNE.N    ??emPrintfInternal_5
   \   0000004A   0x19F7             ADDS     R7,R6,R7
   \   0000004C   0xB2FF             UXTB     R7,R7
   \   0000004E   0xAD01             ADD      R5,SP,#+4
   \                     ??emPrintfInternal_4:
   \   00000050   0x1C64             ADDS     R4,R4,#+1
   \                     ??emPrintfInternal_0:
   \   00000052   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000056   0x1A2E             SUBS     R6,R5,R0
   \   00000058   0x7820             LDRB     R0,[R4, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD007             BEQ.N    ??emPrintfInternal_6
   \   0000005E   0x2825             CMP      R0,#+37
   \   00000060   0xD002             BEQ.N    ??emPrintfInternal_7
   \                     ??emPrintfInternal_8:
   \   00000062   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   00000066   0xE7E6             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_7:
   \   00000068   0xF814 0x0F01      LDRB     R0,[R4, #+1]!
   \   0000006C   0x2800             CMP      R0,#+0
   \                     ??emPrintfInternal_6:
   \   0000006E   0xD076             BEQ.N    ??emPrintfInternal_9
   \   00000070   0x2825             CMP      R0,#+37
   \   00000072   0xD0F6             BEQ.N    ??emPrintfInternal_8
   \   00000074   0x2832             CMP      R0,#+50
   \   00000076   0xBF18             IT       NE 
   \   00000078   0x2834             CMPNE    R0,#+52
   \   0000007A   0xD05F             BEQ.N    ??emPrintfInternal_10
   \   0000007C   0x2858             CMP      R0,#+88
   \   0000007E   0xD057             BEQ.N    ??emPrintfInternal_11
   \   00000080   0x2863             CMP      R0,#+99
   \   00000082   0xD00C             BEQ.N    ??emPrintfInternal_12
   \   00000084   0x2864             CMP      R0,#+100
   \   00000086   0xBF18             IT       NE 
   \   00000088   0x286C             CMPNE    R0,#+108
   \   0000008A   0xD025             BEQ.N    ??emPrintfInternal_13
   \   0000008C   0x2870             CMP      R0,#+112
   \   0000008E   0xBF18             IT       NE 
   \   00000090   0x2873             CMPNE    R0,#+115
   \   00000092   0xD007             BEQ.N    ??emPrintfInternal_14
   \   00000094   0x2875             CMP      R0,#+117
   \   00000096   0xD01F             BEQ.N    ??emPrintfInternal_13
   \   00000098   0x2878             CMP      R0,#+120
   \   0000009A   0xD049             BEQ.N    ??emPrintfInternal_11
   \   0000009C   0xE7CB             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_12:
   \   0000009E   0xF85B 0x0B04      LDR      R0,[R11], #+4
   \   000000A2   0xE7DE             B.N      ??emPrintfInternal_8
   \                     ??emPrintfInternal_14:
   \   000000A4   0xF85B 0xAB04      LDR      R10,[R11], #+4
   \   000000A8   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   000000AC   0x2800             CMP      R0,#+0
   \                     ??emPrintfInternal_5:
   \   000000AE   0xD15C             BNE.N    ??emPrintfInternal_15
   \   000000B0   0x19F7             ADDS     R7,R6,R7
   \   000000B2   0xB2FF             UXTB     R7,R7
   \   000000B4   0xAD01             ADD      R5,SP,#+4
   \   000000B6   0x2600             MOVS     R6,#+0
   \   000000B8   0xE000             B.N      ??emPrintfInternal_16
   \                     ??emPrintfInternal_17:
   \   000000BA   0x1C76             ADDS     R6,R6,#+1
   \                     ??emPrintfInternal_16:
   \   000000BC   0xB2F6             UXTB     R6,R6
   \   000000BE   0xF816 0x000A      LDRB     R0,[R6, R10]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD1F9             BNE.N    ??emPrintfInternal_17
   \   000000C6   0x4632             MOV      R2,R6
   \   000000C8   0x4651             MOV      R1,R10
   \   000000CA   0x4648             MOV      R0,R9
   \   000000CC   0x47C0             BLX      R8
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD14B             BNE.N    ??emPrintfInternal_15
   \   000000D2   0x19F7             ADDS     R7,R6,R7
   \   000000D4   0xB2FF             UXTB     R7,R7
   \   000000D6   0xE7AE             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_13:
   \   000000D8   0xF85B 0x0B04      LDR      R0,[R11], #+4
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD503             BPL.N    ??emPrintfInternal_18
   \   000000E2   0x212D             MOVS     R1,#+45
   \   000000E4   0x7029             STRB     R1,[R5, #+0]
   \   000000E6   0x2101             MOVS     R1,#+1
   \   000000E8   0x4240             RSBS     R0,R0,#+0
   \                     ??emPrintfInternal_18:
   \   000000EA   0x2300             MOVS     R3,#+0
   \   000000EC   0x2200             MOVS     R2,#+0
   \                     ??emPrintfInternal_19:
   \   000000EE   0xF04F 0x0C00      MOV      R12,#+0
   \   000000F2   0xE002             B.N      ??emPrintfInternal_20
   \                     ??emPrintfInternal_21:
   \   000000F4   0x1B80             SUBS     R0,R0,R6
   \   000000F6   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??emPrintfInternal_20:
   \   000000FA   0x.... 0x....      ADR.W    R6,powers10
   \   000000FE   0xF856 0x6022      LDR      R6,[R6, R2, LSL #+2]
   \   00000102   0x42B0             CMP      R0,R6
   \   00000104   0xD2F6             BCS.N    ??emPrintfInternal_21
   \   00000106   0xEA43 0x060C      ORR      R6,R3,R12
   \   0000010A   0xB2F6             UXTB     R6,R6
   \   0000010C   0x2E00             CMP      R6,#+0
   \   0000010E   0xD005             BEQ.N    ??emPrintfInternal_22
   \   00000110   0xB2C9             UXTB     R1,R1
   \   00000112   0xF10C 0x0330      ADD      R3,R12,#+48
   \   00000116   0x554B             STRB     R3,[R1, R5]
   \   00000118   0x1C49             ADDS     R1,R1,#+1
   \   0000011A   0x2301             MOVS     R3,#+1
   \                     ??emPrintfInternal_22:
   \   0000011C   0x1C52             ADDS     R2,R2,#+1
   \   0000011E   0x2A09             CMP      R2,#+9
   \   00000120   0xDBE5             BLT.N    ??emPrintfInternal_19
   \   00000122   0xB2C9             UXTB     R1,R1
   \   00000124   0x3030             ADDS     R0,R0,#+48
   \   00000126   0x5548             STRB     R0,[R1, R5]
   \   00000128   0x1C48             ADDS     R0,R1,#+1
   \   0000012A   0xB2C0             UXTB     R0,R0
   \   0000012C   0x1945             ADDS     R5,R0,R5
   \                     ??emPrintfInternal_23:
   \   0000012E   0xE782             B.N      ??emPrintfInternal_3
   \                     ??emPrintfInternal_11:
   \   00000130   0xF85B 0x1B04      LDR      R1,[R11], #+4
   \   00000134   0x2202             MOVS     R2,#+2
   \   00000136   0xB2C9             UXTB     R1,R1
   \                     ??emPrintfInternal_24:
   \   00000138   0x4628             MOV      R0,R5
   \   0000013A   0xE779             B.N      ??emPrintfInternal_2
   \                     ??emPrintfInternal_10:
   \   0000013C   0xF814 0x0F01      LDRB     R0,[R4, #+1]!
   \   00000140   0x2878             CMP      R0,#+120
   \   00000142   0xBF1C             ITT      NE 
   \   00000144   0x2858             CMPNE    R0,#+88
   \   00000146   0x1E64             SUBNE    R4,R4,#+1
   \   00000148   0xD1F1             BNE.N    ??emPrintfInternal_23
   \   0000014A   0xF814 0x0C01      LDRB     R0,[R4, #-1]
   \   0000014E   0x2832             CMP      R0,#+50
   \   00000150   0xF47F 0xAF63      BNE.W    ??emPrintfInternal_1
   \   00000154   0xF85B 0x1B04      LDR      R1,[R11], #+4
   \   00000158   0x2204             MOVS     R2,#+4
   \   0000015A   0xB289             UXTH     R1,R1
   \   0000015C   0xE7EC             B.N      ??emPrintfInternal_24
    510            }
    511            
    512           done:
    513            flushBuffer();
   \                     ??emPrintfInternal_9:
   \   0000015E   0x.... 0x....      BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0:
   \   00000162   0xB910             CBNZ.N   R0,??emPrintfInternal_15
    514            return total;
   \   00000164   0x19F0             ADDS     R0,R6,R7
   \   00000166   0xB2C0             UXTB     R0,R0
   \   00000168   0xE000             B.N      ??emPrintfInternal_25
    515          
    516           fail:
    517            return 0;
   \                     ??emPrintfInternal_15:
   \   0000016A   0x2000             MOVS     R0,#+0
   \                     ??emPrintfInternal_25:
   \   0000016C   0xB007             ADD      SP,SP,#+28
   \   0000016E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    518          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xB2F2             UXTB     R2,R6
   \   00000002   0xA901             ADD      R1,SP,#+4
   \   00000004   0x4648             MOV      R0,R9
   \   00000006   0x4740             BX       R8
    519          
    520          //------------------------------------------------------
    521          // Buffered Serial utility APIs
    522          
    523          #ifdef EM_ENABLE_SERIAL_BUFFER
    524          // always executed in interrupt context
    525          void emSerialBufferNextMessageIsr(EmSerialBufferQueue *q) 
    526          {
    527            EmSerialBufferQueueEntry *e = &q->fifo[q->tail];
    528          
    529            q->currentBuffer = e->buffer;
    530            q->nextByte = emberLinkedBufferContents(q->currentBuffer) + e->startIndex;
    531            if((e->length + e->startIndex) > PACKET_BUFFER_SIZE) {
    532              q->lastByte = q->nextByte + ((PACKET_BUFFER_SIZE-1) - e->startIndex);
    533              e->length -= PACKET_BUFFER_SIZE - e->startIndex;
    534            } else {
    535              q->lastByte = q->nextByte + e->length - 1;
    536              e->length = 0;
    537            }
    538          }
    539          #endif
    540          
    541          #ifdef EM_ENABLE_SERIAL_BUFFER
    542          // always executed in interrupt context
    543          void emSerialBufferNextBlockIsr(EmSerialBufferQueue *q, int8u port)
    544          {
    545            EmSerialBufferQueueEntry *e = &q->fifo[q->tail];
    546            
    547            if(e->length != 0) {
    548              q->currentBuffer = emberStackBufferLink(q->currentBuffer);
    549              q->nextByte = emberLinkedBufferContents(q->currentBuffer);
    550              if(e->length > PACKET_BUFFER_SIZE) {
    551                q->lastByte = q->nextByte + 31;
    552                e->length -= PACKET_BUFFER_SIZE;
    553              } else {
    554                q->lastByte = q->nextByte + e->length - 1;
    555                e->length = 0;
    556              }
    557            } else {
    558              #ifdef AVR_ATMEGA
    559                //If we are using an AVR host, non power-of-2 queue sizes are NOT
    560                //supported and therefore we use a mask    
    561                q->tail = ((q->tail+1) & emSerialTxQueueMasks[port]);
    562              #else // AVR_ATMEGA
    563                //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
    564                //supported and therefore we use a mod with the queue size
    565                q->tail = ((q->tail+1) % emSerialTxQueueSizes[port]);
    566              #endif // !AVR_ATMEGA
    567              q->dead++;
    568              q->used--;
    569              if(q->used)
    570                emSerialBufferNextMessageIsr(q);
    571              else
    572                q->nextByte = NULL;
    573            }
    574          }
    575          #endif
    576          
    577          //------------------------------------------------------
    578          // Serial initialization
    579          

   \                                 In section .text, align 2, keep-with-next
    580          EmberStatus emberSerialInit(int8u port, 
    581                                      SerialBaudRate rate,
    582                                      SerialParity parity,
    583                                      int8u stopBits)
    584          {
   \                     emberSerialInit:
   \   00000000   0xE92D 0x4EFC      PUSH     {R2-R7,R9-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x469B             MOV      R11,R3
    585          #ifdef EMBER_SERIAL_USE_STDIO
    586            //When using stdio, bypass the serial library initialization
    587            //and just initialize the low level UART driver.
    588            return halInternalUartInit(port, rate, parity, stopBits);
    589          #else //EMBER_SERIAL_USE_STDIO
    590            EmSerialFifoQueue *rq;
    591          
    592          #if EMBER_SERIAL0_MODE == EMBER_SERIAL_UNUSED
    593            if (port == 0) return EMBER_SERIAL_INVALID_PORT;
    594          #endif
    595          #if EMBER_SERIAL1_MODE == EMBER_SERIAL_UNUSED
    596            if (port == 1) return EMBER_SERIAL_INVALID_PORT;
    597          #endif
    598          #if EMBER_SERIAL2_MODE == EMBER_SERIAL_UNUSED
    599            if (port == 2) return EMBER_SERIAL_INVALID_PORT;
   \   0000000C   0x2C02             CMP      R4,#+2
   \   0000000E   0xBF1C             ITT      NE 
   \   00000010   0x2C03             CMPNE    R4,#+3
    600          #endif
    601          #if EMBER_SERIAL3_MODE == EMBER_SERIAL_UNUSED
    602            if (port == 3) return EMBER_SERIAL_INVALID_PORT;
   \   00000012   0x2C04             CMPNE    R4,#+4
    603          #endif
    604          #if EMBER_SERIAL4_MODE == EMBER_SERIAL_UNUSED
    605            if (port == 4) return EMBER_SERIAL_INVALID_PORT;
   \   00000014   0xD027             BEQ.N    ??emberSerialInit_0
    606          #endif
    607            if (port >= EM_NUM_SERIAL_PORTS) return EMBER_SERIAL_INVALID_PORT;
   \   00000016   0xD226             BCS.N    ??emberSerialInit_0
    608          
    609            switch(emSerialPortModes[port]) {
   \   00000018   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000001C   0x5C20             LDRB     R0,[R4, R0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD121             BNE.N    ??emberSerialInit_0
    610          #ifdef EM_ENABLE_SERIAL_FIFO
    611            case EMBER_SERIAL_FIFO: {
    612              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable19_1
   \   00000026   0xEB05 0x0684      ADD      R6,R5,R4, LSL #+2
   \   0000002A   0x68F7             LDR      R7,[R6, #+12]
    613              ATOMIC_LITE(
    614                q->used = 0;
    615                q->head = 0;
    616                q->tail = 0;
    617              )
   \   0000002C   0x.... 0x....      BL       _disableBasePri
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x80B9             STRH     R1,[R7, #+4]
   \   00000034   0x8039             STRH     R1,[R7, #+0]
   \   00000036   0x8079             STRH     R1,[R7, #+2]
   \   00000038   0x.... 0x....      BL       _writeBasePri
    618              break; }
    619          #endif
    620          #ifdef EM_ENABLE_SERIAL_BUFFER
    621            case EMBER_SERIAL_BUFFER: {
    622              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    623              ATOMIC_LITE(
    624                q->used = 0;
    625                q->head = 0;
    626                q->tail = 0;
    627                q->dead = 0;
    628                q->currentBuffer = EMBER_NULL_MESSAGE_BUFFER;
    629                q->nextByte = NULL;
    630                q->lastByte = NULL;
    631              )
    632              break; }
    633          #endif
    634            default:
    635              return EMBER_SERIAL_INVALID_PORT;
    636              //break;  //statement is unreachable
    637            }
    638          
    639            rq = emSerialRxQueues[port];
   \   0000003C   0x69F6             LDR      R6,[R6, #+28]
    640            ATOMIC_LITE(
    641              rq->used = 0;
    642              rq->head = 0;
    643              rq->tail = 0;
    644              emSerialRxError[port] = EMBER_SUCCESS;
    645            )
   \   0000003E   0x.... 0x....      BL       _disableBasePri
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x80B1             STRH     R1,[R6, #+4]
   \   00000046   0x8031             STRH     R1,[R6, #+0]
   \   00000048   0x8071             STRH     R1,[R6, #+2]
   \   0000004A   0x5561             STRB     R1,[R4, R5]
   \   0000004C   0x.... 0x....      BL       _writeBasePri
    646          
    647            halInternalRestartUart();
   \   00000050   0x.... 0x....      BL       halInternalRestartUart
    648          
    649            return halInternalUartInit(port, rate, parity, stopBits);
   \   00000054   0x465B             MOV      R3,R11
   \   00000056   0x4652             MOV      R2,R10
   \   00000058   0x4649             MOV      R1,R9
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0xB002             ADD      SP,SP,#+8
   \   0000005E   0xE8BD 0x4EF0      POP      {R4-R7,R9-R11,LR}
   \   00000062   0x.... 0x....      B.W      halInternalUartInit
   \                     ??emberSerialInit_0:
   \   00000066   0x2021             MOVS     R0,#+33
   \   00000068   0xE8BD 0x8EF6      POP      {R1,R2,R4-R7,R9-R11,PC}  ;; return
    650          #endif //EMBER_SERIAL_USE_STDIO
    651          }
    652          
    653          //------------------------------------------------------
    654          // Serial Input
    655          
    656          // returns # bytes available for reading

   \                                 In section .text, align 2, keep-with-next
    657          int16u emberSerialReadAvailable(int8u port)  
    658          {
   \                     emberSerialReadAvailable:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    659          #ifdef EMBER_SERIAL_USE_STDIO
    660            return halInternalPrintfReadAvailable();
    661          #else //EMBER_SERIAL_USE_STDIO
    662            halInternalUartRxPump(port);
   \   00000004   0x.... 0x....      BL       halInternalUartRxPump
    663            return emSerialRxQueues[port]->used;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   0000000C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000010   0x69C0             LDR      R0,[R0, #+28]
   \   00000012   0x8880             LDRH     R0,[R0, #+4]
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    664          #endif //EMBER_SERIAL_USE_STDIO
    665          }
    666          

   \                                 In section .text, align 2, keep-with-next
    667          EmberStatus emberSerialReadByte(int8u port, int8u *dataByte)
    668          {
   \                     emberSerialReadByte:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4688             MOV      R8,R1
    669          #ifdef EMBER_SERIAL_USE_STDIO
    670            int ch=-1;
    671            ch = getchar();
    672            if(ch<0) {
    673              return EMBER_SERIAL_RX_EMPTY;
    674            }
    675            *dataByte = (int8u)ch;
    676            return EMBER_SUCCESS;
    677          #else //EMBER_SERIAL_USE_STDIO
    678            int8u retval;
    679            EmSerialFifoQueue *q = emSerialRxQueues[port];
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable19_1
   \   0000000C   0xEB05 0x0184      ADD      R1,R5,R4, LSL #+2
   \   00000010   0x69CE             LDR      R6,[R1, #+28]
    680          
    681            if(emSerialPortModes[port] == EMBER_SERIAL_UNUSED) {
   \   00000012   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   00000016   0x5C61             LDRB     R1,[R4, R1]
   \   00000018   0xB909             CBNZ.N   R1,??emberSerialReadByte_0
    682              return EMBER_ERR_FATAL;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE035             B.N      ??emberSerialReadByte_1
    683            }
    684          
    685            if(emSerialRxError[port] != EMBER_SUCCESS) {
   \                     ??emberSerialReadByte_0:
   \   0000001E   0xEB05 0x0744      ADD      R7,R5,R4, LSL #+1
   \   00000022   0x5D61             LDRB     R1,[R4, R5]
   \   00000024   0xB161             CBZ.N    R1,??emberSerialReadByte_2
    686              if(emSerialRxErrorIndex[port] == q->tail) {
   \   00000026   0x88B9             LDRH     R1,[R7, #+4]
   \   00000028   0x8872             LDRH     R2,[R6, #+2]
   \   0000002A   0x4291             CMP      R1,R2
   \   0000002C   0xD108             BNE.N    ??emberSerialReadByte_2
    687                ATOMIC_LITE(
    688                  retval = emSerialRxError[port];
    689                  emSerialRxError[port] = EMBER_SUCCESS;
    690                )
   \   0000002E   0x.... 0x....      BL       _disableBasePri
   \   00000032   0x5D66             LDRB     R6,[R4, R5]
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x5561             STRB     R1,[R4, R5]
   \   00000038   0x.... 0x....      BL       _writeBasePri
    691                return retval;
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0xE024             B.N      ??emberSerialReadByte_1
    692              }
    693            }
    694            
    695            halInternalUartRxPump(port);
   \                     ??emberSerialReadByte_2:
   \   00000040   0x.... 0x....      BL       halInternalUartRxPump
    696            halInternalUartFlowControl(port);
    697            
    698            if(q->used > 0) {
   \   00000044   0x88B0             LDRH     R0,[R6, #+4]
   \   00000046   0xB1F8             CBZ.N    R0,??emberSerialReadByte_3
    699              ATOMIC_LITE(
    700                *dataByte = FIFO_DEQUEUE(q,emSerialRxQueueWraps[port]);
    701              )
   \   00000048   0x.... 0x....      BL       _disableBasePri
   \   0000004C   0x8871             LDRH     R1,[R6, #+2]
   \   0000004E   0x1989             ADDS     R1,R1,R6
   \   00000050   0x7989             LDRB     R1,[R1, #+6]
   \   00000052   0xF888 0x1000      STRB     R1,[R8, #+0]
   \   00000056   0x8871             LDRH     R1,[R6, #+2]
   \   00000058   0x1C49             ADDS     R1,R1,#+1
   \   0000005A   0x.... 0x....      ADR.W    R2,emSerialRxQueueWraps
   \   0000005E   0xF832 0x2014      LDRH     R2,[R2, R4, LSL #+1]
   \   00000062   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_3:
   \   00000066   0x8071             STRH     R1,[R6, #+2]
   \   00000068   0x88B1             LDRH     R1,[R6, #+4]
   \   0000006A   0x1E49             SUBS     R1,R1,#+1
   \   0000006C   0x80B1             STRH     R1,[R6, #+4]
   \   0000006E   0x.... 0x....      BL       _writeBasePri
    702              if(emSerialRxError[port] != EMBER_SUCCESS) {
   \   00000072   0x5D60             LDRB     R0,[R4, R5]
   \   00000074   0xB130             CBZ.N    R0,??emberSerialReadByte_4
    703                //This index is used when there is an error when the FIFO is full.
    704                if(emSerialRxErrorIndex[port] == RX_FIFO_FULL) {
   \   00000076   0x88B8             LDRH     R0,[R7, #+4]
   \   00000078   0xF64F 0x71FF      MOVW     R1,#+65535
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xBF04             ITT      EQ 
   \   00000080   0x8830             LDRHEQ   R0,[R6, #+0]
   \   00000082   0x80B8             STRHEQ   R0,[R7, #+4]
    705                  //q->tail has advanced by one, we can now mark the head as the error
    706                  emSerialRxErrorIndex[port] = q->head;
    707                }
    708              }
    709              return EMBER_SUCCESS;
   \                     ??emberSerialReadByte_4:
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE000             B.N      ??emberSerialReadByte_1
    710            } else {
    711              return EMBER_SERIAL_RX_EMPTY;
   \                     ??emberSerialReadByte_3:
   \   00000088   0x2026             MOVS     R0,#+38
   \                     ??emberSerialReadByte_1:
   \   0000008A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    712            }
    713          #endif //EMBER_SERIAL_USE_STDIO
    714          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \   00000004   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \   00000008   0x4770             BX       LR
    715          

   \                                 In section .text, align 2, keep-with-next
    716          EmberStatus emberSerialReadData(int8u port,
    717                                          int8u *data,
    718                                          int16u length,
    719                                          int16u *bytesRead)
    720          {
   \                     emberSerialReadData:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461F             MOV      R7,R3
    721            int16u bytesReadInternal = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0xE001             B.N      ??emberSerialReadData_0
    722            EmberStatus status;
    723          
    724            while (bytesReadInternal < length) {
    725              status = emberSerialReadByte(port, data);
    726          
    727              switch (status) {
    728                case EMBER_SUCCESS:
    729                  ++data;
   \                     ??emberSerialReadData_1:
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
    730                  ++bytesReadInternal;
   \   00000012   0x1C76             ADDS     R6,R6,#+1
    731                  break;
   \                     ??emberSerialReadData_0:
   \   00000014   0xB2B6             UXTH     R6,R6
   \   00000016   0x4546             CMP      R6,R8
   \   00000018   0xD20A             BCS.N    ??emberSerialReadData_2
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       emberSerialReadByte
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0xD0F4             BEQ.N    ??emberSerialReadData_1
   \   00000026   0x2826             CMP      R0,#+38
   \   00000028   0xD0F4             BEQ.N    ??emberSerialReadData_0
    732          
    733                case EMBER_SERIAL_RX_EMPTY:
    734                  // empty queue is not an error for us, we just want to keep waiting
    735                  break;
    736          
    737                default:
    738                  // only store number of bytes read if the caller provided a non-NULL pointer
    739                  if (bytesRead) {
   \   0000002A   0xB127             CBZ.N    R7,??emberSerialReadData_3
    740                    *bytesRead = bytesReadInternal;
   \   0000002C   0x803E             STRH     R6,[R7, #+0]
    741                  }
    742                  return status;
   \   0000002E   0xE002             B.N      ??emberSerialReadData_3
    743              }
    744            }
    745          
    746            // only store number of bytes read if the caller provided a non-NULL pointer
    747            if (bytesRead) {
   \                     ??emberSerialReadData_2:
   \   00000030   0xB107             CBZ.N    R7,??emberSerialReadData_4
    748              *bytesRead = bytesReadInternal;
   \   00000032   0x803E             STRH     R6,[R7, #+0]
    749            }
    750          
    751            return EMBER_SUCCESS;
   \                     ??emberSerialReadData_4:
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??emberSerialReadData_3:
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    752          }
    753          
    754          #ifndef EMBER_TEST

   \                                 In section .text, align 2, keep-with-next
    755          EmberStatus emberSerialReadDataTimeout(int8u port,
    756                                                 int8u *data,
    757                                                 int16u length,
    758                                                 int16u *bytesRead,
    759                                                 int16u firstByteTimeout,
    760                                                 int16u subsequentByteTimeout)
    761          {
   \                     emberSerialReadDataTimeout:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4692             MOV      R10,R2
   \   0000000A   0x461E             MOV      R6,R3
   \   0000000C   0x9D0A             LDR      R5,[SP, #+40]
    762            int16u bytesReadInternal = 0;
   \   0000000E   0x2700             MOVS     R7,#+0
    763            EmberStatus status;
    764            int16u timeout = firstByteTimeout;
    765            int16u startTime = halCommonGetInt16uMillisecondTick();
   \   00000010   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000014   0x4683             MOV      R11,R0
   \   00000016   0x9C0B             LDR      R4,[SP, #+44]
   \   00000018   0xE006             B.N      ??emberSerialReadDataTimeout_0
    766          
    767            // loop until we read the max number of bytes or the timeout elapses
    768            while (bytesReadInternal < length
    769                   && halCommonGetInt16uMillisecondTick() - startTime < timeout) {
    770              status = emberSerialReadByte(port, data);
    771          
    772              switch (status) {
    773                case EMBER_SUCCESS:
    774                  ++data;
   \                     ??emberSerialReadDataTimeout_1:
   \   0000001A   0xF109 0x0901      ADD      R9,R9,#+1
    775                  ++bytesReadInternal;
   \   0000001E   0x1C7F             ADDS     R7,R7,#+1
    776                  // reset timer and timeout for next character
    777                  startTime = halCommonGetInt16uMillisecondTick();
   \   00000020   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000024   0x4683             MOV      R11,R0
    778                  timeout = subsequentByteTimeout;
   \   00000026   0x4625             MOV      R5,R4
    779                  break;
   \                     ??emberSerialReadDataTimeout_0:
   \   00000028   0xB2BF             UXTH     R7,R7
   \   0000002A   0x4557             CMP      R7,R10
   \   0000002C   0xD211             BCS.N    ??emberSerialReadDataTimeout_2
   \   0000002E   0x.... 0x....      BL       halCommonGetInt16uMillisecondTick
   \   00000032   0xEBA0 0x000B      SUB      R0,R0,R11
   \   00000036   0xB2AD             UXTH     R5,R5
   \   00000038   0x42A8             CMP      R0,R5
   \   0000003A   0xDA0A             BGE.N    ??emberSerialReadDataTimeout_2
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x4640             MOV      R0,R8
   \   00000040   0x.... 0x....      BL       emberSerialReadByte
   \   00000044   0x0001             MOVS     R1,R0
   \   00000046   0xD0E8             BEQ.N    ??emberSerialReadDataTimeout_1
   \   00000048   0x2826             CMP      R0,#+38
   \   0000004A   0xD0ED             BEQ.N    ??emberSerialReadDataTimeout_0
    780          
    781                case EMBER_SERIAL_RX_EMPTY:
    782                  // empty queue is not an error for us, we just want to keep waiting
    783                  break;
    784          
    785                default:
    786                  // only store number of bytes read if the caller provided a non-NULL pointer
    787                  if (bytesRead) {
   \   0000004C   0xB13E             CBZ.N    R6,??emberSerialReadDataTimeout_3
    788                    *bytesRead = bytesReadInternal;
   \   0000004E   0x8037             STRH     R7,[R6, #+0]
    789                  }
    790                  return status;
   \   00000050   0xE005             B.N      ??emberSerialReadDataTimeout_3
    791              }
    792            }
    793          
    794            // only store number of bytes read if the caller provided a non-NULL pointer
    795            if (bytesRead) {
   \                     ??emberSerialReadDataTimeout_2:
   \   00000052   0xB106             CBZ.N    R6,??emberSerialReadDataTimeout_4
    796              *bytesRead = bytesReadInternal;
   \   00000054   0x8037             STRH     R7,[R6, #+0]
    797            }
    798          
    799            return bytesReadInternal == length ? EMBER_SUCCESS : EMBER_SERIAL_RX_EMPTY;
   \                     ??emberSerialReadDataTimeout_4:
   \   00000056   0x4557             CMP      R7,R10
   \   00000058   0xBF0C             ITE      EQ 
   \   0000005A   0x2000             MOVEQ    R0,#+0
   \   0000005C   0x2026             MOVNE    R0,#+38
   \                     ??emberSerialReadDataTimeout_3:
   \   0000005E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    800          }
    801          #endif // EMBER_TEST
    802          

   \                                 In section .text, align 2, keep-with-next
    803          EmberStatus emberSerialReadPartialLine(int8u port, char *data, int8u max, int8u * index)
    804          {
   \                     emberSerialReadPartialLine:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461D             MOV      R5,R3
    805            EmberStatus err;
    806            int8u ch;
    807          
    808            if (((*index) == 0) || ((*index) >= max))
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0xB108             CBZ.N    R0,??emberSerialReadPartialLine_0
   \   0000000E   0x42B0             CMP      R0,R6
   \   00000010   0xD308             BCC.N    ??emberSerialReadPartialLine_1
    809              data[0] = '\0';
   \                     ??emberSerialReadPartialLine_0:
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7038             STRB     R0,[R7, #+0]
   \   00000016   0xE005             B.N      ??emberSerialReadPartialLine_1
    810          
    811            for (;;) {   
    812              err = emberSerialReadByte(port, &ch);
    813          
    814              // no new serial port char?, keep looping
    815              if (err) return err;
    816          
    817              // handle bogus characters
    818              if ( ch > 0x7F ) continue;
    819          
    820              // handle leading newline - fogBUGZ # 584
    821              if (((*index) == 0) &&
    822                  ((ch == '\n') || (ch == 0))) continue;
    823          
    824              // Drop the CR, or NULL that is part of EOL sequence.
    825              if ((*index) >= max) {
    826                *index = 0;
    827                if ((ch == '\r') || (ch == 0)) continue;
    828              }
    829          
    830              // handle backspace
    831              if ( ch == 0x8 || ch == 0x7F ) {
    832                if ( (*index) > 0 ) {
    833                  // delete the last character from our string
    834                  (*index)--;
    835                  data[*index] = '\0';
    836                  // echo backspace
    837                  emberSerialWriteString(port, "\b \b");
    838                }
    839                // don't add or process this character
    840                continue;
    841              }
    842          
    843              //if the string is about to overflow, fake in a CR
    844              if ( (*index) + 2 > max ) {
    845                ch = '\r';
    846              }
    847          
    848              emberSerialWriteByte(port, ch); // term char echo
    849          
    850              //upcase that char
    851              if ( ch>='a' && ch<='z') ch = ch - ('a'-'A');
    852          
    853              // build a string until we press enter
    854              if ( ( ch == '\r' ) || ( ch == '\n' ) ) {
    855                data[*index] = '\0';
    856          
    857                if (ch == '\r') {
    858                  emberSerialWriteByte(port, '\n'); // "append" LF
    859                  *index = 0;                       // Reset for next line; \n next
    860                } else {
    861                  emberSerialWriteByte(port, '\r'); // "append" CR
    862                  *index = max;                     // Reset for next line; \r,\0 next
    863                }
    864          
    865                return EMBER_SUCCESS;
    866              } 
    867                
    868              data[(*index)++] = ch;
   \                     ??emberSerialReadPartialLine_2:
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0x1C41             ADDS     R1,R0,#+1
   \   0000001C   0x7029             STRB     R1,[R5, #+0]
   \   0000001E   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000022   0x55C1             STRB     R1,[R0, R7]
   \                     ??emberSerialReadPartialLine_1:
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       emberSerialReadByte
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD155             BNE.N    ??emberSerialReadPartialLine_3
   \   00000030   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000034   0x2880             CMP      R0,#+128
   \   00000036   0xD2F5             BCS.N    ??emberSerialReadPartialLine_1
   \   00000038   0x7828             LDRB     R0,[R5, #+0]
   \   0000003A   0xB928             CBNZ.N   R0,??emberSerialReadPartialLine_4
   \   0000003C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000040   0x290A             CMP      R1,#+10
   \   00000042   0xBF18             IT       NE 
   \   00000044   0x2900             CMPNE    R1,#+0
   \   00000046   0xD0ED             BEQ.N    ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_4:
   \   00000048   0x42B0             CMP      R0,R6
   \   0000004A   0xD307             BCC.N    ??emberSerialReadPartialLine_5
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x7028             STRB     R0,[R5, #+0]
   \   00000050   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000054   0x280D             CMP      R0,#+13
   \   00000056   0xBF18             IT       NE 
   \   00000058   0x2800             CMPNE    R0,#+0
   \   0000005A   0xD0E3             BEQ.N    ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_5:
   \   0000005C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000060   0x2808             CMP      R0,#+8
   \   00000062   0xBF18             IT       NE 
   \   00000064   0x287F             CMPNE    R0,#+127
   \   00000066   0xD10C             BNE.N    ??emberSerialReadPartialLine_6
   \   00000068   0x7828             LDRB     R0,[R5, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD0DA             BEQ.N    ??emberSerialReadPartialLine_1
   \   0000006E   0x1E40             SUBS     R0,R0,#+1
   \   00000070   0x7028             STRB     R0,[R5, #+0]
   \   00000072   0xB2C0             UXTB     R0,R0
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x55C1             STRB     R1,[R0, R7]
   \   00000078   0x....             ADR.N    R1,??DataTable18  ;; "\b \b"
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       emberSerialWriteString
   \   00000080   0xE7D0             B.N      ??emberSerialReadPartialLine_1
   \                     ??emberSerialReadPartialLine_6:
   \   00000082   0x7828             LDRB     R0,[R5, #+0]
   \   00000084   0x1C80             ADDS     R0,R0,#+2
   \   00000086   0x4286             CMP      R6,R0
   \   00000088   0xBFBC             ITT      LT 
   \   0000008A   0x200D             MOVLT    R0,#+13
   \   0000008C   0xF88D 0x0000      STRBLT   R0,[SP, #+0]
   \   00000090   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000094   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_9:
   \   00000098   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000009C   0x3861             SUBS     R0,R0,#+97
   \   0000009E   0xB2C0             UXTB     R0,R0
   \   000000A0   0x281A             CMP      R0,#+26
   \   000000A2   0xD204             BCS.N    ??emberSerialReadPartialLine_7
   \   000000A4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000A8   0x3820             SUBS     R0,R0,#+32
   \   000000AA   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \                     ??emberSerialReadPartialLine_7:
   \   000000AE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000B2   0x280D             CMP      R0,#+13
   \   000000B4   0xBF18             IT       NE 
   \   000000B6   0x280A             CMPNE    R0,#+10
   \   000000B8   0xD1AE             BNE.N    ??emberSerialReadPartialLine_2
   \   000000BA   0x7828             LDRB     R0,[R5, #+0]
   \   000000BC   0x2100             MOVS     R1,#+0
   \   000000BE   0x55C1             STRB     R1,[R0, R7]
   \   000000C0   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000C4   0x280D             CMP      R0,#+13
   \   000000C6   0xD104             BNE.N    ??emberSerialReadPartialLine_8
   \   000000C8   0x200A             MOVS     R0,#+10
   \   000000CA   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_8:
   \   000000CE   0x2600             MOVS     R6,#+0
   \   000000D0   0xE002             B.N      ??CrossCallReturnLabel_7
   \                     ??emberSerialReadPartialLine_8:
   \   000000D2   0x200D             MOVS     R0,#+13
   \   000000D4   0x.... 0x....      BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_7:
   \   000000D8   0x702E             STRB     R6,[R5, #+0]
   \   000000DA   0x2000             MOVS     R0,#+0
   \                     ??emberSerialReadPartialLine_3:
   \   000000DC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    869            }
    870          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000000A                      REQUIRE ??Subroutine4_0
   \   0000000A                      ;; // Fall through to label ??Subroutine4_0
    871          

   \                                 In section .text, align 2, keep-with-next
    872          EmberStatus emberSerialReadLine(int8u port, char *data, int8u max)
    873          {
   \                     emberSerialReadLine:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    874            int8u index=0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000010   0xE001             B.N      ??emberSerialReadLine_0
    875          
    876            while(emberSerialReadPartialLine(port, data, max, &index) != EMBER_SUCCESS) {
    877              halResetWatchdog();
   \                     ??emberSerialReadLine_1:
   \   00000012   0x.... 0x....      BL       halInternalResetWatchDog
    878            }
   \                     ??emberSerialReadLine_0:
   \   00000016   0xAB00             ADD      R3,SP,#+0
   \   00000018   0x4632             MOV      R2,R6
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       emberSerialReadPartialLine
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F5             BNE.N    ??emberSerialReadLine_1
    879            return EMBER_SUCCESS;
   \   00000026   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    880          }
    881          
    882          //------------------------------------------------------
    883          // Serial Output
    884          
    885          // returns # bytes (if fifo mode)/messages (if buffer mode) that can be written

   \                                 In section .text, align 2, keep-with-next
    886          int16u emberSerialWriteAvailable(int8u port)  
    887          {
    888          #ifdef EMBER_SERIAL_USE_STDIO
    889            return halInternalPrintfWriteAvailable();
    890          #else //EMBER_SERIAL_USE_STDIO
    891            switch(emSerialPortModes[port]) {
   \                     emberSerialWriteAvailable:
   \   00000000   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   00000004   0x5C41             LDRB     R1,[R0, R1]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD10B             BNE.N    ??emberSerialWriteAvailable_0
    892          #ifdef EM_ENABLE_SERIAL_FIFO
    893            case EMBER_SERIAL_FIFO:
    894              return emSerialTxQueueSizes[port] - 
    895                ((EmSerialFifoQueue*)emSerialTxQueues[port])->used;
   \   0000000A   0x.... 0x....      ADR.W    R1,emSerialTxQueueSizes
   \   0000000E   0xF831 0x1010      LDRH     R1,[R1, R0, LSL #+1]
   \   00000012   0x....             LDR.N    R2,??DataTable19_1
   \   00000014   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \   00000018   0x68C0             LDR      R0,[R0, #+12]
   \   0000001A   0x8880             LDRH     R0,[R0, #+4]
   \   0000001C   0x1A08             SUBS     R0,R1,R0
   \   0000001E   0xB280             UXTH     R0,R0
   \   00000020   0x4770             BX       LR
    896          #endif
    897          #ifdef EM_ENABLE_SERIAL_BUFFER
    898            case EMBER_SERIAL_BUFFER: {
    899              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
    900              int8u elementsUsed;
    901              int8u elementsDead; 
    902              ATOMIC_LITE( // To clarify the volatile access.
    903                     elementsUsed = q->used;
    904                     elementsDead = q->dead;
    905                     )
    906              return emSerialTxQueueSizes[port] - (elementsUsed + elementsDead);
    907              }
    908          #endif
    909            default: {
    910            }
    911            }
    912            return 0;
   \                     ??emberSerialWriteAvailable_0:
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x4770             BX       LR               ;; return
    913          #endif //EMBER_SERIAL_USE_STDIO
    914          }
    915          

   \                                 In section .text, align 2, keep-with-next
    916          EmberStatus emberSerialWriteByte(int8u port, int8u dataByte)
    917          {
   \                     emberSerialWriteByte:
   \   00000000   0xB502             PUSH     {R1,LR}
    918            return emberSerialWriteData(port, &dataByte, 1);
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xA900             ADD      R1,SP,#+0
   \   00000006   0x.... 0x....      BL       emberSerialWriteData
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    919          }
    920          
    921          #ifndef EMBER_SERIAL_USE_STDIO
    922          #ifdef EM_ENABLE_SERIAL_FIFO
    923          static boolean getOutputFifoSpace(EmSerialFifoQueue *q,
    924                                            int8u port,
    925                                            int16u extraByteCount)
    926          {
    927            return (q->used < emSerialTxQueueSizes[port] - extraByteCount);
    928          }
    929          #endif
    930          #endif //EMBER_SERIAL_USE_STDIO
    931          

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine4_0:
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x....             B.N      emberSerialWriteData

   \                                 In section .text, align 2, keep-with-next
    932          EmberStatus emberSerialWriteHex(int8u port, int8u dataByte)
    933          {
   \                     emberSerialWriteHex:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
    934            int8u hex[2];
    935            emWriteHexInternal(hex, dataByte, 2);
   \   00000006   0x2202             MOVS     R2,#+2
   \   00000008   0xA800             ADD      R0,SP,#+0
   \   0000000A   0x.... 0x....      BL       emWriteHexInternal
    936            return emberSerialWriteData(port, hex, 2);
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x.... 0x....      BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_6:
   \   00000016   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    937          }
    938          

   \                                 In section .text, align 2, keep-with-next
    939          EmberStatus emberSerialWriteString(int8u port, PGM_P string)
    940          {
   \                     emberSerialWriteString:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4682             MOV      R10,R0
   \   00000006   0x460D             MOV      R5,R1
    941          #ifdef EMBER_SERIAL_USE_STDIO
    942            while(*string != '\0') {
    943              putchar(*string);
    944              string++;
    945            }
    946            return EMBER_SUCCESS;
    947          #else //EMBER_SERIAL_USE_STDIO
    948            switch(emSerialPortModes[port]) {
   \   00000008   0x4656             MOV      R6,R10
   \   0000000A   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000000E   0x5C30             LDRB     R0,[R6, R0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD131             BNE.N    ??emberSerialWriteString_0
    949          #ifdef EM_ENABLE_SERIAL_FIFO
    950            case EMBER_SERIAL_FIFO:
    951              {
    952                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000014   0x....             LDR.N    R0,??DataTable19_1
   \   00000016   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   0000001A   0x68C7             LDR      R7,[R0, #+12]
    953                boolean kickStartTx = FALSE;
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0x.... 0x....      ADR.W    R8,emSerialTxQueueWraps
   \   00000022   0x.... 0x....      ADR.W    R9,emSerialTxQueueSizes
   \   00000026   0xE015             B.N      ??emberSerialWriteString_1
    954          
    955                while(*string != '\0') {
    956                  while (! getOutputFifoSpace(q, port, 0)) {
    957                    if (kickStartTx) {
    958                      halInternalStartUartTx(port);
    959                      kickStartTx = FALSE;
    960                    }
    961                    #ifdef EM_ENABLE_SERIAL_BLOCKING
    962                      if (emSerialBlocking[port]) {
    963                        simulatedSerialTimePasses();
    964                        // Pet the watchdog here?
    965                        continue;
    966                      }
    967                    #endif
    968                    return EMBER_SERIAL_TX_OVERFLOW;
    969                  }
    970                  ATOMIC_LITE(
    971                    if (q->used == 0) {
    972                      kickStartTx = TRUE;
    973                    }
    974                    FIFO_ENQUEUE(q,*string,emSerialTxQueueWraps[port]);
    975                  )
   \                     ??emberSerialWriteString_2:
   \   00000028   0x.... 0x....      BL       _disableBasePri
   \   0000002C   0x88B9             LDRH     R1,[R7, #+4]
   \   0000002E   0xB901             CBNZ.N   R1,??emberSerialWriteString_3
   \   00000030   0x2401             MOVS     R4,#+1
   \                     ??emberSerialWriteString_3:
   \   00000032   0x8839             LDRH     R1,[R7, #+0]
   \   00000034   0x19C9             ADDS     R1,R1,R7
   \   00000036   0xF815 0x2B01      LDRB     R2,[R5], #+1
   \   0000003A   0x718A             STRB     R2,[R1, #+6]
   \   0000003C   0x8839             LDRH     R1,[R7, #+0]
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
   \   00000040   0xF838 0x2016      LDRH     R2,[R8, R6, LSL #+1]
   \   00000044   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_4:
   \   00000048   0x8039             STRH     R1,[R7, #+0]
   \   0000004A   0x88B9             LDRH     R1,[R7, #+4]
   \   0000004C   0x1C49             ADDS     R1,R1,#+1
   \   0000004E   0x80B9             STRH     R1,[R7, #+4]
   \   00000050   0x.... 0x....      BL       _writeBasePri
    976                  string++;
   \                     ??emberSerialWriteString_1:
   \   00000054   0x7828             LDRB     R0,[R5, #+0]
   \   00000056   0xB150             CBZ.N    R0,??emberSerialWriteString_4
   \   00000058   0x88B8             LDRH     R0,[R7, #+4]
   \   0000005A   0xF839 0x1016      LDRH     R1,[R9, R6, LSL #+1]
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD3E2             BCC.N    ??emberSerialWriteString_2
   \   00000062   0xB114             CBZ.N    R4,??emberSerialWriteString_5
   \   00000064   0x4650             MOV      R0,R10
   \   00000066   0x.... 0x....      BL       halInternalStartUartTx
   \                     ??emberSerialWriteString_5:
   \   0000006A   0x2022             MOVS     R0,#+34
   \   0000006C   0xE005             B.N      ??emberSerialWriteString_6
    977                }
    978                // make sure the interrupt is enabled so it will be sent
    979                halInternalStartUartTx(port);
   \                     ??emberSerialWriteString_4:
   \   0000006E   0x4650             MOV      R0,R10
   \   00000070   0x.... 0x....      BL       halInternalStartUartTx
    980                return EMBER_SUCCESS;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE000             B.N      ??emberSerialWriteString_6
    981              }
    982          #endif
    983          #ifdef EM_ENABLE_SERIAL_BUFFER
    984            case EMBER_SERIAL_BUFFER:
    985              {
    986                EmberMessageBuffer buff = emberAllocateStackBuffer();
    987                if(buff != EMBER_NULL_MESSAGE_BUFFER) {
    988                  EmberStatus stat;
    989                  if((stat=emberAppendPgmStringToLinkedBuffers(buff, string)) 
    990                     == EMBER_SUCCESS) {
    991                    stat = emberSerialWriteBuffer(port, buff, 0, emberMessageBufferLength(buff));
    992                  }
    993                  // Refcounts may be manipulated in ISR if DMA used
    994                  ATOMIC( emberReleaseMessageBuffer(buff); )
    995                  return stat;
    996                }
    997                return EMBER_NO_BUFFERS;
    998              }
    999          #endif
   1000            default:
   1001              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteString_0:
   \   00000078   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteString_6:
   \   0000007A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1002            }
   1003          #endif //EMBER_SERIAL_USE_STDIO
   1004          }
   1005          

   \                                 In section .text, align 2, keep-with-next
   1006          EmberStatus emberSerialPrintCarriageReturn(int8u port)
   1007          {
   1008            return emberSerialPrintf(port, "\r\n");
   \                     emberSerialPrintCarriageReturn:
   \   00000000   0x....             ADR.N    R1,??DataTable19  ;; 0x0D, 0x0A, 0x00, 0x00
   \   00000002   0x....             B.N      emberSerialPrintf
   1009          }
   1010          

   \                                 In section .text, align 2, keep-with-next
   1011          EmberStatus emberSerialPrintfVarArg(int8u port, PGM_P formatString, va_list ap)
   1012          {
   \                     emberSerialPrintfVarArg:
   \   00000000   0xB510             PUSH     {R4,LR}
   1013             EmberStatus stat = EMBER_SUCCESS;
   \   00000002   0x2400             MOVS     R4,#+0
   1014             
   1015          #ifdef EMBER_SERIAL_USE_STDIO
   1016            if(!emPrintfInternal(emberSerialWriteData, port, formatString, ap)) {
   1017              stat = EMBER_ERR_FATAL;
   1018            }
   1019          #else //EMBER_SERIAL_USE_STDIO
   1020            
   1021            switch(emSerialPortModes[port]) {
   \   00000004   0x.... 0x....      ADR.W    R3,emSerialPortModes
   \   00000008   0x5CC3             LDRB     R3,[R0, R3]
   \   0000000A   0x2B01             CMP      R3,#+1
   \   0000000C   0xD108             BNE.N    ??emberSerialPrintfVarArg_0
   1022          #ifdef EM_ENABLE_SERIAL_FIFO
   1023            case EMBER_SERIAL_FIFO: {
   1024              if(!emPrintfInternal(emberSerialWriteData, port, formatString, ap))
   \   0000000E   0x4613             MOV      R3,R2
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x4601             MOV      R1,R0
   \   00000014   0x.... 0x....      ADR.W    R0,emberSerialWriteData
   \   00000018   0x.... 0x....      BL       emPrintfInternal
   \   0000001C   0xB900             CBNZ.N   R0,??emberSerialPrintfVarArg_0
   1025                stat = EMBER_ERR_FATAL;
   \   0000001E   0x2401             MOVS     R4,#+1
   1026              break;
   1027            }
   1028          #endif
   1029          #ifdef EM_ENABLE_SERIAL_BUFFER
   1030            case EMBER_SERIAL_BUFFER: {
   1031              EmberMessageBuffer buff = emberAllocateStackBuffer();
   1032              if(buff == EMBER_NULL_MESSAGE_BUFFER) {
   1033                stat = EMBER_NO_BUFFERS;
   1034                break;
   1035              }
   1036              if(emPrintfInternal(emberAppendToLinkedBuffers,
   1037                                  buff,
   1038                                  formatString,
   1039                                  ap)) {
   1040                stat = emberSerialWriteBuffer(port,buff,0,emberMessageBufferLength(buff));
   1041              } else {
   1042                stat = EMBER_NO_BUFFERS;
   1043              }
   1044              // Refcounts may be manipulated in ISR if DMA used
   1045              ATOMIC( emberReleaseMessageBuffer(buff); )
   1046          
   1047              break;
   1048            }
   1049          #endif
   1050            default: {
   1051            }
   1052            } //close switch.
   1053          #endif //EMBER_SERIAL_USE_STDIO
   1054            return stat;
   \                     ??emberSerialPrintfVarArg_0:
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   1055          }
   1056          

   \                                 In section .text, align 2, keep-with-next
   1057          EmberStatus emberSerialPrintf(int8u port, PGM_P formatString, ...)
   1058          {
   \                     emberSerialPrintf:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB580             PUSH     {R7,LR}
   1059            EmberStatus stat;
   1060            va_list ap;
   1061            va_start (ap, formatString);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   1062            stat = emberSerialPrintfVarArg(port, formatString, ap);
   1063            va_end (ap);
   1064            return stat;
   \   00000006   0x.... 0x....      BL       emberSerialPrintfVarArg
   \   0000000A   0xBC02             POP      {R1}
   \   0000000C   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   1065          }
   1066          

   \                                 In section .text, align 2, keep-with-next
   1067          EmberStatus emberSerialPrintfLine(int8u port, PGM_P formatString, ...)
   1068          {
   \                     emberSerialPrintfLine:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4604             MOV      R4,R0
   1069            EmberStatus stat;
   1070            va_list ap;
   1071            va_start (ap, formatString);
   \   00000006   0xAA04             ADD      R2,SP,#+16
   1072            stat = emberSerialPrintfVarArg(port, formatString, ap);
   \   00000008   0x.... 0x....      BL       emberSerialPrintfVarArg
   \   0000000C   0x4605             MOV      R5,R0
   1073            va_end (ap);
   1074            emberSerialPrintCarriageReturn(port);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       emberSerialPrintCarriageReturn
   1075            return stat;
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x....             B.N      ?Subroutine0
   1076          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xBC32             POP      {R1,R4,R5}
   \   00000002   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   1077          

   \                                 In section .text, align 4, keep-with-next
   1078          EmberStatus emberSerialWriteData(int8u port, int8u *data, int8u length)
   1079          {
   \                     emberSerialWriteData:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x468B             MOV      R11,R1
   \   00000008   0x4616             MOV      R6,R2
   1080          #ifdef EMBER_SERIAL_USE_STDIO
   1081            while(length--) {
   1082              putchar(*data);
   1083              data++;
   1084            }
   1085            return EMBER_SUCCESS;
   1086          #else //EMBER_SERIAL_USE_STDIO
   1087            switch(emSerialPortModes[port]) {
   \   0000000A   0x4647             MOV      R7,R8
   \   0000000C   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   00000010   0x5C38             LDRB     R0,[R7, R0]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD133             BNE.N    ??emberSerialWriteData_0
   1088          #ifdef EM_ENABLE_SERIAL_FIFO
   1089            case EMBER_SERIAL_FIFO:
   1090              {
   1091                EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   00000016   0x....             LDR.N    R0,??DataTable19_1
   \   00000018   0xEB00 0x0087      ADD      R0,R0,R7, LSL #+2
   \   0000001C   0x68C4             LDR      R4,[R0, #+12]
   1092                boolean kickStartTx = FALSE;
   \   0000001E   0x2500             MOVS     R5,#+0
   \   00000020   0x.... 0x....      ADR.W    R9,emSerialTxQueueWraps
   \   00000024   0x.... 0x....      ADR.W    R10,emSerialTxQueueSizes
   \   00000028   0xE015             B.N      ??emberSerialWriteData_1
   1093          
   1094                while(length--) {
   1095                  while (! getOutputFifoSpace(q, port, 0)) {
   1096                    if (kickStartTx) {
   1097                      halInternalStartUartTx(port);
   1098                      kickStartTx = FALSE;
   1099                    }
   1100                    #ifdef EM_ENABLE_SERIAL_BLOCKING
   1101                      if (emSerialBlocking[port]) {
   1102                        simulatedSerialTimePasses();
   1103                        // Pet the watchdog here?
   1104                        continue;
   1105                      }
   1106                    #endif
   1107                    return EMBER_SERIAL_TX_OVERFLOW;
   1108                  }
   1109                  ATOMIC_LITE(
   1110                    if (q->used == 0) {
   1111                      kickStartTx = TRUE;
   1112                    }
   1113                    FIFO_ENQUEUE(q,*data,emSerialTxQueueWraps[port]);
   1114                  )
   \                     ??emberSerialWriteData_2:
   \   0000002A   0x.... 0x....      BL       _disableBasePri
   \   0000002E   0x88A1             LDRH     R1,[R4, #+4]
   \   00000030   0xB901             CBNZ.N   R1,??emberSerialWriteData_3
   \   00000032   0x2501             MOVS     R5,#+1
   \                     ??emberSerialWriteData_3:
   \   00000034   0x8821             LDRH     R1,[R4, #+0]
   \   00000036   0x1909             ADDS     R1,R1,R4
   \   00000038   0xF81B 0x2B01      LDRB     R2,[R11], #+1
   \   0000003C   0x718A             STRB     R2,[R1, #+6]
   \   0000003E   0x8821             LDRH     R1,[R4, #+0]
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   \   00000042   0xF839 0x2017      LDRH     R2,[R9, R7, LSL #+1]
   \   00000046   0x.... 0x....      BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_5:
   \   0000004A   0x8021             STRH     R1,[R4, #+0]
   \   0000004C   0x88A1             LDRH     R1,[R4, #+4]
   \   0000004E   0x1C49             ADDS     R1,R1,#+1
   \   00000050   0x80A1             STRH     R1,[R4, #+4]
   \   00000052   0x.... 0x....      BL       _writeBasePri
   1115                  data++;
   \                     ??emberSerialWriteData_1:
   \   00000056   0x4630             MOV      R0,R6
   \   00000058   0x1E46             SUBS     R6,R0,#+1
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0xB150             CBZ.N    R0,??emberSerialWriteData_4
   \   0000005E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000060   0xF83A 0x1017      LDRH     R1,[R10, R7, LSL #+1]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD3E0             BCC.N    ??emberSerialWriteData_2
   \   00000068   0xB115             CBZ.N    R5,??emberSerialWriteData_5
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       halInternalStartUartTx
   \                     ??emberSerialWriteData_5:
   \   00000070   0x2022             MOVS     R0,#+34
   \   00000072   0xE005             B.N      ??emberSerialWriteData_6
   1116                }
   1117                // make sure the interrupt is enabled so it will be sent
   1118                halInternalStartUartTx(port);
   \                     ??emberSerialWriteData_4:
   \   00000074   0x4640             MOV      R0,R8
   \   00000076   0x.... 0x....      BL       halInternalStartUartTx
   1119                return EMBER_SUCCESS;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE000             B.N      ??emberSerialWriteData_6
   1120              }
   1121          #endif
   1122          #ifdef EM_ENABLE_SERIAL_BUFFER
   1123            case EMBER_SERIAL_BUFFER:
   1124              {
   1125                // Note: We must always copy this, even in buffer mode
   1126                //  since it is ram based data and there are no reference counts
   1127                //  or indication of when it is actually written out the serial
   1128                //  we cannot trust that the data won't be changed after this call
   1129                //  but before it was actually written out.
   1130                EmberMessageBuffer buff = emberFillLinkedBuffers(data,length);
   1131                if(buff != EMBER_NULL_MESSAGE_BUFFER) {
   1132                  EmberStatus stat = emberSerialWriteBuffer(port, buff, 0, emberMessageBufferLength(buff));
   1133                  // Refcounts may be manipulated in ISR if DMA used
   1134                  ATOMIC( emberReleaseMessageBuffer(buff); )
   1135                  return stat;
   1136                } else 
   1137                  return EMBER_NO_BUFFERS;
   1138              }
   1139          #endif
   1140            default:
   1141              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteData_0:
   \   0000007E   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteData_6:
   \   00000080   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1142            }
   1143          #endif //EMBER_SERIAL_USE_STDIO
   1144          }
   1145          
   1146          #ifndef  NO_PACKET_BUFFERS

   \                                 In section .text, align 2, keep-with-next
   1147          EmberStatus emberSerialWriteBuffer(int8u port, 
   1148                                             EmberMessageBuffer buffer, 
   1149                                             int8u start, 
   1150                                             int8u length)
   1151          {
   \                     emberSerialWriteBuffer:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   1152          //Host processors do not use Ember Message Buffers.
   1153          #if defined(EZSP_HOST) || defined(EMBER_SERIAL_USE_STDIO)
   1154            return EMBER_ERR_FATAL;  //This function is invalid.
   1155          #else// !EZSP_HOST && !EMBER_SERIAL_USE_STDIO
   1156          
   1157            if(buffer == EMBER_NULL_MESSAGE_BUFFER)
   \   0000000C   0x2DFF             CMP      R5,#+255
   \   0000000E   0xD00A             BEQ.N    ??emberSerialWriteBuffer_0
   1158              return EMBER_ERR_FATAL;
   1159            if(length == 0)
   \   00000010   0xB90F             CBNZ.N   R7,??emberSerialWriteBuffer_1
   1160              return EMBER_SUCCESS;
   \                     ??emberSerialWriteBuffer_2:
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE008             B.N      ??emberSerialWriteBuffer_3
   1161          
   1162            switch(emSerialPortModes[port]) {
   \                     ??emberSerialWriteBuffer_1:
   \   00000016   0x.... 0x....      ADR.W    R0,emSerialPortModes
   \   0000001A   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0x....             LDR.N    R4,??DataTable19_2
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0xD004             BEQ.N    ??emberSerialWriteBuffer_4
   1163          #ifdef   EM_ENABLE_SERIAL_FIFO
   1164            case EMBER_SERIAL_FIFO:
   1165              {
   1166                for(;PACKET_BUFFER_SIZE <= start; start-=PACKET_BUFFER_SIZE)
   1167                  buffer = emberStackBufferLink(buffer);
   1168                
   1169                while (0 < length) {
   1170                  int8u remainingInBuffer = PACKET_BUFFER_SIZE - start;
   1171                  int8u bytes = (length < remainingInBuffer
   1172                                 ? length
   1173                                 : remainingInBuffer);
   1174                  emberSerialWriteData(port,
   1175                                       emberMessageBufferContents(buffer) + start,
   1176                                       bytes);
   1177                  length -= bytes;
   1178                  start = 0;
   1179                  buffer = emberStackBufferLink(buffer);
   1180                }
   1181                // make sure the interrupt is enabled so it will be sent
   1182                halInternalStartUartTx(port);
   1183                break;
   1184              }
   1185          #endif// EM_ENABLE_SERIAL_FIFO
   1186          #ifdef   EM_ENABLE_SERIAL_BUFFER
   1187            case EMBER_SERIAL_BUFFER:
   1188              {
   1189                EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1190                EmSerialBufferQueueEntry *e;
   1191                int8u elementsUsed;
   1192                int8u elementsDead;
   1193          
   1194                ATOMIC_LITE( // To clarify volatile access.
   1195                       elementsUsed = q->used;
   1196                       elementsDead = q->dead;
   1197                       )
   1198                
   1199                #ifdef   EM_ENABLE_SERIAL_BLOCKING
   1200                if(emSerialBlocking[port]) {
   1201                  while((elementsUsed + elementsDead) >= emSerialTxQueueSizes[port]) {
   1202                    emberSerialBufferTick();
   1203                    //re-read the element counters after clocking the serial buffers
   1204                    ATOMIC_LITE( // To clarify volatile access.
   1205                          elementsUsed = q->used;
   1206                          elementsDead = q->dead;
   1207                          )
   1208                  }
   1209                } else
   1210                #endif// EM_ENABLE_SERIAL_BLOCKING
   1211                if((elementsUsed + elementsDead) >= emSerialTxQueueSizes[port]) {
   1212                  if(elementsDead)
   1213                    emberSerialBufferTick();
   1214                  else
   1215                    return EMBER_SERIAL_TX_OVERFLOW;
   1216                }
   1217          
   1218                for(;PACKET_BUFFER_SIZE <= start; start-=PACKET_BUFFER_SIZE) {
   1219                  buffer = emberStackBufferLink(buffer);
   1220                }
   1221                emberHoldMessageBuffer(buffer);
   1222                
   1223                e = &q->fifo[q->head];
   1224                e->length = length;
   1225                e->buffer = buffer;
   1226                e->startIndex = start;
   1227                #ifdef AVR_ATMEGA
   1228                  //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1229                  //supported and therefore we use a mask
   1230                  q->head = ((q->head+1) & emSerialTxQueueMasks[port]);
   1231                #else // AVR_ATMEGA
   1232                  //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1233                  //supported and therefore we use a mod with the queue size
   1234                  q->head = ((q->head+1) % emSerialTxQueueSizes[port]);
   1235                #endif // !AVR_ATMEGA
   1236                ATOMIC_LITE(
   1237                  q->used++;
   1238                )
   1239                halInternalStartUartTx(port);  
   1240                break; 
   1241              }
   1242          #endif// EM_ENABLE_SERIAL_BUFFER
   1243            default:
   1244              return EMBER_ERR_FATAL;
   \                     ??emberSerialWriteBuffer_0:
   \   00000026   0x2001             MOVS     R0,#+1
   \                     ??emberSerialWriteBuffer_3:
   \   00000028   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??emberSerialWriteBuffer_5:
   \   0000002C   0x5C2D             LDRB     R5,[R5, R0]
   \   0000002E   0x3E20             SUBS     R6,R6,#+32
   \                     ??emberSerialWriteBuffer_4:
   \   00000030   0xB2F6             UXTB     R6,R6
   \   00000032   0x2E20             CMP      R6,#+32
   \   00000034   0xD2FA             BCS.N    ??emberSerialWriteBuffer_5
   \                     ??emberSerialWriteBuffer_6:
   \   00000036   0xF1C6 0x0020      RSB      R0,R6,#+32
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x46B9             MOV      R9,R7
   \   0000003E   0x4287             CMP      R7,R0
   \   00000040   0xBF88             IT       HI 
   \   00000042   0x4681             MOVHI    R9,R0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       emberMessageBufferContents
   \   0000004A   0xFA5F 0xF289      UXTB     R2,R9
   \   0000004E   0x1831             ADDS     R1,R6,R0
   \   00000050   0x4640             MOV      R0,R8
   \   00000052   0x.... 0x....      BL       emberSerialWriteData
   \   00000056   0xEBA7 0x0709      SUB      R7,R7,R9
   \   0000005A   0x2600             MOVS     R6,#+0
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x5C2D             LDRB     R5,[R5, R0]
   \   00000060   0xB2FF             UXTB     R7,R7
   \   00000062   0x2F00             CMP      R7,#+0
   \   00000064   0xD1E7             BNE.N    ??emberSerialWriteBuffer_6
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x.... 0x....      BL       halInternalStartUartTx
   1245            }
   1246            return EMBER_SUCCESS;
   \   0000006C   0xE7D1             B.N      ??emberSerialWriteBuffer_2
   1247          #endif// !EZSP_HOST && !EMBER_SERIAL_USE_STDIO
   1248          }
   1249          #endif// NO_PACKET_BUFFERS
   1250          
   1251          

   \                                 In section .text, align 2, keep-with-next
   1252          EmberStatus emberSerialWaitSend(int8u port)  // waits for all byte to be written out of a port
   1253          {
   \                     emberSerialWaitSend:
   \   00000000   0xB580             PUSH     {R7,LR}
   1254          #ifdef EMBER_SERIAL_USE_STDIO
   1255            fflush(stdout);
   1256          #else //EMBER_SERIAL_USE_STDIO
   1257            switch(emSerialPortModes[port]) {
   \   00000002   0x.... 0x....      ADR.W    R2,emSerialPortModes
   \   00000006   0x5C82             LDRB     R2,[R0, R2]
   \   00000008   0x2A01             CMP      R2,#+1
   \   0000000A   0xD106             BNE.N    ??emberSerialWaitSend_0
   1258          #ifdef EM_ENABLE_SERIAL_FIFO
   1259            case EMBER_SERIAL_FIFO: {
   1260              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   \   0000000C   0x....             LDR.N    R2,??DataTable19_1
   \   0000000E   0xEB02 0x0180      ADD      R1,R2,R0, LSL #+2
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   1261              while(q->used)
   \                     ??emberSerialWaitSend_1:
   \   00000014   0x888A             LDRH     R2,[R1, #+4]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1FC             BNE.N    ??emberSerialWaitSend_1
   1262                simulatedSerialTimePasses();
   1263              break; }
   1264          #endif
   1265          #ifdef EM_ENABLE_SERIAL_BUFFER
   1266            case EMBER_SERIAL_BUFFER: {
   1267              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1268              while(q->used) {
   1269                simulatedSerialTimePasses();
   1270              }
   1271              break; }
   1272          #endif
   1273            default: {
   1274            }
   1275            } // close switch.
   1276            halInternalWaitUartTxComplete(port);
   \                     ??emberSerialWaitSend_0:
   \   0000001A   0x.... 0x....      BL       halInternalWaitUartTxComplete
   1277          #endif //EMBER_SERIAL_USE_STDIO
   1278            return EMBER_SUCCESS;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
   1279          }
   1280          
   1281          //------------------------------------------------------
   1282          // Guaranteed output
   1283          
   1284          // The _only_ Guaranteed API:  The usage model for this api 
   1285          //   Does not require efficiency

   \                                 In section .text, align 2, keep-with-next
   1286          EmberStatus emberSerialGuaranteedPrintf(int8u port, PGM_P formatString, ...)
   1287          {
   \                     emberSerialGuaranteedPrintf:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB538             PUSH     {R3-R5,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1288          #ifdef EMBER_SERIAL_USE_STDIO
   1289            //TODO: This function might have to break stdio abstraction to operate
   1290            //      with interrupts off and guarantee a print.
   1291            //NOTE: The following code is the same code found in emberSerialPrintf
   1292            EmberStatus stat;
   1293            halInternalForcePrintf(TRUE);
   1294            va_list ap;
   1295            va_start (ap, formatString);
   1296            stat = emberSerialPrintfVarArg(port, formatString, ap);
   1297            va_end (ap);
   1298            halInternalForcePrintf(FALSE);
   1299            return stat;
   1300          #else //EMBER_SERIAL_USE_STDIO
   1301            va_list ap;
   1302            
   1303            // prevent interrupt driven transmission from intermixing
   1304            halInternalStopUartTx(port);
   \   00000008   0x.... 0x....      BL       halInternalStopUartTx
   1305            va_start(ap, formatString);
   \   0000000C   0xAB04             ADD      R3,SP,#+16
   1306            emPrintfInternal(halInternalForceWriteUartData, port, formatString, ap);
   \   0000000E   0x462A             MOV      R2,R5
   \   00000010   0x4621             MOV      R1,R4
   \   00000012   0x....             LDR.N    R0,??DataTable19_3
   \   00000014   0x.... 0x....      BL       emPrintfInternal
   1307            va_end(ap);
   1308          
   1309            // re-enable interrupt driven transmission if needed
   1310            switch(emSerialPortModes[port]) {
   \   00000018   0x.... 0x....      ADR.W    R1,emSerialPortModes
   \   0000001C   0x5C61             LDRB     R1,[R4, R1]
   \   0000001E   0x2901             CMP      R1,#+1
   \   00000020   0xD108             BNE.N    ??emberSerialGuaranteedPrintf_0
   1311          #ifdef EM_ENABLE_SERIAL_FIFO
   1312            case EMBER_SERIAL_FIFO: {
   1313              EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialTxQueues[port];
   1314              if(q->used)
   \   00000022   0x....             LDR.N    R1,??DataTable19_1
   \   00000024   0xEB01 0x0084      ADD      R0,R1,R4, LSL #+2
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0x8880             LDRH     R0,[R0, #+4]
   \   0000002C   0xB110             CBZ.N    R0,??emberSerialGuaranteedPrintf_0
   1315                halInternalStartUartTx(port);
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       halInternalStartUartTx
   1316              break; }
   1317          #endif
   1318          #ifdef EM_ENABLE_SERIAL_BUFFER
   1319            case EMBER_SERIAL_BUFFER: {
   1320              EmSerialBufferQueue *q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1321              if(q->used)
   1322                halInternalStartUartTx(port);
   1323              break; }
   1324          #endif
   1325            default: {
   1326            }
   1327            } //close switch.
   1328          
   1329            return EMBER_SUCCESS;
   \                     ??emberSerialGuaranteedPrintf_0:
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036                      REQUIRE ?Subroutine0
   \   00000036                      ;; // Fall through to label ?Subroutine0
   1330          #endif //EMBER_SERIAL_USE_STDIO
   1331          }
   1332          
   1333          //------------------------------------------------------
   1334          // Serial buffer maintenance

   \                                 In section .text, align 2, keep-with-next
   1335          void emberSerialFlushRx(int8u port) 
   1336          {
   \                     emberSerialFlushRx:
   \   00000000   0xB510             PUSH     {R4,LR}
   1337          #ifdef EMBER_SERIAL_USE_STDIO
   1338            ATOMIC(
   1339              while(halInternalPrintfReadAvailable()) {
   1340                (int)getchar();
   1341              }
   1342            )
   1343          #else //EMBER_SERIAL_USE_STDIO
   1344            EmSerialFifoQueue *q = (EmSerialFifoQueue *)emSerialRxQueues[port];
   \   00000002   0x....             LDR.N    R1,??DataTable19_1
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x69C4             LDR      R4,[R0, #+28]
   1345          
   1346            ATOMIC_LITE(
   1347               q->used = 0;
   1348               q->head = 0;
   1349               q->tail = 0;
   1350               )
   \   0000000A   0x.... 0x....      BL       _disableBasePri
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x80A1             STRH     R1,[R4, #+4]
   \   00000012   0x8021             STRH     R1,[R4, #+0]
   \   00000014   0x8061             STRH     R1,[R4, #+2]
   \   00000016   0x.... 0x....      BL       _writeBasePri
   1351          
   1352            halInternalRestartUart();
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      halInternalRestartUart
   1353          #endif //EMBER_SERIAL_USE_STDIO
   1354          }
   1355          
   1356          //------------------------------------------------------
   1357          // Serial Buffer Cleanup Tick
   1358          
   1359          #ifdef EM_ENABLE_SERIAL_BUFFER
   1360          //Helper function to calculate deadIndex since ifdefs cannot exist in the 
   1361          //ATOMIC_LITE block
   1362          int8u calculateDeadIndex(int8u port, int8u tail, int8u numDead) {
   1363            int8u deadIndex;
   1364            
   1365            #ifdef AVR_ATMEGA
   1366              //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1367              //supported and therefore we use a mask
   1368              deadIndex = (tail - numDead) & emSerialTxQueueMasks[port];
   1369            #else // AVR_ATMEGA
   1370              //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1371              //supported and therefore we need to use a conditional to figure
   1372              //out the deadIndex
   1373              if(numDead > tail) {
   1374                //Since subtracting numDead from tail would cause deadIndex to
   1375                //wrap, we add the tail to the queue size and then subtract
   1376                //numDead
   1377                deadIndex = (emSerialTxQueueSizes[port] + tail) - numDead;
   1378              } else {
   1379                deadIndex = tail - numDead;
   1380              }
   1381            #endif // !AVR_ATMEGA
   1382            
   1383            return deadIndex;
   1384          }
   1385          #endif //EM_ENABLE_SERIAL_BUFFER
   1386              

   \                                 In section .text, align 2, keep-with-next
   1387          void emberSerialBufferTick(void)
   1388          {
   1389          #ifdef EM_ENABLE_SERIAL_BUFFER
   1390            int8u port;
   1391            EmSerialBufferQueue *q;
   1392            int8u numDead, deadIndex;
   1393          
   1394            for(port=0; port<EM_NUM_SERIAL_PORTS; port++) {
   1395              if(emSerialPortModes[port] == EMBER_SERIAL_BUFFER) {
   1396                q = (EmSerialBufferQueue *)emSerialTxQueues[port];
   1397          
   1398                if(q->dead) {
   1399                  ATOMIC_LITE(
   1400                    numDead = q->dead;
   1401                    q->dead = 0;
   1402                    deadIndex = calculateDeadIndex(port,q->tail,numDead);
   1403                  )
   1404                  for(;numDead;numDead--) {
   1405                    // Refcounts may be manipulated in ISR if DMA used
   1406                    ATOMIC( emberReleaseMessageBuffer(q->fifo[deadIndex].buffer); )
   1407                    #ifdef AVR_ATMEGA
   1408                      //If we are using an AVR host, non power-of-2 queue sizes are NOT
   1409                      //supported and therefore we use a mask
   1410                      deadIndex = (deadIndex + 1) & emSerialTxQueueMasks[port];
   1411                    #else // AVR_ATMEGA
   1412                      //If we are using the xap2b/cortexm3, non power-of-2 queue sizes are
   1413                      //supported and therefore we use a mod with the queue size
   1414                      deadIndex = (deadIndex + 1) % emSerialTxQueueSizes[port];
   1415                    #endif // !AVR_ATMEGA
   1416                  }
   1417                }
   1418              }
   1419            }
   1420          
   1421            simulatedSerialTimePasses();
   1422          #endif
   1423          }
   \                     emberSerialBufferTick:
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x08 0x20          DC8      "\b \b"
   \              0x08 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     emSerialRxError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     emPacketBufferLinks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     halInternalForceWriteUartData

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\b \\b">`:
   \   00000000   0x08 0x20          DC8 "\010 \010"
   \              0x08 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\r\\n">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       64  emPrintfInternal
             64 -- Indirect call
             64 -> emWriteHexInternal
       16  emWriteHexInternal
        0  emberSerialBufferTick
        8  emberSerialFlushRx
              8 -> _disableBasePri
              8 -> _writeBasePri
              0 -> halInternalRestartUart
       24  emberSerialGuaranteedPrintf
             24 -> emPrintfInternal
             24 -> halInternalStartUartTx
             24 -> halInternalStopUartTx
       40  emberSerialInit
             40 -> _disableBasePri
             40 -> _writeBasePri
             40 -> halInternalRestartUart
              0 -> halInternalUartInit
        0  emberSerialPrintCarriageReturn
              0 -> emberSerialPrintf
       16  emberSerialPrintf
             16 -> emberSerialPrintfVarArg
       24  emberSerialPrintfLine
             24 -> emberSerialPrintCarriageReturn
             24 -> emberSerialPrintfVarArg
        8  emberSerialPrintfVarArg
              8 -> emPrintfInternal
        8  emberSerialReadAvailable
              8 -> halInternalUartRxPump
       24  emberSerialReadByte
             24 -> _disableBasePri
             24 -> _writeBasePri
             24 -> halInternalUartRxPump
       24  emberSerialReadData
             24 -> emberSerialReadByte
       40  emberSerialReadDataTimeout
             40 -> emberSerialReadByte
             40 -> halCommonGetInt16uMillisecondTick
       24  emberSerialReadLine
             24 -> emberSerialReadPartialLine
             24 -> halInternalResetWatchDog
       24  emberSerialReadPartialLine
             24 -> emberSerialReadByte
             24 -> emberSerialWriteData
             24 -> emberSerialWriteString
        8  emberSerialWaitSend
              8 -> halInternalWaitUartTxComplete
        0  emberSerialWriteAvailable
       32  emberSerialWriteBuffer
             32 -> emberMessageBufferContents
             32 -> emberSerialWriteData
             32 -> halInternalStartUartTx
        8  emberSerialWriteByte
              8 -> emberSerialWriteData
       40  emberSerialWriteData
             40 -> _disableBasePri
             40 -> _writeBasePri
             40 -> halInternalStartUartTx
       16  emberSerialWriteHex
             16 -> emWriteHexInternal
             16 -> emberSerialWriteData
       32  emberSerialWriteString
             32 -> _disableBasePri
             32 -> _writeBasePri
             32 -> halInternalStartUartTx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "\b \b">
       4  ?<Constant "\r\n">
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??Subroutine4_0
       6  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine2
      10  ?Subroutine3
     370  emPrintfInternal
      72  emSerial0RxQueue
     136  emSerial0TxQueue
      24  emSerial1RxQueue
     136  emSerial1TxQueue
       4  emSerialPortModes
      44  emSerialRxError
          emSerialRxErrorIndex
          emSerialTxQueues
          emSerialRxQueues
       8  emSerialRxQueueSizes
       8  emSerialRxQueueWraps
       8  emSerialTxQueueMasks
       8  emSerialTxQueueSizes
       8  emSerialTxQueueWraps
      42  emWriteHexInternal
       2  emberSerialBufferTick
      34  emberSerialFlushRx
      54  emberSerialGuaranteedPrintf
     108  emberSerialInit
       4  emberSerialPrintCarriageReturn
      16  emberSerialPrintf
      24  emberSerialPrintfLine
      36  emberSerialPrintfVarArg
      22  emberSerialReadAvailable
     142  emberSerialReadByte
      58  emberSerialReadData
      98  emberSerialReadDataTimeout
      40  emberSerialReadLine
     222  emberSerialReadPartialLine
      34  emberSerialWaitSend
      38  emberSerialWriteAvailable
     110  emberSerialWriteBuffer
      12  emberSerialWriteByte
     132  emberSerialWriteData
      24  emberSerialWriteHex
     126  emberSerialWriteString
      36  powers10

 
   368 bytes in section .bss
    44 bytes in section .data
    24 bytes in section .rodata
 1 870 bytes in section .text
 
 1 870 bytes of CODE  memory
    24 bytes of CONST memory
   412 bytes of DATA  memory

Errors: none
Warnings: none
