###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.4.54170/W32 for ARM     02/Jul/2013  21:36:30 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\cstartup-iar-common.c                          #
#    Command line =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro #
#                    \cortexm3\cstartup-iar-common.c -D DEBUG -D              #
#                    "BOARD_HEADER=\"hal/micro/cortexm3/em35x/board/dev0680.h #
#                    \"" -D "PLATFORM_HEADER=\"hal/micro/cortexm3/compiler/ia #
#                    r.h\"" -D HAL_MICRO -D CORTEXM3 -D CORTEXM3_EM357 -D     #
#                    PHY_EM3XX -D BOARD_DEV0680 -D                            #
#                    "CONFIGURATION_HEADER=\"app/sensor/sensor-configuration. #
#                    h\"" -D SINK_APP -D EMBER_SERIAL1_MODE=EMBER_SERIAL_FIFO #
#                     -D EMBER_SERIAL1_TX_QUEUE_SIZE=128 -D                   #
#                    EMBER_SERIAL1_RX_QUEUE_SIZE=16 -D EMBER_SERIAL0_DEBUG    #
#                    -D EMBER_SERIAL0_MODE=EMBER_SERIAL_FIFO -D               #
#                    EMBER_SERIAL0_TX_QUEUE_SIZE=128 -D                       #
#                    EMBER_SERIAL0_RX_QUEUE_SIZE=64 -D                        #
#                    SCAN_DEBUG_PRINT_ENABLE -D USE_BOOTLOADER_LIB -D         #
#                    "__SOURCEFILE__=\"cstartup-iar-common.c\"" -lC           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\            #
#                    --diag_suppress Pa050 -o F:\Firmware\emberZNet\firmware\ #
#                    EmberZNet\EM35x\build\sink-cortexm3-iar-em357-em3xx-dev0 #
#                    680-debug\Obj\ --debug --endian=little --cpu=Cortex-M3   #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.4\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I F:\Firmware\emberZNet\firmware\EmberZNet\EM35x #
#                    \hal\micro\cortexm3\ -I F:\Firmware\emberZNet\firmware\E #
#                    mberZNet\EM35x\app\sensor\ewb-em357\..\..\..\ -I         #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\STACK\ -I                           #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\HAL\ -I                             #
#                    F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\app\senso #
#                    r\ewb-em357\..\..\..\ -Ohz --use_c++_inline              #
#    List file    =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Lst\cstartup-ia #
#                    r-common.lst                                             #
#    Object file  =  F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\build\sin #
#                    k-cortexm3-iar-em357-em3xx-dev0680-debug\Obj\cstartup-ia #
#                    r-common.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

F:\Firmware\emberZNet\firmware\EmberZNet\EM35x\hal\micro\cortexm3\cstartup-iar-common.c
      1          //=============================================================================
      2          // FILE
      3          //   cstartup.c - Startup and low-level utility code for Ember's Cortex based
      4          //                SOCs when using the IAR toolchain.
      5          //
      6          // DESCRIPTION
      7          //   This file defines the basic information needed to go from reset up to
      8          //   the main() found in C code.
      9          //
     10          //[[   Author: Brooks Barrett, Lee Taylor  ]]
     11          //   Copyright 2009 by Ember Corporation. All rights reserved.             *80*
     12          //=============================================================================
     13          
     14          #include PLATFORM_HEADER
     15          #include "hal/micro/cortexm3/diagnostic.h"
     16          #include "hal/micro/cortexm3/mpu.h"
     17          #include "hal/micro/micro.h"
     18          #include "hal/micro/cortexm3/memmap.h"
     19          #include "hal/micro/cortexm3/cstartup-iar-common.h"
     20          #include "hal/micro/cortexm3/internal-storage.h"
     21          
     22          #include "stack/include/ember-types.h"
     23          #include "hal/micro/bootloader-interface.h"
     24          
     25          #ifdef EMBER_STACK_IP
     26            #define SOFTWARE_VERSION 0
     27            #define EMBER_BUILD_NUMBER 0
     28          #else
     29            // Pull in the SOFTWARE_VERSION from the stack
     30            #include "stack/config/config.h"
     31          #endif
     32          
     33          // Define the CUSTOMER_APPLICATION_VERSION if it wasn't set
     34          #ifndef CUSTOMER_APPLICATION_VERSION
     35            #define CUSTOMER_APPLICATION_VERSION 0
     36          #endif
     37          // Define the CUSTOMER_BOOTLOADER_VERSION if it wasn't set
     38          #ifndef CUSTOMER_BOOTLOADER_VERSION
     39            #define CUSTOMER_BOOTLOADER_VERSION 0
     40          #endif
     41          
     42          // Verify the various bootloader options that may be specified.  Use of some
     43          //   options is now deprecated and will be removed in a future release.
     44          // On the 35x platform, the use of these options is only important to specify
     45          //   the size of the bootloader, rather than the bootloader type.
     46          // By default, the lack of any option will indicate an 8k bootloader size
     47          // The NULL_BTL option indicates no bootloader is used.
     48          #ifdef APP_BTL
     49            #pragma message("The APP_BTL build option is deprecated.  Removing this option will build for any 8k bootloader type.")
     50          #endif
     51          #ifdef SERIAL_UART_BTL
     52            #pragma message("The SERIAL_UART_BTL build option is deprecated.  Removing this option will build for any 8k bootloader type.")
     53          #endif
     54          #ifdef SERIAL_OTA_BTL
     55            #pragma message("The SERIAL_UART_OTA build option is deprecated.  Removing this option will build for any 8k bootloader type.")
     56          #endif
     57          #ifdef NULL_BTL
     58            // Fully supported, no error
     59          #endif
     60          #ifdef SMALL_BTL
     61            #error SMALL_BTL is not supported
     62          #endif
     63          
     64          
     65          //=============================================================================
     66          // Define the size of the call stack and define a block of memory for it.
     67          // 
     68          // Place the cstack area in a segment named CSTACK.  This segment is
     69          // defined soley for the purpose of placing the stack.  Since this area
     70          // is manually placed, it cannot be part of the normal data initialization
     71          // and therefore must be declared '__no_init'.  Refer to reset handler for the
     72          //initialization code and iar-cfg-common.icf for segment placement in memory.
     73          // 
     74          // halResetInfo, used to store crash information and bootloader parameters, is
     75          // overlayed on top of the base of this segment so it can be overwritten by the 
     76          // call stack.
     77          // This assumes that the stack will not go that deep between reset and
     78          // use of the crash or the bootloader data.
     79          //=============================================================================
     80          #ifndef CSTACK_SIZE
     81            #if (! defined(EMBER_STACK_IP))
     82              // Pro Stack
     83          
     84              // Right now we define the stack size to be for the worst case scenario,
     85              // ECC.  The ECC library uses stack for its calculations.  Empirically I have
     86              // seen it use as much as 1504 bytes for the 'key bit generate' operation.
     87              // So we add a 25% buffer: 1504 * 1.25 = 1880
     88              // Later we may want to conditionally change the stack based on whether
     89              // or not the customer is building a Smart Energy Application.
     90              #define CSTACK_SIZE  (470)  // *4 = 1880 bytes
     91          
     92            #else
     93              // IP Stack
     94              #define CSTACK_SIZE (950) // *4 = 3800 bytes
     95            #endif // !EMBER_STACK_IP
     96          #endif

   \                                 In section CSTACK, align 4, root
     97          __root __no_init int32u cstackMemory[CSTACK_SIZE] @ __CSTACK__;
   \                     cstackMemory:
   \   00000000                      DS8 1880
     98          
     99          #ifndef HTOL_EM3XX
    100            // Create an array to hold space for the guard region. Do not actually use this
    101            // array in code as we will move the guard region around programatically. This
    102            // is only here so that the linker takes into account the size of the guard
    103            // region when configuring the RAM.
    104            #pragma data_alignment=HEAP_GUARD_REGION_SIZE_BYTES

   \                                 In section GUARD_REGION, align 32, root
    105            __root __no_init int8u guardRegionPlaceHolder[HEAP_GUARD_REGION_SIZE_BYTES] @ __GUARD_REGION__;
   \                     guardRegionPlaceHolder:
   \   00000000                      DS8 32
    106          #endif
    107          
    108          // Reset cause and crash info live in a special RAM segment that is
    109          // not modified during startup.  This segment is overlayed on top of the
    110          // bottom of the cstack.

   \                                 In section RESETINFO, align 4, root
    111          __root __no_init HalResetInfoType halResetInfo @ __RESETINFO__;
   \                     halResetInfo:
   \   00000000                      DS8 152
    112          
    113          // If space is needed in the flash for data storage like for the local storage
    114          // bootloader then create an array here to hold a place for this data.
    115          #if INTERNAL_STORAGE_SIZE_B > 0
    116            // Define the storage region as an uninitialized array in the
    117            // __INTERNAL_STORAGE__ region which the linker knows how to place.
    118            VAR_AT_SEGMENT(__root __no_init int8u internalStorage[INTERNAL_STORAGE_SIZE_B], __INTERNAL_STORAGE__);
    119          #endif
    120          
    121          //=============================================================================
    122          // Declare the address tables which will always live at well known addresses
    123          //=============================================================================

   \                                 In section FAT, align 4, root
    124          __root __no_init const HalFixedAddressTableType halFixedAddressTable @ __FAT__; 
   \                     halFixedAddressTable:
   \   00000000                      DS8 44
    125          
    126          #ifdef NULL_BTL
    127          // In the case of a NULL_BTL application, we define a dummy BAT
    128          __root const HalBootloaderAddressTableType halBootloaderAddressTable @ __BAT__ = {
    129            { __section_end("CSTACK"),
    130              halEntryPoint,
    131              halNmiIsr,
    132              halHardFaultIsr,
    133              BOOTLOADER_ADDRESS_TABLE_TYPE,
    134              BAT_NULL_VERSION,
    135              NULL                    // No other vector table.
    136            },
    137            BL_EXT_TYPE_NULL,           //int16u bootloaderType;
    138            BOOTLOADER_INVALID_VERSION, //int16u bootloaderVersion;  
    139            &halAppAddressTable,
    140            PLAT,   //int8u platInfo;   // type of platform, defined in micro.h
    141            MICRO,  //int8u microInfo;  // type of micro, defined in micro.h
    142            PHY,    //int8u phyInfo;    // type of phy, defined in micro.h
    143            0,      //int8u reserved;   // reserved for future use  
    144            NULL,   // eblProcessInit
    145            NULL,   // eblProcess
    146            NULL,   // eblDataFuncs
    147            NULL,   // eepromInit    
    148            NULL,   // eepromRead    
    149            NULL,   // eepromWrite   
    150            NULL,   // eepromShutdown
    151            NULL,   // eepromInfo    
    152            NULL,   // eepromErase   
    153            NULL,   // eepromBusy    
    154            EMBER_BUILD_NUMBER, // int16u softwareBuild;
    155            0,                  // int16u reserved2;
    156            CUSTOMER_BOOTLOADER_VERSION  // int32u customerBootloaderVersion;
    157          };
    158          #else
    159          // otherwise we just define a variable that maps to the real bootloader BAT

   \                                 In section BAT, align 4, root
    160          __root __no_init const HalBootloaderAddressTableType halBootloaderAddressTable @ __BAT__;
   \                     halBootloaderAddressTable:
   \   00000000                      DS8 84
    161          #endif
    162          

   \                                 In section AAT, align 4, root
    163          __root const HalAppAddressTableType halAppAddressTable @ __AAT__ = {
   \                     halAppAddressTable:
   \   00000000   0x........         DC32 SFE(CSTACK), halEntryPoint, halNmiIsr, halHardFaultIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x0AA7 0x0108      DC16 2727, 264
   \   00000014   0x........         DC32 __vector_table
   \   00000018   0x04 0x03          DC8 4, 3, 3, 172
   \              0x03 0xAC    
   \   0000001C   0x5000 0x005F      DC16 20480, 95
   \   00000020   0x00000000         DC32 0
   \   00000024   0x00               DC8 ""
   \   00000025   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000035   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000044   0x00000000         DC32 0
   \   00000048   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \   00000054   0x........         DC32 SFB(SIMEE), 0, SFB(INTERNAL_STORAGE), 4294967295, 4294967295
   \              0x00000000   
   \              0x........   
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \   00000068   0xFFFFFFFF         DC32 4294967295, 4294967295, 4294967295, 4294967295, 4294967295
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \              0xFFFFFFFF   
   \   0000007C   0xFFFFFFFF         DC32 4294967295, SFB(DEBUG_CHANNEL), SFB(`.noinit`), SFE(`.bss`)
   \              0x........   
   \              0x........   
   \              0x........   
   \   0000008C   0x........         DC32 SFE(`.bss`), SFE(CSTACK), SFE(`.data_init`), SFE(`.text`)
   \              0x........   
   \              0x........   
   \              0x........   
   \   0000009C   0x........         DC32 SFB(CSTACK), SFE(EMHEAP_overlay), SFE(SIMEE), SFE(DEBUG_CHANNEL)
   \              0x........   
   \              0x........   
   \              0x........   
    164            { __section_end("CSTACK"),
    165              halEntryPoint,
    166              halNmiIsr,
    167              halHardFaultIsr,
    168              APP_ADDRESS_TABLE_TYPE,
    169              AAT_VERSION,
    170              __vector_table
    171            },
    172            PLAT,  //int8u platInfo;   // type of platform, defined in micro.h
    173            MICRO, //int8u microInfo;  // type of micro, defined in micro.h
    174            PHY,   //int8u phyInfo;    // type of phy, defined in micro.h
    175            sizeof(HalAppAddressTableType),  // size of aat itself
    176            SOFTWARE_VERSION,   // int16u softwareVersion
    177            EMBER_BUILD_NUMBER, // int16u softwareBuild
    178            0,  //int32u timestamp; // Unix epoch time of .ebl file, filled in by ebl gen
    179            "", //int8u imageInfo[IMAGE_INFO_SZ];  // string, filled in by ebl generation
    180            0,  //int32u imageCrc;  // CRC over following pageRanges, filled in by ebl gen
    181            { {0xFF, 0xFF},   //pageRange_t pageRanges[6];  // Flash pages used by app, 
    182              {0xFF, 0xFF},                                 // filled in by ebl gen
    183              {0xFF, 0xFF}, 
    184              {0xFF, 0xFF}, 
    185              {0xFF, 0xFF}, 
    186              {0xFF, 0xFF} 
    187            }, 
    188            __section_begin(__SIMEE__),                         //void *simeeBottom;
    189            CUSTOMER_APPLICATION_VERSION,                       //int32u customerApplicationVersion;
    190            __section_begin(__INTERNAL_STORAGE__),              //void *internalStorageBottom;
    191            {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,    // bootloaderReserved
    192             0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF},
    193            __section_begin(__DEBUG_CHANNEL__),   //void *debugChannelBottom;
    194            __section_begin(__NO_INIT__),         //void *noInitBottom;
    195            __section_end(__BSS__),               //void *appRamTop; NO LONGER USED! (set to __BSS__ for 3xx convert)
    196            __section_end(__BSS__),               //void *globalTop;
    197            __section_end(__CSTACK__),            //void *cstackTop;  
    198            __section_end(__DATA_INIT__),         //void *initcTop;
    199            __section_end(__TEXT__),              //void *codeTop;
    200            __section_begin(__CSTACK__),          //void *cstackBottom;
    201            __section_end(__EMHEAP_OVERLAY__),    //void *heapTop;
    202            __section_end(__SIMEE__),             //void *simeeTop;
    203            __section_end(__DEBUG_CHANNEL__)      //void *debugChannelTop;
    204          };
    205          
    206          
    207          
    208          //=============================================================================
    209          // Define the vector table as a HalVectorTableType.  __root ensures the compiler
    210          // will not strip the table.  const ensures the table is placed into flash.
    211          // @ "INTVEC" tells the compiler/linker to place the vector table in the INTVEC
    212          // segment which holds the reset/interrupt vectors at address 0x00000000.
    213          // 
    214          // All Handlers point to a corresponding ISR.  The ISRs are prototyped above.
    215          // The file isr-stubs.s79 provides a weak definition for all ISRs.  To
    216          // "register" its own ISR, an application simply has to define the function
    217          // and the weak stub will be overridden.
    218          //
    219          // The list of handlers are extracted from the NVIC configuration file.  The
    220          // order of the handlers in the NVIC configuration file is critical since it
    221          // translates to the order they are placed into the vector table here.
    222          //=============================================================================

   \                                 In section .intvec, align 4, root
    223          __root const HalVectorTableType __vector_table[] @ __INTVEC__ =
   \                     __vector_table:
   \   00000000   0x........         DC32 SFE(CSTACK), halEntryPoint, halNmiIsr, halHardFaultIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x........         DC32 halMemoryFaultIsr, halBusFaultIsr, halUsageFaultIsr
   \              0x........   
   \              0x........   
   \   0000001C   0x........         DC32 halReserved07Isr, halReserved08Isr, halReserved09Isr
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 halReserved10Isr, halSvCallIsr, halDebugMonitorIsr
   \              0x........   
   \              0x........   
   \   00000034   0x........         DC32 halReserved13Isr, halPendSvIsr, halSysTickIsr, halTimer1Isr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000044   0x........         DC32 halTimer2Isr, halManagementIsr, halBaseBandIsr, halSleepTimerIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000054   0x........         DC32 halSc1Isr, halSc2Isr, halSecurityIsr, halStackMacTimerIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000064   0x........         DC32 emRadioTransmitIsr, emRadioReceiveIsr, halAdcIsr, halIrqAIsr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000074   0x........         DC32 halIrqBIsr, halIrqCIsr, halIrqDIsr, halDebugIsr, halSc3Isr
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000088   0x........         DC32 halSc4Isr, halUsbIsr
   \              0x........   
    224          {
    225            { .topOfStack = __section_end(__CSTACK__) },
    226            #ifndef INTERRUPT_DEBUGGING
    227              #define EXCEPTION(vectorNumber, functionName, priorityLevel) \
    228                functionName,
    229            #else //INTERRUPT_DEBUGGING  
    230              // The interrupt debug behavior inserts a special shim handler before
    231              // the actual interrupt.  The shim handler then redirects to the 
    232              // actual table, defined below
    233              #define EXCEPTION(vectorNumber, functionName, priorityLevel) \
    234                halInternalIntDebuggingIsr,
    235              // PERM_EXCEPTION is used for any vectors that cannot be redirected
    236              // throught the shim handler.  (such as the reset vector)
    237              #define PERM_EXCEPTION(vectorNumber, functionName, priorityLevel) \
    238                functionName,
    239            #endif //INTERRUPT_DEBUGGING
    240            #include NVIC_CONFIG
    241            #undef  EXCEPTION
    242            #undef PERM_EXCEPTION
    243          };
    244          
    245          // halInternalClassifyReset() records the cause of the last reset here

   \                                 In section .bss, align 2
    246          static int16u savedResetCause;
   \                     savedResetCause:
   \   00000000                      DS8 2
    247          

   \                                 In section .text, align 2, keep-with-next
    248          void halInternalClassifyReset(void) 
    249          {
   \                     halInternalClassifyReset:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    250            // Table used to convert from RESET_EVENT register bits to reset types
    251            static const int16u resetEventTable[] = {
    252              RESET_POWERON_HV,            // bit 0: RESET_PWRHV_BIT
    253              RESET_POWERON_LV,            // bit 1: RESET_PWRLV_BIT
    254              RESET_EXTERNAL_PIN,          // bit 2: RESET_NRESET_BIT
    255              RESET_WATCHDOG_EXPIRED,      // bit 3: RESET_WDOG_BIT
    256              RESET_SOFTWARE,              // bit 4: RESET_SW_BIT
    257              RESET_BOOTLOADER_DEEPSLEEP,  // bit 5: RESET_DSLEEP_BIT
    258              RESET_FATAL_OPTIONBYTE,      // bit 6: RESET_OPTBYTEFAIL_BIT
    259              RESET_FATAL_LOCKUP,          // bit 7: RESET_CPULOCKUP_BIT
    260            };
    261            
    262            // It is possible for RSTB and POWER_HV to be set at the same time, which
    263            // happens when RSTB releases between HV power good and LV power good. (All
    264            // other reset events are mutually exclusive.) When both RSTB and POWER_HV
    265            // are set, POWER_HV should be returned as the cause. The bit test order --
    266            // from LSB to MSB -- ensures that it will.
    267            int16u resetEvent = RESET_EVENT & 
    268                                  ( RESET_CPULOCKUP_MASK   |
    269                                    RESET_OPTBYTEFAIL_MASK |
    270                                    RESET_DSLEEP_MASK      |
    271                                    RESET_SW_MASK          |
    272                                    RESET_WDOG_MASK        |
    273                                    RESET_NRESET_MASK      |
    274                                    RESET_PWRLV_MASK       |
    275                                    RESET_PWRHV_MASK );
   \   00000002   0x....             LDR.N    R0,??DataTable3  ;; 0x4000002c
   \   00000004   0x6801             LDR      R1,[R0, #+0]
    276          
    277            int16u cause = RESET_UNKNOWN;
   \   00000006   0x2000             MOVS     R0,#+0
    278            int i;
    279          
    280            for (i = 0; i < sizeof(resetEventTable)/sizeof(resetEventTable[0]); i++) {
   \   00000008   0x2200             MOVS     R2,#+0
    281              if (resetEvent & (1 << i)) {
   \                     ??halInternalClassifyReset_0:
   \   0000000A   0x2401             MOVS     R4,#+1
   \   0000000C   0x4094             LSLS     R4,R4,R2
   \   0000000E   0xB2CB             UXTB     R3,R1
   \   00000010   0x4223             TST      R3,R4
   \   00000012   0xD012             BEQ.N    ??halInternalClassifyReset_1
    282                cause = resetEventTable[i];
   \   00000014   0x.... 0x....      ADR.W    R0,??resetEventTable
   \   00000018   0xF830 0x0012      LDRH     R0,[R0, R2, LSL #+1]
    283                break;
    284              }
    285            }
    286          
    287            if (cause == RESET_SOFTWARE) {
   \   0000001C   0xF24C 0x313C      MOVW     R1,#+49980
   \   00000020   0xF24F 0x020F      MOVW     R2,#+61455
   \   00000024   0x....             LDR.N    R3,??DataTable3_1
   \   00000026   0x2806             CMP      R0,#+6
   \   00000028   0xD111             BNE.N    ??halInternalClassifyReset_2
    288              if((halResetInfo.crash.resetSignature == RESET_VALID_SIGNATURE) &&
    289                 (RESET_BASE_TYPE(halResetInfo.crash.resetReason) < NUM_RESET_BASE_TYPES)) {
   \   0000002A   0x8858             LDRH     R0,[R3, #+2]
   \   0000002C   0x4290             CMP      R0,R2
   \   0000002E   0xD10A             BNE.N    ??halInternalClassifyReset_3
   \   00000030   0x8818             LDRH     R0,[R3, #+0]
   \   00000032   0x0A02             LSRS     R2,R0,#+8
   \   00000034   0x2A0B             CMP      R2,#+11
   \   00000036   0xD206             BCS.N    ??halInternalClassifyReset_3
    290                // The extended reset cause is recovered from RAM
    291                // This can be trusted because the hardware reset event was software
    292                //  and additionally because the signature is valid
    293                savedResetCause = halResetInfo.crash.resetReason;
   \   00000038   0xE007             B.N      ??halInternalClassifyReset_4
    294              } else {
   \                     ??halInternalClassifyReset_1:
   \   0000003A   0x1C52             ADDS     R2,R2,#+1
   \   0000003C   0x2A08             CMP      R2,#+8
   \   0000003E   0xD3E4             BCC.N    ??halInternalClassifyReset_0
    295                savedResetCause = RESET_SOFTWARE_UNKNOWN;
    296              }
    297              // mark the signature as invalid 
    298              halResetInfo.crash.resetSignature = RESET_INVALID_SIGNATURE;
    299            } else if (    (cause == RESET_BOOTLOADER_DEEPSLEEP) 
    300                        && (halResetInfo.crash.resetSignature == RESET_VALID_SIGNATURE)
    301                        && (halResetInfo.crash.resetReason == RESET_BOOTLOADER_DEEPSLEEP)) {
    302              // Save the crash info for bootloader deep sleep (even though it's not used
    303              // yet) and invalidate the resetSignature.
    304              halResetInfo.crash.resetSignature = RESET_INVALID_SIGNATURE;
    305              savedResetCause = halResetInfo.crash.resetReason;
    306            } else {
    307              savedResetCause = cause;
   \                     ??halInternalClassifyReset_5:
   \   00000040   0x....             LDR.N    R1,??DataTable3_2
   \   00000042   0x8008             STRH     R0,[R1, #+0]
    308            }
    309          }  
   \   00000044   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??halInternalClassifyReset_3:
   \   00000046   0xF44F 0x60C0      MOV      R0,#+1536
   \                     ??halInternalClassifyReset_4:
   \   0000004A   0x8059             STRH     R1,[R3, #+2]
   \   0000004C   0xE7F8             B.N      ??halInternalClassifyReset_5
   \                     ??halInternalClassifyReset_2:
   \   0000004E   0xF240 0x2407      MOVW     R4,#+519
   \   00000052   0x42A0             CMP      R0,R4
   \   00000054   0xBF01             ITTTT    EQ 
   \   00000056   0x885D             LDRHEQ   R5,[R3, #+2]
   \   00000058   0x4295             CMPEQ    R5,R2
   \   0000005A   0x881A             LDRHEQ   R2,[R3, #+0]
   \   0000005C   0x42A2             CMPEQ    R2,R4
   \   0000005E   0xD1EF             BNE.N    ??halInternalClassifyReset_5
   \   00000060   0x8059             STRH     R1,[R3, #+2]
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0xE7EC             B.N      ??halInternalClassifyReset_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??resetEventTable:
   \   00000000   0x0401 0x0402      DC16 1025, 1026, 769, 1281, 6, 519, 2307, 2305
   \              0x0301 0x0501
   \              0x0006 0x0207
   \              0x0903 0x0901
    310          

   \                                 In section .text, align 2, keep-with-next
    311          int8u halGetResetInfo(void)
    312          {
    313            return RESET_BASE_TYPE(savedResetCause);
   \                     halGetResetInfo:
   \   00000000   0x....             LDR.N    R0,??DataTable3_2
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x0A00             LSRS     R0,R0,#+8
   \   00000006   0x4770             BX       LR               ;; return
    314          }
    315          

   \                                 In section .text, align 2, keep-with-next
    316          int16u halGetExtendedResetInfo(void)
    317          {
    318            return savedResetCause;
   \                     halGetExtendedResetInfo:
   \   00000000   0x....             LDR.N    R0,??DataTable3_2
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    319          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x4000002C         DC32     0x4000002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     halResetInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     savedResetCause
    320          
    321          
    322          
    323          #ifdef INTERRUPT_DEBUGGING
    324          //=============================================================================
    325          // If interrupt debugging is enabled, the actual ISRs are listed in this
    326          // secondary interrupt table.  The halInternalIntDebuggingIsr will use this
    327          // table to jump to the appropriate handler
    328          //=============================================================================
    329          __root const HalVectorTableType __real_vector_table[] = 
    330          {
    331            { .topOfStack = __section_end("CSTACK") },
    332            #define EXCEPTION(vectorNumber, functionName, priorityLevel) \
    333              functionName,
    334              #include NVIC_CONFIG
    335            #undef EXCEPTION
    336          };
    337          
    338          //[[  Macro used with the interrupt latency debugging hooks
    339            #define ISR_TX_BIT(bit)  GPIO_PAOUT = (GPIO_PAOUT&(~PA7_MASK))|((bit)<<PA7_BIT)
    340          //]]
    341          
    342          //=============================================================================
    343          // The halInternalDebuggingIsr will intercept all exceptions in order to 
    344          // set interrupt debugging IO flags so that interrupt latency and other timings
    345          // may be measured with a logic analyzer
    346          //=============================================================================
    347          void halInternalIntDebuggingIsr(void)
    348          {
    349            boolean prevState = I_STATE(I_PORT,I_PIN);
    350            int32u exception;
    351            
    352            //[[ Additional debug output for printing, via printf, the name of the
    353            //   ISR that has been invoked and the time it took (in us).  The ISR must
    354            //   exceed a time threshold to print the name.
    355            #ifdef PRINT_ISR_NAME
    356            int32u beginTime = MAC_TIMER;
    357            int32u endTime;
    358            #endif //PRINT_ISR_NAME
    359            //]]
    360           
    361            I_SET(I_PORT, I_PIN);
    362          
    363            // call the actual exception we were supposed to go to.  The exception
    364            // number is conveniently available in the SCS_ICSR register
    365            exception = (SCS_ICSR & SCS_ICSR_VECACTIVE_MASK) >> SCS_ICSR_VECACTIVE_BIT;
    366            
    367            //[[  This is a little bit of additional debug output that serially shows
    368            //     which exception was triggered, so that long ISRs can be determined
    369            //     from a logic analyzer trace
    370            #if 0
    371            {
    372              int32u byte = (exception<<3) | 0x2;
    373              int32u i;
    374              for(i=0;i<11;i++) {
    375               ISR_TX_BIT(byte&0x1); //data bit
    376                byte = (byte>>1);
    377              }
    378              ISR_TX_BIT(1); //stop bit
    379            }
    380            #endif
    381            //]]
    382          
    383            __real_vector_table[exception].ptrToHandler();
    384          
    385            // In order to deal with the possibility of nesting, only clear the status
    386            // output if it was clear when we entered
    387            if(!prevState)
    388              I_CLR(I_PORT, I_PIN);
    389            //[[ Some additional debug output to show the ISR exited
    390            #if 0
    391            else {
    392              ISR_TX_BIT(0);
    393              ISR_TX_BIT(1);
    394            }
    395            #endif
    396            //]]
    397            
    398            //[[ Additional debug output for printing, via printf, the name of the
    399            //   ISR that has been invoked and the time it took (in us).  The ISR must
    400            //   exceed a time threshold to print the name.
    401            #ifdef PRINT_ISR_NAME
    402            endTime = MAC_TIMER;
    403            if((endTime-beginTime)>150) {
    404              EmberStatus emberSerialGuaranteedPrintf(int8u port, PGM_P formatString, ...);
    405              emberSerialGuaranteedPrintf(1, "[%d:", (endTime-beginTime));
    406              switch(INT_ACTIVE) {
    407                case INT_DEBUG:
    408                  emberSerialGuaranteedPrintf(1, "DEBUG");
    409                break;
    410                case INT_IRQD:
    411                  emberSerialGuaranteedPrintf(1, "IRQD");
    412                break;
    413                case INT_IRQC:
    414                  emberSerialGuaranteedPrintf(1, "IRQC");
    415                break;
    416                case INT_IRQB:
    417                  emberSerialGuaranteedPrintf(1, "IRQB");
    418                break;
    419                case INT_IRQA:
    420                  emberSerialGuaranteedPrintf(1, "IRQA");
    421                break;
    422                case INT_ADC:
    423                  emberSerialGuaranteedPrintf(1, "ADC");
    424                break;
    425                case INT_MACRX:
    426                  emberSerialGuaranteedPrintf(1, "MACRX");
    427                break;
    428                case INT_MACTX:
    429                  emberSerialGuaranteedPrintf(1, "MACTX");
    430                break;
    431                case INT_MACTMR:
    432                  emberSerialGuaranteedPrintf(1, "MACTMR");
    433                break;
    434                case INT_SEC:
    435                  emberSerialGuaranteedPrintf(1, "SEC");
    436                break;
    437                case INT_SC2:
    438                  emberSerialGuaranteedPrintf(1, "SC1");
    439                break;
    440                case INT_SC1:
    441                  emberSerialGuaranteedPrintf(1, "SC1");
    442                break;
    443                case INT_SLEEPTMR:
    444                  emberSerialGuaranteedPrintf(1, "SLEEPTMR");
    445                break;
    446                case INT_BB:
    447                  emberSerialGuaranteedPrintf(1, "BB");
    448                break;
    449                case INT_MGMT:
    450                  emberSerialGuaranteedPrintf(1, "MGMT");
    451                break;
    452                case INT_TIM2:
    453                  emberSerialGuaranteedPrintf(1, "TIM2");
    454                break;
    455                case INT_TIM1:
    456                  emberSerialGuaranteedPrintf(1, "TIM1");
    457                break;
    458              }
    459              emberSerialGuaranteedPrintf(1, "]");
    460            }
    461            #endif //PRINT_ISR_NAME
    462            //]]
    463          }
    464          #endif //INTERRUPT_DEBUGGING
    465          
    466          
    467          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  halGetExtendedResetInfo
        0  halGetResetInfo
       12  halInternalClassifyReset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
     144  __vector_table
    1880  cstackMemory
      32  guardRegionPlaceHolder
     172  halAppAddressTable
      84  halBootloaderAddressTable
      44  halFixedAddressTable
       6  halGetExtendedResetInfo
       8  halGetResetInfo
     102  halInternalClassifyReset
     152  halResetInfo
      16  resetEventTable
       2  savedResetCause

 
     2 bytes in section .bss
   144 bytes in section .intvec
   144 bytes in section .text
   172 bytes in section AAT
    84 bytes in section BAT
 1 880 bytes in section CSTACK
    44 bytes in section FAT
    32 bytes in section GUARD_REGION
   152 bytes in section RESETINFO
 
   144 bytes of CODE  memory
   316 bytes of CONST memory
 2 194 bytes of DATA  memory

Errors: none
Warnings: none
